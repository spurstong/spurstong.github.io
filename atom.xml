<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>房东的小黑</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/spurstong/"/>
  <updated>2020-02-22T02:47:33.933Z</updated>
  <id>https://github.com/spurstong/</id>
  
  <author>
    <name>Mara Tong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ConcurrentHashMap源码分析</title>
    <link href="https://github.com/spurstong/2020/02/20/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/spurstong/2020/02/20/ConcurrentHashMap源码分析/</id>
    <published>2020-02-20T12:56:46.299Z</published>
    <updated>2020-02-22T02:47:33.933Z</updated>
    
    <content type="html"><![CDATA[<p>ConcurrentHashMap解决了HashMap的线程不安全问题，在分析之前先介绍一个将HashMap线程安全的方法。利用<code>Collections.synchronizedMAp方法</code>调用内部类<code>SynchronizedMap</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Map m =  Collections.synchronizedMap(map);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1978198479659022715L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;     <span class="comment">// Backing Map</span></span><br><span class="line">        <span class="keyword">final</span> Object      mutex;        <span class="comment">// Object on which to synchronize</span></span><br><span class="line"></span><br><span class="line">        SynchronizedMap(Map&lt;K,V&gt; m) &#123;</span><br><span class="line">            <span class="keyword">this</span>.m = Objects.requireNonNull(m);</span><br><span class="line">            mutex = <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) &#123;</span><br><span class="line">            <span class="keyword">this</span>.m = m;</span><br><span class="line">            <span class="keyword">this</span>.mutex = mutex;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>内部主要有两个变量，一个普通变量Map,还有一个互斥锁mutex。通过构造方法将外部的Map传入进去，如果没有要传入的mutex,则将引用<code>this</code>赋值给<code>mutex</code>，就产生了一个对象实例锁。之后，要操作Map的时候只要再外部添加一个<code>synchronized</code>关键字即可，很简单，但有时会影响性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(key, value);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.remove(key);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; map)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;m.putAll(map);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mutex) &#123;m.clear();&#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="ConcurrentHashMap-JDK1-7版本"><a href="#ConcurrentHashMap-JDK1-7版本" class="headerlink" title="ConcurrentHashMap JDK1.7版本"></a>ConcurrentHashMap JDK1.7版本</h1><p>在JDK1.7中，ConcurrentHashMap是由一个Segment数组和多个HashEntry组成,每一个Segment元素存储的是HashEntry数组和链表。它采用的是<strong>分段锁</strong>技术。其中，Segment继承于ReentrantLock。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png" alt="1.7数据结构"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认的数组大小16(HashMap里的那个数组)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容因子0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//ConcurrentHashMap中的数组</span></span><br><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认并发标准16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CONCURRENCY_LEVEL = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Segment是ReentrantLock子类，因此拥有锁的操作</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="comment">//分别是数组、键值对数量、阈值、负载因子</span></span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">volatile</span> HashEntry&lt;K,V&gt;[] table;</span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line">  <span class="keyword">transient</span> <span class="keyword">int</span> threshold;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">  Segment(<span class="keyword">float</span> lf, <span class="keyword">int</span> threshold, HashEntry&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            <span class="keyword">this</span>.loadFactor = lf;</span><br><span class="line">            <span class="keyword">this</span>.threshold = threshold;</span><br><span class="line">            <span class="keyword">this</span>.table = tab;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//HashEntry对象，存key、value、hash值以及下一个节点</span></span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V value;</span><br><span class="line">        <span class="keyword">volatile</span> HashEntry&lt;K,V&gt; next;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//segment中HashEntry[]数组最小长度</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_SEGMENT_TABLE_CAPACITY = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于定位在segments数组中的位置，下面介绍</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentMask;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> segmentShift;</span><br></pre></td></tr></table></figure><p>变量<code>concurrentLevel</code>表示并发数，默认是16，理论上最多可以同时支持16个线程并发写，只要它们的操作分别分布在不同的Segment上。这个值可以在初始化的时候设置为其他值，但是一旦初始化后，它是不可以扩容的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">float</span> loadFactor, <span class="keyword">int</span> concurrencyLevel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (concurrencyLevel &gt; MAX_SEGMENTS)</span><br><span class="line">        concurrencyLevel = MAX_SEGMENTS;</span><br><span class="line">    <span class="comment">// Find power-of-two sizes best matching arguments</span></span><br><span class="line">    <span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 计算并行级别 ssize，因为要保持并行级别是 2 的 n 次方</span></span><br><span class="line">    <span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">        ++sshift;</span><br><span class="line">        ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 我们这里先不要那么烧脑，用默认值，concurrencyLevel 为 16，sshift 为 4</span></span><br><span class="line">    <span class="comment">// 那么计算出 segmentShift 为 28，segmentMask 为 15，后面会用到这两个值</span></span><br><span class="line">    <span class="keyword">this</span>.segmentShift = <span class="number">32</span> - sshift;</span><br><span class="line">    <span class="keyword">this</span>.segmentMask = ssize - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialCapacity 是设置整个 map 初始的大小，</span></span><br><span class="line">    <span class="comment">// 这里根据 initialCapacity 计算 Segment 数组中每个位置可以分到的大小</span></span><br><span class="line">    <span class="comment">// 如 initialCapacity 为 64，那么每个 Segment 或称之为"槽"可以分到 4 个</span></span><br><span class="line">    <span class="keyword">int</span> c = initialCapacity / ssize;</span><br><span class="line">    <span class="keyword">if</span> (c * ssize &lt; initialCapacity)</span><br><span class="line">        ++c;</span><br><span class="line">    <span class="comment">// 默认 MIN_SEGMENT_TABLE_CAPACITY 是 2，这个值也是有讲究的，因为这样的话，对于具体的槽上，</span></span><br><span class="line">    <span class="comment">// 插入一个元素不至于扩容，插入第二个的时候才会扩容</span></span><br><span class="line">    <span class="keyword">int</span> cap = MIN_SEGMENT_TABLE_CAPACITY; </span><br><span class="line">    <span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">        cap &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Segment 数组，</span></span><br><span class="line">    <span class="comment">// 并创建数组的第一个元素 segment[0]</span></span><br><span class="line">    Segment&lt;K,V&gt; s0 =</span><br><span class="line">        <span class="keyword">new</span> Segment&lt;K,V&gt;(loadFactor, (<span class="keyword">int</span>)(cap * loadFactor),</span><br><span class="line">                         (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap]);</span><br><span class="line">    Segment&lt;K,V&gt;[] ss = (Segment&lt;K,V&gt;[])<span class="keyword">new</span> Segment[ssize];</span><br><span class="line">    <span class="comment">// 往数组写入 segment[0]</span></span><br><span class="line">    UNSAFE.putOrderedObject(ss, SBASE, s0); <span class="comment">// ordered write of segments[0]</span></span><br><span class="line">    <span class="keyword">this</span>.segments = ss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化可以得到：<br>1）Segment数组长度为16，不可以扩容<br>2）每个Segment元素的默认长度大小为2，负载因子为0.75，得出初始阈值为1.5，当插入第二个值时会进行第一次扩容<br>3）初始化了segment[0],其他位置还是null。<br>4）当前segmentShift的值为32-4=28，segmentMask为16-1=15，先简单分别称它们为移位码和掩码。</p><h1 id="JDK1-7的put操作"><a href="#JDK1-7的put操作" class="headerlink" title="JDK1.7的put操作"></a>JDK1.7的put操作</h1><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2.png" alt="put整体流程"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        Segment&lt;K,V&gt; s;</span><br><span class="line">        <span class="comment">//注意valus不能为空！！！</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//根据key计算hash值，key也不能为null，否则hash(key)报空指针</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">        <span class="comment">//根据hash值计算在segments数组中的位置</span></span><br><span class="line">        <span class="keyword">int</span> j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;</span><br><span class="line">        <span class="comment">//查看当前数组中指定位置Segment是否为空</span></span><br><span class="line">        <span class="comment">//若为空，先创建初始化Segment再put值，不为空，直接put值。</span></span><br><span class="line">        <span class="keyword">if</span> ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          <span class="comment">// nonvolatile; recheck</span></span><br><span class="line">             (segments, (j &lt;&lt; SSHIFT) + SBASE)) == <span class="keyword">null</span>) <span class="comment">//  in ensureSegment</span></span><br><span class="line">            s = ensureSegment(j);</span><br><span class="line">        <span class="keyword">return</span> s.put(key, hash, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当key为空时，会抛出异常。根据hash来找到对应的Segment,然后执行Segment内部的put操作。<br>如果定位到的segment[j] 是空的，没有初始化，需要在该位置初始化一个Segmentj,调用方法<code>ensureSegment</code>, 要初始化的下标j是大于0的，因为segment[0]在构造函数中已经初始化了，不会为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Segment&lt;K,V&gt; <span class="title">ensureSegment</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Segment&lt;K,V&gt;[] ss = <span class="keyword">this</span>.segments;</span><br><span class="line">    <span class="keyword">long</span> u = (k &lt;&lt; SSHIFT) + SBASE; <span class="comment">// raw offset</span></span><br><span class="line">    Segment&lt;K,V&gt; seg;</span><br><span class="line">    <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里看到为什么之前要初始化 segment[0] 了，</span></span><br><span class="line">        <span class="comment">// 使用当前 segment[0] 处的数组长度和负载因子来初始化 segment[k]</span></span><br><span class="line">        <span class="comment">// 为什么要用“当前”，因为 segment[0] 可能早就扩容过了</span></span><br><span class="line">        Segment&lt;K,V&gt; proto = ss[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> cap = proto.table.length;</span><br><span class="line">        <span class="keyword">float</span> lf = proto.loadFactor;</span><br><span class="line">        <span class="keyword">int</span> threshold = (<span class="keyword">int</span>)(cap * lf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 segment[k] 内部的数组</span></span><br><span class="line">        HashEntry&lt;K,V&gt;[] tab = (HashEntry&lt;K,V&gt;[])<span class="keyword">new</span> HashEntry[cap];</span><br><span class="line">        <span class="keyword">if</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">            == <span class="keyword">null</span>) &#123; <span class="comment">// 再次检查一遍该槽是否被其他线程初始化了。</span></span><br><span class="line"></span><br><span class="line">            Segment&lt;K,V&gt; s = <span class="keyword">new</span> Segment&lt;K,V&gt;(lf, threshold, tab);</span><br><span class="line">            <span class="comment">// 使用 while 循环，内部用 CAS，当前线程成功设值或其他线程成功设值后，退出</span></span><br><span class="line">            <span class="keyword">while</span> ((seg = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(ss, u))</span><br><span class="line">                   == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(ss, u, <span class="keyword">null</span>, seg = s))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> seg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到并发，会利用CAS机制来进行初始化，加载因子和数组长度和Segment[0]一致。之后，就进入这个segment进行put操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">put</span><span class="params">(K key, <span class="keyword">int</span> hash, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//步骤① start</span></span><br><span class="line">            HashEntry&lt;K,V&gt; node = tryLock() ? <span class="keyword">null</span> :</span><br><span class="line">                scanAndLockForPut(key, hash, value);</span><br><span class="line">            <span class="comment">//步骤① end</span></span><br><span class="line">            V oldValue;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//步骤② start</span></span><br><span class="line">                <span class="comment">//获取Segment中的HashEntry[]</span></span><br><span class="line">                HashEntry&lt;K,V&gt;[] tab = table;</span><br><span class="line">                <span class="comment">//算出在HashEntry[]中的位置</span></span><br><span class="line">                <span class="keyword">int</span> index = (tab.length - <span class="number">1</span>) &amp; hash;</span><br><span class="line">                <span class="comment">//找到HashEntry[]中的指定位置的第一个节点</span></span><br><span class="line">                HashEntry&lt;K,V&gt; first = entryAt(tab, index);</span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; e = first;;) &#123;</span><br><span class="line">                    <span class="comment">//如果不为空，遍历这条链</span></span><br><span class="line">                    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        K k;</span><br><span class="line">                        <span class="comment">//情况① 之前已存过，则替换原值</span></span><br><span class="line">                        <span class="keyword">if</span> ((k = e.key) == key ||</span><br><span class="line">                            (e.hash == hash &amp;&amp; key.equals(k))) &#123;</span><br><span class="line">                            oldValue = e.value;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent) &#123;</span><br><span class="line">                                e.value = value;</span><br><span class="line">                                ++modCount;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        e = e.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//情况② 另一个线程的准备工作</span></span><br><span class="line">                        <span class="keyword">if</span> (node != <span class="keyword">null</span>)</span><br><span class="line">                            <span class="comment">//链表头插入方式</span></span><br><span class="line">                            node.setNext(first);</span><br><span class="line">                        <span class="keyword">else</span> <span class="comment">//情况③ 该位置为空，则新建一个节点(注意这里采用链表头插入方式)</span></span><br><span class="line">                            node = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(hash, key, value, first);</span><br><span class="line">                        <span class="comment">//键值对数量+1</span></span><br><span class="line">                        <span class="keyword">int</span> c = count + <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">//如果键值对数量超过阈值</span></span><br><span class="line">                        <span class="keyword">if</span> (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)</span><br><span class="line">                            <span class="comment">//扩容</span></span><br><span class="line">                            rehash(node);</span><br><span class="line">                        <span class="keyword">else</span> <span class="comment">//未超过阈值，直接放在指定位置</span></span><br><span class="line">                            setEntryAt(tab, index, node);</span><br><span class="line">                        ++modCount;</span><br><span class="line">                        count = c;</span><br><span class="line">                        <span class="comment">//插入成功返回null</span></span><br><span class="line">                        oldValue = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//步骤② end</span></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//步骤③</span></span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//修改成功，返回原值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>在执行put操作时首先调用<code>tryLock</code>尝试获得锁，如果获取失败就说明有其他线程竞争，则利用scanAndLockForPut()通过自旋获取锁。在里面如果重试的次数达到了<code>max_scan_retries</code>则改为阻塞锁获取，保证能获得成功。之后就是按照hashmap的1.7版本的put操作那样插入数据，即是按头插法插入的。最后是解锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法参数上的 node 是这次扩容后，需要添加到新的数组中的数据。</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">(HashEntry&lt;K,V&gt; node)</span> </span>&#123;</span><br><span class="line">    HashEntry&lt;K,V&gt;[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="comment">// 2 倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    <span class="comment">// 创建新数组</span></span><br><span class="line">    HashEntry&lt;K,V&gt;[] newTable =</span><br><span class="line">        (HashEntry&lt;K,V&gt;[]) <span class="keyword">new</span> HashEntry[newCapacity];</span><br><span class="line">    <span class="comment">// 新的掩码，如从 16 扩容到 32，那么 sizeMask 为 31，对应二进制 ‘000...00011111’</span></span><br><span class="line">    <span class="keyword">int</span> sizeMask = newCapacity - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历原数组，老套路，将原数组位置 i 处的链表拆分到 新数组位置 i 和 i+oldCap 两个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; oldCapacity ; i++) &#123;</span><br><span class="line">        <span class="comment">// e 是链表的第一个元素</span></span><br><span class="line">        HashEntry&lt;K,V&gt; e = oldTable[i];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HashEntry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="comment">// 计算应该放置在新数组中的位置，</span></span><br><span class="line">            <span class="comment">// 假设原数组长度为 16，e 在 oldTable[3] 处，那么 idx 只可能是 3 或者是 3 + 16 = 19</span></span><br><span class="line">            <span class="keyword">int</span> idx = e.hash &amp; sizeMask;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)   <span class="comment">// 该位置处只有一个元素，那比较好办</span></span><br><span class="line">                newTable[idx] = e;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">// Reuse consecutive sequence at same slot</span></span><br><span class="line">                <span class="comment">// e 是链表表头</span></span><br><span class="line">                HashEntry&lt;K,V&gt; lastRun = e;</span><br><span class="line">                <span class="comment">// idx 是当前链表的头结点 e 的新位置</span></span><br><span class="line">                <span class="keyword">int</span> lastIdx = idx;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 下面这个 for 循环会找到一个 lastRun 节点，这个节点之后的所有元素是将要放到一起的</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; last = next;</span><br><span class="line">                     last != <span class="keyword">null</span>;</span><br><span class="line">                     last = last.next) &#123;</span><br><span class="line">                    <span class="keyword">int</span> k = last.hash &amp; sizeMask;</span><br><span class="line">                    <span class="keyword">if</span> (k != lastIdx) &#123;</span><br><span class="line">                        lastIdx = k;</span><br><span class="line">                        lastRun = last;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将 lastRun 及其之后的所有节点组成的这个链表放到 lastIdx 这个位置</span></span><br><span class="line">                newTable[lastIdx] = lastRun;</span><br><span class="line">                <span class="comment">// 下面的操作是处理 lastRun 之前的节点，</span></span><br><span class="line">                <span class="comment">//    这些节点可能分配在另一个链表中，也可能分配到上面的那个链表中</span></span><br><span class="line">                <span class="keyword">for</span> (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) &#123;</span><br><span class="line">                    V v = p.value;</span><br><span class="line">                    <span class="keyword">int</span> h = p.hash;</span><br><span class="line">                    <span class="keyword">int</span> k = h &amp; sizeMask;</span><br><span class="line">                    HashEntry&lt;K,V&gt; n = newTable[k];</span><br><span class="line">                    newTable[k] = <span class="keyword">new</span> HashEntry&lt;K,V&gt;(h, p.key, v, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将新来的 node 放到新数组中刚刚的 两个链表之一 的 头部</span></span><br><span class="line">    <span class="keyword">int</span> nodeIndex = node.hash &amp; sizeMask; <span class="comment">// add the new node</span></span><br><span class="line">    node.setNext(newTable[nodeIndex]);</span><br><span class="line">    newTable[nodeIndex] = node;</span><br><span class="line">    table = newTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码先找出扩容前后需要转移的节点，先执行转移，然后在把该条链上剩下的节点转移。整体的put流程图如下：</p><p><strong>get方法分析</strong><br>1）计算hash值，找到segment数组中的具体位置<br>2）槽中也是一个数组，根据hash找到数组中的具体位置<br>3）这个时候获取到的是链表了，顺着链表进行查找就可以了<br>get方法比较简单，它能够实现无锁化操作的主要原因是使用UNSAFE对象的getObjectVolatile()方法提供原子语义，来获取segment和头节点。</p><h1 id="jDK-1-8版本"><a href="#jDK-1-8版本" class="headerlink" title="jDK 1.8版本"></a>jDK 1.8版本</h1><p>在jdk1.8版本中ConcurrentHashMap利用CAS+Sychronized来确保线程安全，它的底层数组结构依然是数组+链表+红黑树<br><strong>重要属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放node的数组，大小是2的幂次方</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node[] table;</span><br><span class="line"><span class="comment">//扩容时用于存放数据的变量，平时为null</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node[] nextTable;</span><br><span class="line"><span class="comment">//通过CAS更新，记录容器的容量大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制标志符</span></span><br><span class="line"><span class="comment"> * 负数: 代表正在进行初始化或扩容操作，其中-1表示正在初始化，-N 表示有N-1个线程正在进行扩容操作</span></span><br><span class="line"><span class="comment"> * 正数或0: 代表hash表还没有被初始化，这个数值表示初始化或下一次进行扩容的大小，类似于扩容阈值</span></span><br><span class="line"><span class="comment"> * 它的值始终是当前ConcurrentHashMap容量的0.75倍，这与loadfactor是对应的。</span></span><br><span class="line"><span class="comment"> * 实际容量 &gt;= sizeCtl，则扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"><span class="comment">//下次transfer方法的起始下标index加上1之后的值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br><span class="line"><span class="comment">//CAS自旋锁标志位</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"><span class="comment">//counter cell表，长度总为2的幂次</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br></pre></td></tr></table></figure><p><strong>重要内部类</strong><br>Node节点类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="keyword">volatile</span> V val;</span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>value和next属性用volatile修饰保证了内存可见性，没有setValue方法直接改变Node的value属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span> <span class="keyword">extends</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node[] nextTable;</span><br><span class="line">        <span class="comment">//ForwardingNode节点hash为-1，若操作中遇到此类型节点，表明有线程正在扩容</span></span><br><span class="line">        ForwardingNode(Node[] tab) &#123;</span><br><span class="line">            <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ForwardingNode是一种临时节点只有扩容时使用，表明当前桶已做过处理。<br><strong>initTable方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node[] initTable() &#123;</span><br><span class="line">        Node[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">        <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//若sizeCtl&lt;0，即存在其他线程正在初始化操作，确保只有一个线程进行初始化</span></span><br><span class="line">            <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">                Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">            <span class="comment">//利用CAS方法把sizectl的值置为-1，表明已有线程进行初始化</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//获得桶容量</span></span><br><span class="line">                        <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                        <span class="comment">//初始化node数组</span></span><br><span class="line">                        Node[] nt = (Node[])<span class="keyword">new</span> Node[n];</span><br><span class="line">                        table = tab = nt;</span><br><span class="line">                        <span class="comment">//计算扩容阈值0.75n</span></span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>只有一个线程参与初始化过程，其他线程必须挂起；构造函数不初始化过程，初始化真正是在put操作触发。<br>当sizeCtl为-1时表明已有一个线程正在执行初始化操作，当前线程要执行<code>Thread.yield()</code>操作让出CPU时间片。而正在进行初始化的线程会利用CAS操作将sizeCtl改为-1，创建出一个数组后，并将sizeCtl赋值为当前可用的数组大小。</p><p>整体流程：<br>1）首先对于每一个放入的值，首先利用spread方法对key的hashcode进行一次hash计算，获取在table数组的索引下标地址<br>2）如果当前table还没有初始化，先调用<code>initTable()</code>进行初始化<br>3）如果该位置为null,说明还没有数据放入，则利用CAS操作直接放入<br>4）如果不为空，说明存在哈希碰撞，当fh==MOED(-1),说明数组正在扩容<br>5）当数组不在扩容状态，对该节点利用<code>sychronized</code>加锁，然后再进行一次判断当前节点是否发生变化，没有变化执行下面的方法；发生了变化直接跳转到第8步<br>6）如果是链表节点（fh&gt;0）,开始遍历链表节点，如果key相等，则进行值覆盖；如果都没有到节点尾部插入新节点<br>7）如果这个节点类型是TreeBin，利用红黑树的方法插入新的节点。<br>8）如果链表长度大于8，则利用<code>treeifyBin</code>把这个链表转化为红黑树，但是不是大于8就转化为红黑树，当数组长度小于<code>MIN_TREEIFY_CAPACITY</code>(默认是64)时，进行扩容操作。<br>9）如果当前实际大小数量+1超过了临界值，就进行扩容<br><strong>spread()方法</strong><br>计算hash,主要是将key的hashcode的低16位和高16位进行异或运算，0x7fffffff主要是<br>用于和负数hash值进行 &amp; 运算，将其转化为正数（绝对值不相等）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="transfer-扩容操作"><a href="#transfer-扩容操作" class="headerlink" title="transfer 扩容操作"></a>transfer 扩容操作</h1><p>总体流程：<br>1）计算每个线程可以处理的桶区间，默认16<br>2） 构建一个nextTable,容量是原来的两倍<br>3）死循环开始，根据一个finishing变量来判断，当为true时表示扩容结束，否则继续扩容<br>3.1）进入一个while循环，分配数组中一个桶的区间给线程，默认是16。从大到小进行分配。当拿到分配值后，进行i–递减。这个i是数组下标。其中，<code>bound</code>变量是指该线程此次可以处理的区间的最小下标，超过这个下标，就需要重新领取区间或者结束扩容；<code>advance</code>变量是值是否转移到下一个桶，如果为true,表明该桶已经处理好了，向下一个桶推进;如果为false,说明还没有处理好当前桶，不能推进。<br>3.2）判断扩容是否结束，如果扩容结束，清空临时变量，更新table变量，更新库容阈值<br>3.3）如果当前桶内没有节点，则通过CAS操作插入到<code>ForwardingNode</code>节点，用于告诉其他线程该桶已经处理了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">                advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br></pre></td></tr></table></figure><p>3.4）如果当前桶已经被其他线程处理了，当前线程处理到这个节点时，获得的<code>hash</code>值应该为-1（MOVED）,则直接跳过，向前一个桶处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br></pre></td></tr></table></figure><p>4） 如果该桶没有被处理，则开始李勇<code>sychronized</code>加锁，然后再判断一下该桶的头节点是否发生了变化，没有发生变化继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br></pre></td></tr></table></figure><p>4.1）如果该桶存储的是链表的话<br>4.1.1）因为扩容后与扩容前就增加了一位，只要比较新增的最高位是1还是0即可。<code>int runBit = fh &amp; n;</code>是标识新增的位标志。然后开始对链表进行遍历。<code>lastRun</code>表示该节点及剩余的节点的新位置都是一样的，不需要再向下遍历，只要把这部分的头结点，即<code>lastRun</code>移动到新的位置，就能使剩余的部分都移到了新位置。此时的<code>runBit</code>表示该节点位置的标识，可能是1，也可能是0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; lastRun = f;</span><br><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">      <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">      <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">         runBit = b;</span><br><span class="line">         lastRun = p;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.1.2）如果最后一个需要移动的节点是到原来的索引下标下，则将低位置头结点<code>ln=lastRun</code>;如果是到新的索引下标下，则将高位置头节点设置为<code>hn = lastRun;</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">ln = lastRun;</span><br><span class="line">hn = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">hn = lastRun;</span><br><span class="line">ln = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.1.3）然后对链表进行遍历，知道最后一个需要移动的节点就终止，将节点分别插入到<code>ln</code>和<code>hn</code>,利用头插法插入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">    <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">    <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">        ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>4.1.4 ）分别将<code>ln</code>和<code>hn</code>插入到新数组，并将旧数组的该位置的节点变成<code>ForwardingNode</code>类型。之后，设置<code>advance</code>为true,表明该桶处理完了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTabAt(nextTab, i, ln);</span><br><span class="line">setTabAt(nextTab, i + n, hn);</span><br><span class="line">setTabAt(tab, i, fwd);</span><br><span class="line">advance = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>4.2）如果桶存储的是红黑树类型<br>也是判断是最高位是0还是1，生成两个树<code>lo</code>和<code>hi</code>,然后判断这个树如果小于6，就转化为链表，如果不是，则处理成标准的红黑树。之后，设置<code>advance</code>为true,表明该桶处理完了。</p><p>在旧数组中节点设置为<code>ForwardingNode</code>，表明该节点已经被处理了，里面的nextTable执行新的数组。</p><h1 id="get（）方法"><a href="#get（）方法" class="headerlink" title="get（）方法"></a>get（）方法</h1><p>先通过hash值获取在哪个桶，如果头节点的key相等，则返回值。如果hash小于0，表明该节点是<code>ForwardingNode</code>类型，已经发生了移动，则调用该类型节点的<code>find</code>方法查找；其他情况就是遍历链表记行查询。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">        <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// loop to avoid arbitrarily deep recursion on forwarding nodes</span></span><br><span class="line">           outer: <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e; <span class="keyword">int</span> n;</span><br><span class="line">               <span class="keyword">if</span> (k == <span class="keyword">null</span> || tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">                   (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                   <span class="keyword">int</span> eh; K ek;</span><br><span class="line">                   <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp;</span><br><span class="line">                       ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                       <span class="keyword">return</span> e;</span><br><span class="line">                   <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;</span><br><span class="line">                           tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</span><br><span class="line">                           <span class="keyword">continue</span> outer;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">else</span></span><br><span class="line">                           <span class="keyword">return</span> e.find(h, k);</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><strong>参考文章：</strong></p><ol><li><a href="https://juejin.im/post/5a2f2f7851882554b837823a" target="_blank" rel="noopener">图解ConcurrentHashMap</a></li><li><a href="https://zhuanlan.zhihu.com/p/42792443" target="_blank" rel="noopener">第四天：ConcurrentHashMap全解析（上）</a></li><li><a href="https://juejin.im/post/5b53d1adf265da0f70070e3d" target="_blank" rel="noopener">Java并发——ConcurrentHashMap(JDK 1.8）</a></li><li><a href="https://www.jianshu.com/p/f6730d5784ad" target="_blank" rel="noopener">深入分析ConcurrentHashMap1.8的扩容实现</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ConcurrentHashMap解决了HashMap的线程不安全问题，在分析之前先介绍一个将HashMap线程安全的方法。利用&lt;code&gt;Collections.synchronizedMAp方法&lt;/code&gt;调用内部类&lt;code&gt;SynchronizedMap&lt;/cod
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>轻量级RPC设计与实现第五版(最终版)</title>
    <link href="https://github.com/spurstong/2020/02/15/%E8%BD%BB%E9%87%8F%E7%BA%A7RPC%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%BA%94%E7%89%88(%E6%9C%80%E7%BB%88%E7%89%88)/"/>
    <id>https://github.com/spurstong/2020/02/15/轻量级RPC设计与实现第五版(最终版)/</id>
    <published>2020-02-15T11:27:49.900Z</published>
    <updated>2020-02-15T14:46:59.840Z</updated>
    
    <content type="html"><![CDATA[<p>在最近一段时间里，通过搜集有关资料加上自己的理解，设计了一款轻量级RPC,起了一个名字<strong>lightWeightRPC</strong>。它拥有一个RPC常见的基本功能。主要功能和特点如下：</p><ul><li>利用Spring实现依赖注入与参数配置</li><li>利用Netty来实现客户端与服务端的远程通信</li><li>利用Hessian来实现序列化</li><li>设置Zookeeper作为注册中心</li><li>新设监控器，通过心跳机制来判断服务端与监控器的网络连接状况，当出现不稳定时，认为服务端出现了问题，在注册中心删除相关的服务信息。</li><li>利用Netty的Promise来实现异步的传送</li><li>构建线程池来管理发送的请求线程</li><li>添加服务缓存机制，在注册中心宕机的情况下仍能进行服务消费。</li><li>支持服务扩展点发现机制（SPI）,对Spring的SPI机制进行改进，解决了依赖注入问题。</li><li>在客户端从注册中心获取服务时，添加监听器，当注册中心对应节点发生变化时通知客户端修改本地缓存信息。</li></ul><p>以上是<strong>lightWeightRPC</strong>的全部功能，本版本添加的内容就是最后一个功能，为服务节点添加监听器。<br>因为之前在本地添加了持久化的缓存，当服务消费时会先从缓存中查找信息，查不到再到注册中心查找，但是当服务地址等信息发生变化时，如果不对缓存信息进行修改就可能会发生错误。所以在本版本中为服务节点添加了监听器。</p><h1 id="如何添加监听器"><a href="#如何添加监听器" class="headerlink" title="如何添加监听器"></a>如何添加监听器</h1><p>当客户端首次从注册中心获取服务信息时，会对有关服务节点添加监听器,具体方法在<code>addListenerForService</code>，设置完监听后，再获取相关服务节点信息，并封装在URL类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;URL&gt; <span class="title">getServiceInfo</span><span class="params">(String interfaceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            addListenerForService(interfaceName);</span><br><span class="line">            System.out.println(<span class="string">"开始查找服务节点："</span> + getPath(interfaceName));</span><br><span class="line">            List&lt;String&gt; urlList = client.getChildren().forPath(<span class="string">"/"</span> + interfaceName);</span><br><span class="line">            System.out.println(<span class="string">"结果："</span> + urlList);</span><br><span class="line">            List&lt;URL&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(String serviceUrl : urlList) &#123;</span><br><span class="line">                String[] urls = serviceUrl.split(<span class="string">":"</span>);</span><br><span class="line">                String implClassName = get(interfaceName, serviceUrl);</span><br><span class="line">                System.out.println(implClassName);</span><br><span class="line">                result.add(<span class="keyword">new</span> URL(urls[<span class="number">0</span>], Integer.valueOf(urls[<span class="number">1</span>]), interfaceName, implClassName));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在添加监听器时主要是<code>PathChildrenCache</code>类，当节点发生变化时会触发<code>childEvent</code>事件，根据不同的状态采取不同的策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> PathChildrenCache childrenCache = <span class="keyword">new</span> PathChildrenCache(client, getPath(serviceName), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步初始监听点childrenCache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);</span></span><br><span class="line">childrenCache.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;          <span class="keyword">if</span>(event.getType().equals(PathChildrenCacheEvent.Type.INITIALIZED)) &#123;</span><br><span class="line">                    <span class="comment">//建立完监听</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="comment">//删除远程服务节点</span></span><br><span class="line">  <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_REMOVED)) &#123;</span><br><span class="line">                    String path = event.getData().getPath();</span><br><span class="line">                    FileUtil fileUtil = <span class="keyword">new</span> FileUtil(<span class="keyword">true</span>);</span><br><span class="line">                    fileUtil.alterServiceCache(serviceName, path);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>至此，一个RPC设计完成了，有一些不足，希望大家多多指正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在最近一段时间里，通过搜集有关资料加上自己的理解，设计了一款轻量级RPC,起了一个名字&lt;strong&gt;lightWeightRPC&lt;/strong&gt;。它拥有一个RPC常见的基本功能。主要功能和特点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用Spring实现依赖注入与参数配置&lt;/l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dubbo之服务消费</title>
    <link href="https://github.com/spurstong/2020/02/04/Dubbo%E4%B9%8B%E6%9C%8D%E5%8A%A1%E5%BC%95%E7%94%A8/"/>
    <id>https://github.com/spurstong/2020/02/04/Dubbo之服务引用/</id>
    <published>2020-02-04T06:01:38.356Z</published>
    <updated>2020-02-04T11:41:19.189Z</updated>
    
    <content type="html"><![CDATA[<p>Dubbo的服务消费主要包括两个部分。第一大步是<code>ReferenceConfig</code>类的<code>init</code>方法调用<code>Protocol</code>的<code>refer</code>方法生成<code>Invoker</code>实例，这是服务消息的关键。第二大步是把Invoker通过动态代理转换成实现用户接口的动态代理引用。这里的Invoker承载了网络连接、服务调用和重试等功能。</p><h1 id="服务暴露起点"><a href="#服务暴露起点" class="headerlink" title="服务暴露起点"></a>服务暴露起点</h1><p>在消费者的配置文件中存在这个代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;</span><br><span class="line">&lt;dubbo:reference id=<span class="string">"demoService"</span> <span class="class"><span class="keyword">interface</span></span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span> /&gt;</span><br></pre></td></tr></table></figure><p>它会生成一个<code>ReferenceBean</code>,实现了FactoryBean接口，继承了ReferenceConfig,所以ReferenceBean作为dubbo中能够生产对象的工厂Bean,而我们要引用服务，也就要有一个该服务的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ReferenceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">FactoryBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>服务引用被触发有两个时机：</p><ul><li>Spring容器调用ReferenceBean的afterPropertiesSet方法时引用服务（饿汉式）</li><li>在ReferenceBean对应的服务被注入到其他类中时引用（懒汉式）</li></ul><p>默认情况下，Dubbo使用懒汉式引用服务。如果需要使用饿汉式，可通过配置<a href="dubbo:reference" target="_blank" rel="noopener">dubbo:reference</a>的init属性开启。</p><p>因为ReferenceBean实现了FactoryBean接口的getObject()方法，所以在加载bean的时候，会调用ReferenceBean的getObject()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReferenceBean.getObject()  ---&gt;  ReferenceConfig.get()   --&gt; ReferenceConfig.init()</span><br></pre></td></tr></table></figure><p>在init()方法中主要有这几步：<br>(1) 检测本地存根和mock合法性<br>(2) 添加协议版本、发布版本、时间戳、application、module、consumer、protocol等所有信息到map中。<br>(3) 单独处理方法配置，设置重试次数配置以及设置该方法对异步配置信息。<br>(4) 添加消费者ip地址到map<br>(5)创建代理对象,调用<code>ReferenceConfig.createProxy()</code>方法。<br>(6) 生成ConsumerMpdel存入到ApplicationModel中。</p><p>之后介绍<code>ReferenceConfig.createProxy()</code>方法。主要有下面几步：</p><ul><li>如果是本地调用，则直接使用InjvmProtocol的refer方法生成Invoker实例。</li><li>如果不是本地调用，但是选择直连的方式进行调用，则分割配置的多个url。如果协议是配置registry,则表明用户想使用指定的注册中心，配置url后将url保存到urls里面，否则就合并url,并且保存到urls。</li><li>如果是通过注册中心来进行调用，则先校验所有的注册中心，然后假加载注册中心的url,遍历每个url,加入监控中心url配置，最后把每个url保存到urls。</li><li>如果urls的个数是1，是单注册中心，直接引用RegistryProtocol的refer构建Invoker实例；如果urls的数量大于1，说明是多注册中心，则对每个url都生成Invoker,利用<code>cluster.join()</code>方法将多个Invoker进行合并成一个Invoker。</li><li>最后调用<code>proxyFactory.getProxy(invoker)</code>方法。</li></ul><p>然后介绍<code>RegistryProtocol.refer(Class&lt;T&gt; type, URL url)</code>方法生成invoker。</p><p>如果是注册中心服务，则直接返回注册中心服务的invoker;如果不是，则先处理组配置，根据组配置来决定Cluster的实现方式，如果有多个组，则使用MergeableCluster,然后调用doRefer(Cluster, Registry, Class, URL)方法。</p><p>然后介绍<code>doRefer()</code>方法。<br>(1) 创建一个RegistryDirectory实例，设置注册中心、协议等信息<br>(2) 生成服务消费者链接。<br>(3) 注册消费信息到注册中心。<br>(4) 订阅该服务下的providers、configurators、routers等节点下的数据。完成订阅后，RegistryDirectory会受到这几个节点下的子节点信息。<br>(5) 由于一个服务可能部署在多台服务器上，这样就会在providers产生多个节点，这个时候就需要Cluster将多个服务节点合并成一个，并生成一个Invoker.</p><p>在RegistryDirectory实现了NotifyListener接口，服务变更会触发这个类回调notify方法，用于重新引用服务。当发起订阅请求时会进行一次数据拉取操作，同时触发<code>RegistryDirectory.nofity()</code>方法。这是会执行<code>toInvokers()</code>方法进行Invoker转换。<br>(1) 根据消费者protocol配置过滤不匹配的协议。<br>(2) 合并provider端配置数据，比如服务端IP和port等。<br>(3) 忽略重复推送的服务列表<br>(4) 使用具体协议创建远程连接,<code>new InvokerDelegate&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl)</code>。</p><p>具体的Invoker创建是在<code>DubboProtocol.refer()</code>中实现。Dubbo协议在返回DubboInvoker对象之前会初始化客户端连接对象。<br>调用DubboProtocol.initClient()方法 -&gt; Exchangers.connect()方法，根据SPI机制加载HeaderExchangeClent，调用connect()方法。然后调用Transporter类的connect()方法，默认是NettyTransporter类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeClient[] clients;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicPositiveInteger index = <span class="keyword">new</span> AtomicPositiveInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String version;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock destroyLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Invoker&lt;?&gt;&gt; invokers;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; attachment;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> available = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean destroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Dubbo的服务消费主要包括两个部分。第一大步是&lt;code&gt;ReferenceConfig&lt;/code&gt;类的&lt;code&gt;init&lt;/code&gt;方法调用&lt;code&gt;Protocol&lt;/code&gt;的&lt;code&gt;refer&lt;/code&gt;方法生成&lt;code&gt;Invoker&lt;/cod
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dubbo之服务注册</title>
    <link href="https://github.com/spurstong/2020/02/04/Dubbo%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C/"/>
    <id>https://github.com/spurstong/2020/02/04/Dubbo之服务注册/</id>
    <published>2020-02-04T02:26:52.585Z</published>
    <updated>2020-02-04T14:17:27.048Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇文章<strong>Dubbo之服务暴露分析</strong>中介绍了当远程暴露时，如果有注册中心，需要在服务暴露后再将服务注册到注册中心。该篇将介绍该功能的有关步骤。</p><h1 id="注册的起点"><a href="#注册的起点" class="headerlink" title="注册的起点"></a>注册的起点</h1><p>在<code>RegistryProtocol.export()</code>方法包含了服务导出，注册，以及数据订阅等逻辑。其中服务注册先调用<code>RegistryProtocol.register()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL registryUrl, URL registeredProviderUrl)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 Registry</span></span><br><span class="line">    Registry registry = registryFactory.getRegistry(registryUrl);</span><br><span class="line">    <span class="comment">// 注册服务</span></span><br><span class="line">    registry.register(registeredProviderUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，服务注册主要包括两部分，<strong>获取注册中心实例</strong>和<strong>向注册中心注册服务</strong>。</p><h1 id="获取注册中心实例"><a href="#获取注册中心实例" class="headerlink" title="获取注册中心实例"></a>获取注册中心实例</h1><p>（1）调用<code>registryFactory.getRegistry(registryUrl)</code>方法，它会先访问缓存，缓存中不存在则调用<code>createRegistry(URL)</code>方法创建Registry,然后写入缓存。这里的createRegistry是一个模版方法，有具体的子类实现。这里假设使用zookeeper作为注册中心，则调用ZookeeperRegistryFactory的createRegistry()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Registry <span class="title">createRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建 ZookeeperRegistry</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ZookeeperRegistry(url, zookeeperTransporter);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ZookeeperRegistry</span><span class="params">(URL url, ZookeeperTransporter zookeeperTransporter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(url);</span><br><span class="line">    <span class="keyword">if</span> (url.isAnyHost()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"registry address == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取组名，默认为 dubbo</span></span><br><span class="line">    String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);</span><br><span class="line">    <span class="keyword">if</span> (!group.startsWith(Constants.PATH_SEPARATOR)) &#123;</span><br><span class="line">        <span class="comment">// group = "/" + group</span></span><br><span class="line">        group = Constants.PATH_SEPARATOR + group;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.root = group;</span><br><span class="line">    <span class="comment">// 创建 Zookeeper 客户端，默认为 CuratorZookeeperTransporter</span></span><br><span class="line">    zkClient = zookeeperTransporter.connect(url);</span><br><span class="line">    <span class="comment">// 添加状态监听器</span></span><br><span class="line">    zkClient.addStateListener(<span class="keyword">new</span> StateListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (state == RECONNECTED) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    recover();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.error(e.getMessage(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 在<code>ZookeeperRegistry</code>构造方法中调用<code>connect(url)</code>方法,默认是<code>CuratorZookeeperClient</code>, 获得一个ZkClient客户端，之后添加状态监听器。</p><h1 id="向注册中心注册服务"><a href="#向注册中心注册服务" class="headerlink" title="向注册中心注册服务"></a>向注册中心注册服务</h1><p>假设存在一个服务com.alibaba.dubbo.demo.DemoService， 那么 这个服务对应的配置信息（存储在 URL 中）最终被注册到了 /dubbo/com.alibaba.dubbo.demo.DemoService/providers/ 节点下。<br>(1) 调用<code>FailbackRegistry.register()</code>方法，之后调用里面的<code>doRegister</code>方法，它是一个模版方法，在<code>ZookeeperRegistry</code>中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过 Zookeeper 客户端创建节点，节点路径由 toUrlPath 方法生成，路径格式如下:</span></span><br><span class="line">        <span class="comment">//   /$&#123;group&#125;/$&#123;serviceInterface&#125;/providers/$&#123;url&#125;</span></span><br><span class="line">        zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, <span class="keyword">true</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(<span class="string">"Failed to register..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2) 调用<code>create()</code>方法。通过递归创建当前节点的上一级路径，然后再根据ephemeral的值决定是创建临时还是持久节点。分别调用<code>createEphemeral</code>和<code>createPersistent</code>方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上一篇文章&lt;strong&gt;Dubbo之服务暴露分析&lt;/strong&gt;中介绍了当远程暴露时，如果有注册中心，需要在服务暴露后再将服务注册到注册中心。该篇将介绍该功能的有关步骤。&lt;/p&gt;
&lt;h1 id=&quot;注册的起点&quot;&gt;&lt;a href=&quot;#注册的起点&quot; class=&quot;heade
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dubbo服务暴露分析</title>
    <link href="https://github.com/spurstong/2020/02/03/Dubbo%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2/"/>
    <id>https://github.com/spurstong/2020/02/03/Dubbo服务暴露/</id>
    <published>2020-02-03T08:49:14.384Z</published>
    <updated>2020-02-04T02:19:54.135Z</updated>
    
    <content type="html"><![CDATA[<p>Dubbo的服务暴露是一个重要的特性，了解其机制很重要。之前有很多人写了有关的源代码分析，在本文中不再重新分析。官方文档中的一篇写的就很好，本文主要是有关内容进行补充与总结。<br>传送门：<a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/export-service.html" target="_blank" rel="noopener">服务导出</a></p><h1 id="为什么要服务暴露"><a href="#为什么要服务暴露" class="headerlink" title="为什么要服务暴露"></a>为什么要服务暴露</h1><p>服务暴露分为远程暴露和本地暴露。在远程服务暴露中会将服务信息上传到注册中心。这时客户端要调用某个服务时会从注册中心找到该服务的远程地址等信息。然后客户端根据这个地址进行远程调用。服务端接收到远程调用请求后会最终调用<code>getInvoker()</code>方法进行查找对用的<code>invoker</code>。在<code>getInvoker()</code>方法中会从一个HashMap中进行查找，如果在这个Map中查找不到就会抛出异常。在远程服务暴露中，会按照规则将实例Invoker存储在HashMap中，其中Key名包含端口、接口名、接口版本和接口分组。所以进行服务暴露很重要。<br>本地服务暴露是暴露在JVM中，不需要远程通信。Dubbo会默认把远程服务用injvm协议再暴露一份。<br><strong>为什么会有本地服务暴露</strong><br>在Dubbo中，一个服务可以即是provider,又是Consumer,因此就存在它自己调用自己服务的时候，如果再通过网络去访问，那么就是舍近求远，因此有了本地暴露服务这个设计。消费者可以直接消费同一个JVM内部的服务，避免了跨网络进行远程通信。</p><h1 id="服务暴露起点"><a href="#服务暴露起点" class="headerlink" title="服务暴露起点"></a>服务暴露起点</h1><p>我们会通过XML或注解的方式来指定要暴露的服务。l例子如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=“xxxService” <span class="class"><span class="keyword">class</span></span>=“com.xxx.XxxServiceImpl” /&gt; </span><br><span class="line">&lt;!-- 增加暴露远程服务配置 --&gt;</span><br><span class="line">&lt;dubbo:service <span class="class"><span class="keyword">interface</span></span>=“com.xxx.XxxService” ref=“xxxService” /&gt;</span><br></pre></td></tr></table></figure><p>这时会创建出一个<code>ServiceBean</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfigBase</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfigBase</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractServiceConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3033787999037024738L</span>;</span><br><span class="line">    <span class="keyword">protected</span> String interfaceName;</span><br><span class="line">    <span class="comment">//要暴露服务类的接口类</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; interfaceClass;</span><br><span class="line">    <span class="comment">//实现类引用</span></span><br><span class="line">    <span class="keyword">protected</span> T ref;</span><br><span class="line">    <span class="comment">//服务名 </span></span><br><span class="line">    <span class="keyword">protected</span> String path;</span><br><span class="line">    <span class="keyword">protected</span> ProviderConfig provider;</span><br><span class="line">    <span class="keyword">protected</span> String providerIds;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> String generic;</span><br><span class="line">    <span class="keyword">protected</span> ServiceMetadata serviceMetadata;</span><br></pre></td></tr></table></figure><p>ServiceBean和Spring有关，它继承了InitializingBean和ApplicationEvent。在Bean初始化完成后会调用InitializingBean.afterPropertiesSet方法来执行服务暴露的准备工作。在Spring的context完成初始化后，会触发ApplicationEventListener事件进行服务暴露,会执行<code>onApplicationEvent</code>方法。这时服务服务暴露就开始了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否有延迟导出 &amp;&amp; 是否已导出 &amp;&amp; 是不是已被取消导出</span></span><br><span class="line">    <span class="keyword">if</span> (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class="line">        <span class="comment">// 导出服务</span></span><br><span class="line">        export();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p>Dubbo真正的服务暴露入口是<code>ServiceConfig#doExport()</code>方法。首先ServiceConfig类拿到对外提供服务的实际类ref,然后通过<code>ProxyFactory</code>类的<code>getInvoker</code>方法使用ref生成一个<code>AbstractProxyInvoker</code>实例，到这一步就完成具体服务到<code>Invoker</code>的转化。然后就是把<code>Invoker</code>通过具体的协议（比如Bubbo）转化成<code>Exporter</code>。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/Dubbo%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E5%88%86%E6%9E%90/1.png" alt="整体流程"><br>参考了简书肥朝的一篇文章:  <a href="[https://www.jianshu.com/p/60a9263f2ee2](https://www.jianshu.com/p/60a9263f2ee2)">dubbo源码解析-服务暴露原理</a></p><ul><li>调用ServiceConfig中的<code>export</code>方法，对配置进行检查与更新，例如provider是否为空，注册中心是否为空，protocols是否为空。然后检测是否应该暴露，如果不应该暴露，则直接结束；然后检测是否配置了延迟加载，如果是，则使用定时器来实现延迟加载的目的。</li><li>调用<code>expoer</code>方法里面的<code>doExport()</code>方法。通过<code>exported</code>变量判断是否暴露，如果为true，直接返回；否则先设置为true,然后执行<code>doExportUrls()</code>方法。</li><li>调用<code>doExportUrls()</code>方法，先通过<code>loadRegistries</code>加载注册中心链接，然后遍历ProtocolConfig集合，它是用户指定的协议集合（比如Dubbo、REST），在里面执行<code>doExportUrlsFor1Protocol(protocolConfig, registryURLs)</code>方法。</li><li>执行<code>doExportUrlsFor1Protocol(protocolConfig, registryURLs)</code>方法，刚开始是组装URL。（1）它把metrices、application、module、provider、protocol等所有配置都放入到map中，(2) 通过反射获取interfaceClass的方法列表，先做签名校验，判断该服务是否有配置的方法存在，然后该方法签名是否有这个参数存在，都核对成功才将method的配置加入到map中；(3)将范化调用、版本号、method或者methods、token等信息加入到map；（4）获取服务暴露地址和端口号，利用map内数据组装成URL。</li><li>然后根据url中的scope参数决定服务导出方式。<code>scope=none</code>，不导出服务；<code>scope!=remote</code>，导出到本地；<code>scope!=local</code>，导出到远程。</li><li>执行<code>proxyFactory.getInvoker(ref, (Class)interfaceClass, url)</code>方法，来获取invoker，Dubbo默认的ProxyFactory实现类是<code>JavasistProxyFacoty</code>方法。</li></ul><p>这时，第一大步<strong>服务转化成Invoker</strong>已经完成，然后执行第二大步<code>Invoker转化成Exporter</code>。<br><strong>先介绍本地服务的暴露机制</strong></p><ul><li>调用<code>exportLocal(url)</code>。首先判断URL的协议头如果等于injvm,说明已经导出到本地了，无需再次导出。如果不是，则创建一个新的URL并将协议头设置为injvm,并另外设置主机名和端口。然后创建invoker,并调用<code>InjvmProtocal</code>的<code>export()</code>方法暴露服务。</li><li><code>InjvmProtocol</code>的<code>export</code>方法仅创建一个<code>InjvmExporter</code>，无其他逻辑。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);</span><br><span class="line">&#125;</span><br><span class="line">InjvmExporter(Invoker&lt;T&gt; invoker, String key, Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap) &#123;</span><br><span class="line"><span class="keyword">super</span>(invoker);</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.exporterMap = exporterMap;</span><br><span class="line">exporterMap.put(key, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>然后介绍远程服务暴露</strong><br>如果有注册中心，服务暴露后需要向注册中心注册服务信息<br>如果没有注册中心，直接暴露服务。</p><h1 id="有注册中心的暴露"><a href="#有注册中心的暴露" class="headerlink" title="有注册中心的暴露"></a>有注册中心的暴露</h1><ol><li>调用<code>doLocalExport()</code>方法暴露服务。</li><li>向注册中心注册服务</li><li>向注册中心进行订阅ovrride数据</li><li>创建并返回<code>DestroyableExporter</code>。</li></ol><p><strong>调用<code>doLocalExport()</code>方法暴露服务</strong></p><ul><li><p>首先根据<code>invoker</code>得到key,从<code>bounds</code>缓存变量中尝试获取<code>exporter</code>,如果获取不到，则调用Protocal的<code>export</code>方法,默认的协议是dubbo,所以调用的DubboProtocol的export方法。</p></li><li><p>调用DubboProtocol的export方法，首先从invoker中获取对用的URL,然后根据服务组名、服务名、服务版本号和端口组成key,然后创建一个DubboExporter。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demoGroup/com.alibaba.dubbo.demo.DemoService:1.0.1:20880</span></span><br><span class="line">String key = serviceKey(url);</span><br><span class="line"><span class="comment">// 创建 DubboExporter</span></span><br><span class="line">DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line"><span class="comment">// 将 &lt;key, exporter&gt; 键值对放入缓存中</span></span><br><span class="line">exporterMap.put(key, exporter);</span><br></pre></td></tr></table></figure></li><li><p>调用<code>openServer(url)</code>方法。首先根据url获取<code>host:port</code>,用于标识当前的服务器实例。在同一台机器上，同一个端口仅允许启动一个服务器实例。若某个端口上已有服务器实例，此时调用<code>reset</code>方法重置一些服务器的配置；如果没有则调用<code>createServer(url)</code>方法创建一个服务器实例。</p></li><li><p>调用<code>createServer(url)</code>方法，有三个核心的逻辑，首先检测是否存在server参数所代表的Transporter拓展，即网络传输方式（如Netty, Mina），如果没有，则抛出异常；然后通过<code>Exchangers.bind(url, requestHandler)</code>方法创建服务器实例；最后是检测是否支持client参数所表示的Transporter拓展，不存在也是抛出异常。</p></li><li><p>调用<code>Exchangers.bind(url, requestHandler)</code>方法,里面又调用了下面几个方法。只保留了主要逻辑部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getExchanger(url).bind(url, handler);</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Exchanger <span class="title">getExchanger</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);</span><br><span class="line">        <span class="keyword">return</span> getExchanger(type);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Exchanger <span class="title">getExchanger</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Exchanger.class).getExtension(type);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Exchange层是为了封装请求/响应模式，例如：把同步请求转化为异步请求。默认的扩展点实现类是<code>HeaderExchanger</code>。</p><ul><li><p>调用HeaderExchanger的bind方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler... handlers)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handlers == <span class="keyword">null</span> || handlers.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handlers == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ChannelHandler handler;</span><br><span class="line">    <span class="keyword">if</span> (handlers.length == <span class="number">1</span>) &#123;</span><br><span class="line">        handler = handlers[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 handlers 元素数量大于1，则创建 ChannelHandler 分发器</span></span><br><span class="line">        handler = <span class="keyword">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取自适应 Transporter 实例，并调用实例方法</span></span><br><span class="line">    <span class="keyword">return</span> getTransporter().bind(url, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据自适应扩展机制动态创建一个Transporter,Dubbo默认是NettyTransporter。</p></li><li><p>调用<code>NettyTransporter.bind(URL, ChannelHandler)</code>方法。创建一个<code>NettyServer</code>实例。</p></li><li><p>调用<code>NettyServer.doOPen()</code>方法，服务器被开启，服务也被暴露出来了。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Dubbo的服务暴露是一个重要的特性，了解其机制很重要。之前有很多人写了有关的源代码分析，在本文中不再重新分析。官方文档中的一篇写的就很好，本文主要是有关内容进行补充与总结。&lt;br&gt;传送门：&lt;a href=&quot;http://dubbo.apache.org/zh-cn/doc
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>轻量级RPC设计与实现第四版</title>
    <link href="https://github.com/spurstong/2020/02/02/%E8%BD%BB%E9%87%8F%E7%BA%A7RPC%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%9B%9B%E7%89%88/"/>
    <id>https://github.com/spurstong/2020/02/02/轻量级RPC设计与实现第四版/</id>
    <published>2020-02-02T06:37:34.181Z</published>
    <updated>2020-02-02T08:36:48.113Z</updated>
    
    <content type="html"><![CDATA[<p>在本版本中引入了SPI机制，关于Java的SPI机制与Dubbo的SPI机制在以前的文章中介绍过。<br>传送门：<a href="https://www.jianshu.com/p/cb9407a6e7e3" target="_blank" rel="noopener">Dubbo的SPI机制与JDK机制的不同及原理分析</a><br>因为设计的RPC框架是基于Spring的，时常会遇到依赖注入问题。Spring中也有SPI机制，但是它有有个缺点，就是在利用SPI机制实例化具体的服务类时，如果具体的服务类中调用其他的bean,就会实例化失败。主要因为该具体的服务类并没有放入到Spring容器中。本项目将有效解决这个问题。<br>在设计的RPC框架中加入了该机制，来实现不同序列化方式的切换。</p><h1 id="Spring的SPI机制"><a href="#Spring的SPI机制" class="headerlink" title="Spring的SPI机制"></a>Spring的SPI机制</h1><p>我们知道在SprngBoot中好多的配置和实现都有默认的实现，我们只需要修改部分配置，比如数据库配置，我们只要在配置文件中写上对应的url，username，password就可以使用了。其实他这边用的就是SPI的方式实现的。Spring的SPI机制原理与Java的SPI原理是一致的。<br>SpringBoot会利用<code>SpringFactoriesLoader</code>加载META-INF/spring.factories文件，从CLASSPATH下的每个Jar包中搜寻所有META-INF/spring.factories配置文件，然后将解析properties文件，找到指定名称的配置后返回。需要注意的是，其实这里不仅仅是会去ClassPath路径下查找，会扫描所有路径下的Jar包，只不过这个文件只会在Classpath下的jar包中。</p><p><strong>调用方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;AService&gt; services = SpringFactoriesLoader.loadFactories(AService.class, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">for</span> (AService service : services) &#123;</span><br><span class="line">            service.info();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>相关源码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">loadFactories</span><span class="params">(Class&lt;T&gt; factoryClass, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">Assert.notNull(factoryClass, <span class="string">"'factoryClass' must not be null"</span>);</span><br><span class="line">ClassLoader classLoaderToUse = classLoader;</span><br><span class="line"><span class="keyword">if</span> (classLoaderToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; factoryNames = loadFactoryNames(factoryClass, classLoaderToUse);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Loaded ["</span> + factoryClass.getName() + <span class="string">"] names: "</span> + factoryNames);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(factoryNames.size());</span><br><span class="line"><span class="keyword">for</span> (String factoryName : factoryNames) &#123;</span><br><span class="line">result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse));</span><br><span class="line">&#125;</span><br><span class="line">AnnotationAwareOrderComparator.sort(result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">"META-INF/spring.factories"</span>;</span><br><span class="line"><span class="comment">// spring.factories文件的格式为：key=value1,value2,value3</span></span><br><span class="line"><span class="comment">// 从所有的jar包中找到META-INF/spring.factories文件</span></span><br><span class="line"><span class="comment">// 然后从文件中解析出key=factoryClass类名称的所有value值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line">    <span class="comment">// 取得资源文件的URL</span></span><br><span class="line">    Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 遍历所有的URL</span></span><br><span class="line">    <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">        URL url = urls.nextElement();</span><br><span class="line">        <span class="comment">// 根据资源文件URL解析properties文件，得到对应的一组@Configuration类</span></span><br><span class="line">        Properties properties = PropertiesLoaderUtils.loadProperties(<span class="keyword">new</span> UrlResource(url));</span><br><span class="line">        String factoryClassNames = properties.getProperty(factoryClassName);</span><br><span class="line">        <span class="comment">// 组装数据，并返回</span></span><br><span class="line">        result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="改进的SPI机制"><a href="#改进的SPI机制" class="headerlink" title="改进的SPI机制"></a>改进的SPI机制</h1><p>该机制有两个缓存变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Map&lt;String, Class&lt;?&gt;&gt;&gt; cacheClasses= <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Map&lt;String, Object&gt;&gt; cacheIntances = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>两个Map的key都是扩展服务的接口类的Class对象<br><code>cacheClasses</code>的value也是一个Map,这个map的key是定义的扩展名，即<code>META-INF/roadspi/</code>目录下文件中的key,value是具体的扩展类的Class对象。<br><code>cacheIntances</code>变量的value也是一个Map,该map的key是定义的扩展名，value是扩展类的具体实例化对象。<br>该机制的主要逻辑是先获取要实现扩展的接口类Class对象，然后从<code>cacheIntances</code>变量中根据key查找是否有缓存的实例，如果有直接返回。如果没有，然后根据接口类Class对象和key在<code>cacheClasses</code>变量中进行查找具体扩展类的Class对象，如果存在，就直接获取对用的Class对象，然后利用<code>BeanDefinitionBuilder</code>生成bean,并注册到Spring容器中；如果找不到对应的Class对象，则到<code>META-INF/roadspi/扩展接口类全称</code>文件下进行资源加载。<br>支持自定义的<code>RoadSpi</code>注解，来定义默认的具体服务类实现。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/%E8%BD%BB%E9%87%8F%E7%BA%A7RPC%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E5%9B%9B%E7%89%88/1.png" alt="整体流程"><br><strong>最主要部分实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createService</span><span class="params">(Map&lt;String, Object&gt; extensionInstanceMap, Map&lt;String, Class&lt;?&gt;&gt; serviceClass, String serviceName, Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">       Class&lt;?&gt; obj = serviceClass.get(serviceName);</span><br><span class="line">       <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">           log.error(<span class="string">"serviceClass is null!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       String beanName = obj.getSimpleName().concat(serviceName);</span><br><span class="line">       BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(obj);</span><br><span class="line">       GenericBeanDefinition definition = (GenericBeanDefinition)builder.getRawBeanDefinition();</span><br><span class="line">       definition.setAutowireMode(GenericBeanDefinition.AUTOWIRE_BY_NAME);</span><br><span class="line">       ConfigurableApplicationContext configurableApplicationContext = (ConfigurableApplicationContext)context;</span><br><span class="line">       DefaultListableBeanFactory register = (DefaultListableBeanFactory)configurableApplicationContext.getBeanFactory();</span><br><span class="line">       register.registerBeanDefinition(beanName, definition);</span><br><span class="line">       extensionInstanceMap.put(serviceName, context.getBean(beanName));</span><br><span class="line">       cacheIntances.put(type, extensionInstanceMap);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>具体详细代码地址：<a href="https://github.com/spurstong/RoadSPI">RoadSPI</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在本版本中引入了SPI机制，关于Java的SPI机制与Dubbo的SPI机制在以前的文章中介绍过。&lt;br&gt;传送门：&lt;a href=&quot;https://www.jianshu.com/p/cb9407a6e7e3&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>轻量级RPC设计与实现第三版</title>
    <link href="https://github.com/spurstong/2020/01/30/%E8%BD%BB%E9%87%8F%E7%BA%A7RPC%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%89%E7%89%88/"/>
    <id>https://github.com/spurstong/2020/01/30/轻量级RPC设计与实现第三版/</id>
    <published>2020-01-30T08:25:06.415Z</published>
    <updated>2020-01-30T12:21:12.176Z</updated>
    
    <content type="html"><![CDATA[<p>在前两个版本中，每次发起请求一次就新建一个netty的channel连接，如果在高并发情况下就会造成资源的浪费，这时实现<strong>异步请求</strong>就十分重要，当有多个请求线程时，需要设计一个<strong>线程池</strong>来进行管理。除此之外，当前方法过于依赖注册中心，在高并发情况下对注册中心造成了压力；另外如果注册中心出现宕机等情况，那么整合系统就崩溃了，为了解决这个问题，添加了一个<strong>适合高并发的服务缓存机制</strong>。以上为该版本的新增内容。</p><h1 id="异步请求和线程池"><a href="#异步请求和线程池" class="headerlink" title="异步请求和线程池"></a>异步请求和线程池</h1><p>这里就不具体介绍异步请求的概念了。用一个通俗的例子解释，如你在饭店点餐，当你点好餐后，会得到一个点餐号，但是饭菜并不会立即做好送过，需要你等待一段时间，在这个时间段中，你可以做其他的事情，当饭菜做好后，会根据点餐号进行广播，通知你去拿饭菜。这就是一个典型的异步处理。<br>在项目中涉及到异步的主要有三个自定义类，即<code>ChannelHolder</code>,<code>LwRequestPool</code>和<code>LwRequestManager</code>。<br>在<code>ChannelHolder</code>中定义的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>LwRequestManager</code>中的变量:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, ChannelHolder&gt; channelHolderMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService requestExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">30</span>, <span class="number">100</span>, <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>),</span><br><span class="line">            <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(<span class="string">"request-service-connector-%d"</span>).build());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LwRequestPool requestPool = SpringBeanFactory.getBean(LwRequestPool.class);</span><br></pre></td></tr></table></figure><p>在<code>LwRequestPool</code>中定义的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Promise&lt;LwResponse&gt;&gt; requestPool = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><p>刚开始在动态代理中会调用<code>send()</code>方法，开始了有关异步调用的内容。通过requestId来确定是哪个请求，利用线程池执行netty客户端的运行，并利用<code>CountDownLatch</code>来先暂停下面代码的运行，如果latch执行了countDown()方法，会再返回这里执行下面的步骤。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(LwRequest request, URL url)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">      String requestId = request.getRequestId();</span><br><span class="line">      CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">      requestExecutor.execute(<span class="keyword">new</span> NettyClient(requestId, url, latch));</span><br><span class="line">      latch.await();</span><br><span class="line">      ChannelHolder channelHolder = channelHolderMap.get(requestId);</span><br><span class="line">      channelHolder.getChannel().writeAndFlush(request);</span><br><span class="line">      log.info(<span class="string">"客户端发送消息：&#123;&#125;"</span>, channelHolder);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>之后运行Netty客户端中的run()方法，如果与服务端连接成功，将该请求id和对应的channel注册到<code>channelHolderMap</code>变量中，并执行<code>submitRequest</code>方法，将请求id和eventLoop注册到变量<code>requestPool</code>中。最后执行了<code>countDown()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">5000</span>)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">65535</span>, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> LwRpcEncoder(LwRequest.class, <span class="keyword">new</span> HessianSerializer()));</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> LwRpcDecoder(LwResponse.class, <span class="keyword">new</span> HessianSerializer()));</span><br><span class="line">                        pipeline.addLast(clientHandler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = bootstrap.connect(url.getHostname(), url.getPort()).sync();</span><br><span class="line">            <span class="comment">//连接成功</span></span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                ChannelHolder channelHolder = ChannelHolder.builder()</span><br><span class="line">                        .channel(future.channel())</span><br><span class="line">                        .eventLoopGroup(group).build();</span><br><span class="line">                LwRequestManager.registerChannelHolder(requestId, channelHolder);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">requestPool.submitRequest(requestId, channelHolder.getChannel().eventLoop());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitRequest</span><span class="params">(String requestId, EventExecutor executor)</span> </span>&#123;</span><br><span class="line">        requestPool.put(requestId, <span class="keyword">new</span> DefaultPromise&lt;&gt;(executor));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当执行了<code>countDown()</code>方法，会跳转到原来最初的地方，执行剩下的代码部分，进行请求发送。等待服务端的响应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelHolder channelHolder = channelHolderMap.get(requestId);</span><br><span class="line">        channelHolder.getChannel().writeAndFlush(request);</span><br></pre></td></tr></table></figure><p>当客户端接收到服务端发回的结果信息时，会执行<code>notifyRequest</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, LwResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        lwRequestPool.notifyRequest(response.getRequestId(), response);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在<code>notifyRequest</code>方法中，会从变量<code>requestPool</code>中获取到返回的<code>LwResponse</code>变量，并封装在<code>Promise</code>中,最后调用setsuccess()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyRequest</span><span class="params">(String requestId, LwResponse response)</span> </span>&#123;</span><br><span class="line">        Promise&lt;LwResponse&gt; promise = requestPool.get(requestId);</span><br><span class="line">        <span class="keyword">if</span> (promise != <span class="keyword">null</span>) &#123;</span><br><span class="line">            promise.setSuccess(response);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><code>setsuccess()</code>方法是netty的Promise中的方法。它会通知所有的监听器。在官方解释如下：<br><code>Marks this future as a success and notifies all</code><br>此时就可以通过<code>fetchResponse</code>根据请求id获取到了服务端发送过来的消息，此时已经执行完毕，需要从<code>requestpool</code>中删除该请求信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LwResponse response = lwRequestPool.fetchResponse(requestId);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> LwResponse <span class="title">fetchResponse</span><span class="params">(String requestId)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       Promise&lt;LwResponse&gt; promise = requestPool.get(requestId);</span><br><span class="line">       <span class="keyword">if</span> (promise == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       LwResponse response = promise.get(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">       requestPool.remove(requestId);</span><br><span class="line"></span><br><span class="line">       LwRequestManager.destroyChannelHolder(requestId);</span><br><span class="line">       <span class="keyword">return</span> response;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="高并发下的缓存机制"><a href="#高并发下的缓存机制" class="headerlink" title="高并发下的缓存机制"></a>高并发下的缓存机制</h1><p>在原来的版本中，每次请求远程服务时，都需要从注册中心获取服务地址，在高并发情况下，会对注册中心造成一定的影响；或者如果注册中心突然宕机，那么就无法获取待服务地址，整个系统就崩溃了。所以设计一个缓存机制，将请求到的服务地址持久化到本地，当下次请求时，就无须再需要注册中心了，直接从持久化文件中获取，减轻了注册中心的压力。</p><p>在进行本地缓存时，会先调用<code>saveServices</code>方法，将URL数组信息保存到<code>Properties</code>中，并获取当前<code>version</code>版本号，然后执行<code>doSaveProperties</code>方法来保存到本地。这个步骤支持同步和异步两种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveServices</span><span class="params">(String serviceName, List&lt;URL&gt; urlList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (file == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(URL url : urlList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (buf.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buf.append(<span class="string">";"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                buf.append(url.getAllInformation());</span><br><span class="line">            &#125;</span><br><span class="line">            properties.setProperty(serviceName, buf.toString());</span><br><span class="line">            <span class="keyword">long</span> version = lastCacheChanged.incrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (syncSaveFile) &#123;</span><br><span class="line">                doSaveProperties(version);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                registerCacheExecutor.execute(<span class="keyword">new</span> SaveProperties(version));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable  t) &#123;</span><br><span class="line">            log.warn(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在<code>doSaveProperties</code>方法中，如果传入的版本号不是最新的版本号，说明其他线程已经修改了，内容发生了变化，直接退出。在写入到文件时会添加锁，进一步保证信息的准确性。如果添加失败，会进行重试操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSaveProperties</span><span class="params">(<span class="keyword">long</span> version)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (version &lt; lastCacheChanged.get())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (file == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File lockfile = <span class="keyword">new</span> File(file.getAbsolutePath() + <span class="string">".lock"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!lockfile.exists()) &#123;</span><br><span class="line">                lockfile.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>(RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(lockfile, <span class="string">"rw"</span>);</span><br><span class="line">            FileChannel channel = raf.getChannel();) &#123;</span><br><span class="line">                FileLock lock = channel.tryLock();</span><br><span class="line">                <span class="keyword">if</span> (lock == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"不能锁住注册的缓存文件"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                        file.createNewFile();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> (FileOutputStream outputFile = <span class="keyword">new</span> FileOutputStream(file)) &#123;</span><br><span class="line">                        properties.store(outputFile, <span class="string">"RPC Server Cache"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            savePropertiesRetryTimes.incrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (savePropertiesRetryTimes.get() &gt; SAVE_MAX_RETRY) &#123;</span><br><span class="line">                log.warn(<span class="string">"超过最大重试次数，缓存失败！"</span>);</span><br><span class="line">                savePropertiesRetryTimes.set(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (version &lt; lastCacheChanged.get()) &#123;</span><br><span class="line">                savePropertiesRetryTimes.set(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>具体详细代码可以到我的项目中进行查看<a href="https://github.com/spurstong/lightWeightRpc/tree/lightweightrpcv3">轻量级RPC第三版</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在前两个版本中，每次发起请求一次就新建一个netty的channel连接，如果在高并发情况下就会造成资源的浪费，这时实现&lt;strong&gt;异步请求&lt;/strong&gt;就十分重要，当有多个请求线程时，需要设计一个&lt;strong&gt;线程池&lt;/strong&gt;来进行管理。除此之外，当前方
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>轻量级RPC设计与实现第二版</title>
    <link href="https://github.com/spurstong/2020/01/27/%E8%BD%BB%E9%87%8F%E7%BA%A7RPC%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%BA%8C%E7%89%88/"/>
    <id>https://github.com/spurstong/2020/01/27/轻量级RPC设计与实现第二版/</id>
    <published>2020-01-27T07:52:30.625Z</published>
    <updated>2020-01-29T14:40:20.062Z</updated>
    
    <content type="html"><![CDATA[<p>在上一个版本中利用netty实现了简单的一对一的RPC，需要手动设置服务地址，限制性较大。<br>在本文中，利用zookeeper作为服务注册中心，在服务端启动时将本地的服务信息注册到zookeeper中，当客户端发起远程服务调用时，先从zookeeper中获取该服务的地址，然后根据获得的这个地址来利用netty进行网络传送。<br>在服务端和注册中心之间需要建立监听，当服务信息发生变化或网络连接等问题时需要对注册中心的服务信息进行修改。在本文中创建了服务注册监控中心，利用<strong>心跳机制</strong>来判断与服务端是否有较稳定的连接，当出现网络不稳定时，则从注册中心中删除属于该服务端的服务信息。在本项目中设定在5分钟内3次以上没有发送心跳包为不稳定状态。</p><h1 id="zookeeper注册中心"><a href="#zookeeper注册中心" class="headerlink" title="zookeeper注册中心"></a>zookeeper注册中心</h1><p>zookeeper是hadoop中的一个重要组件，其主要是作为<strong>分布式协调服务</strong><br>zookeeper采用节点树的数据模型，类似linux文件系统。<br>每个节点称做一个ZNode,每个ZNode都可以通过路径唯一标识，同时每个节点还可以存储少量数据。<br>本项目借鉴dubbo的注册中心模型来设计本文的注册中心。<br>总体上设计了四级节点，在一个节点是一个持久节点<code>/register</code>，表示是记录注册服务的区域。二级节点是服务接口名，三级节点是远程服务ip地址，该节点是临时节点，节点存储的数据是具体的实现类名。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/%E8%BD%BB%E9%87%8F%E7%BA%A7RPC%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%BA%8C%E7%89%88/1.png" alt="整体流程"><br>在客户端会根据服务接口名在注册中心进行查找，得到远程服务ip地址，并根据节点中存储的具体实现类名进行反射。</p><p>首先进行zookeeper初始化,利用了<code>CuratorFramework</code>有关类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> RetryNTimes(ZKConsts.RETRYTIME, ZKConsts.SLEEP_MS_BEWTEENR_RETRY);</span><br><span class="line">        client = CuratorFrameworkFactory.builder().connectString(ZKConsts.ZK_SERVER_PATH)</span><br><span class="line">                .sessionTimeoutMs(ZKConsts.SESSION_TIMEOUT_MS).retryPolicy(retryPolicy)</span><br><span class="line">                .namespace(ZKConsts.WORK_SPACE).build();</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>服务的注册代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String interfaceName = url.getInterfaceName();</span><br><span class="line">            String implClassName = url.getImplClassName();</span><br><span class="line">            Stat stat = client.checkExists().forPath(getPath(interfaceName, url.toString()));</span><br><span class="line">            <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"该节点已存在！"</span>);</span><br><span class="line">                client.delete().forPath(getPath(interfaceName, url.toString()));</span><br><span class="line">            &#125;</span><br><span class="line">            client.create()</span><br><span class="line">                    .creatingParentsIfNeeded()</span><br><span class="line">                    .withMode(CreateMode.EPHEMERAL)</span><br><span class="line">                    <span class="comment">//权限控制，任何连接的客户端都可以操作该属性znode</span></span><br><span class="line">                    .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</span><br><span class="line">                    .forPath(getPath(interfaceName, url.toString()), implClassName.getBytes());</span><br><span class="line">            System.out.println(getPath(interfaceName, url.toString()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据服务接口名来获取远程服务连接地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> URL <span class="title">random</span><span class="params">(String interfaceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"开始查找服务节点："</span> + getPath(interfaceName));</span><br><span class="line">            List&lt;String&gt; urlList = client.getChildren().forPath(<span class="string">"/"</span> + interfaceName);</span><br><span class="line">            System.out.println(<span class="string">"结果："</span> + urlList);</span><br><span class="line">            String serviceUrl = urlList.get(<span class="number">0</span>);</span><br><span class="line">            String[] urls = serviceUrl.split(<span class="string">":"</span>);</span><br><span class="line">            String implClassName = get(interfaceName, serviceUrl);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> URL(urls[<span class="number">0</span>], Integer.valueOf(urls[<span class="number">1</span>]), interfaceName, implClassName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注册中心与服务端进行连接时需要判断是否维持了稳定的连接，如果服务端出现宕机等情况时需要从注册中心中删除这些服务。<br>以前的一些处理机制，有<strong>session</strong>机制和<strong>wacher</strong>机制。<br><strong>session机制</strong><br>每个zookeeper注册中心与服务端进行连接时会创建一个session,在设置的sessionTimeout内，服务端会与注册中心进行心跳包的定时发送，从而感知每个客户端是否宕机，如果创建某个临时Znode节点对应的session销毁时，相应的临时节点也会被注册中心删除。<br><strong>watcher机制</strong><br>针对每个节点的操作，都有要给监督者进行watcher,当监控的某个节点发生了变化，则会触发watcher事件。注册中心的watcher是一次性的，触发后会被销毁。父节点，子节点增删改都能够触发watcher。触发销毁后，下次需要监听时还需要再注册一次。<br><strong>本文心跳机制</strong><br>服务端定时向注册中心发送本机地址，看作心跳数据包，而注册中心监控则维持一个channelId和具体地址的map,并且通过IdleHandler监听空闲事件，到达一定的空闲次数则认为不活跃，当不活跃时，zookeeper删除对应的url节点。该版本实现了上面的内容，后续的步骤在以后的版本实现。<br>如果10s内没有触发读，就会执行<code>userEventTriggered</code>方法。如果5分钟中出现两次不活跃次数，就认定该连接不稳定，注册中心会移除属于该服务端的服务。你也可以根据实际情况设定不稳定标准。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">service.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">               <span class="keyword">if</span> (future.channel().isActive()) &#123;</span><br><span class="line">                   <span class="keyword">int</span> time = <span class="keyword">new</span> Random().nextInt(<span class="number">5</span>);</span><br><span class="line">                   log.info(<span class="string">"本次定时任务获取的随机数:&#123;&#125;"</span>, time);</span><br><span class="line">                   <span class="keyword">if</span> (time &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                       log.info(<span class="string">"发送本地地址到注册中心：&#123;&#125;"</span>, url);</span><br><span class="line">                       future.channel().writeAndFlush(url);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, <span class="number">60</span>, <span class="number">60</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">           IdleStateEvent state = (IdleStateEvent)evt;</span><br><span class="line">           <span class="keyword">if</span> (state.state().equals(IdleState.READER_IDLE)) &#123;</span><br><span class="line">               log.info(<span class="string">"读空闲"</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.state().equals(IdleState.WRITER_IDLE)) &#123;</span><br><span class="line">               log.info(<span class="string">"写空闲"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//在一定时间内读写空闲才会关闭链接</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (state.state().equals(IdleState.ALL_IDLE)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (++inActiveCount == <span class="number">1</span>) &#123;</span><br><span class="line">                   start = System.currentTimeMillis();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">int</span> minute = (<span class="keyword">int</span>)((System.currentTimeMillis() - start) / (<span class="number">60</span> * <span class="number">1000</span>)) + <span class="number">1</span>;</span><br><span class="line">               log.info(<span class="string">"第&#123;&#125;次读写都空闲，计时分钟数&#123;&#125;"</span>, inActiveCount, minute);</span><br><span class="line">               <span class="keyword">if</span> (inActiveCount &gt; <span class="number">2</span> &amp;&amp; minute &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                   log.info(<span class="string">"移除不活跃ip"</span>);</span><br><span class="line">                   removeAndClose(ctx);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (minute &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">                       log.info(<span class="string">"新周期开始"</span>);</span><br><span class="line">                       start = <span class="number">0</span>;</span><br><span class="line">                       inActiveCount = <span class="number">0</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>具体实现代码：<a href="https://github.com/spurstong/lightWeightRpc/tree/lightweightrpcv2">RPC第二版</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上一个版本中利用netty实现了简单的一对一的RPC，需要手动设置服务地址，限制性较大。&lt;br&gt;在本文中，利用zookeeper作为服务注册中心，在服务端启动时将本地的服务信息注册到zookeeper中，当客户端发起远程服务调用时，先从zookeeper中获取该服务的地址
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>轻量级RPC设计与实现第一版</title>
    <link href="https://github.com/spurstong/2020/01/24/%E8%BD%BB%E9%87%8F%E7%BA%A7RPC%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%80%E7%89%88/"/>
    <id>https://github.com/spurstong/2020/01/24/轻量级RPC设计与实现第一版/</id>
    <published>2020-01-24T13:17:42.717Z</published>
    <updated>2020-01-27T07:37:57.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h1><p>RPC (Remote Procedure Call Protocol), 远程过程调用，通俗的解释就是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样，不需要了解底层网络技术的协议。</p><p><strong>简单的整体工作流程</strong><br>请求端发送一个调用的数据包，该包中包含有调用标识，参数等协议要求的参数。当响应端接收到这个数据包，对应的程序被调起，然后返回结果数据包，返回的数据包含了和请求的数据包中同样的请求标识，结果等。</p><h1 id="性能影响因素"><a href="#性能影响因素" class="headerlink" title="性能影响因素"></a>性能影响因素</h1><ol><li><strong>利用的网络协议</strong>。可以使用应用层协议，例如HTTP或者HTTP/2协议；也可以利用传输层协议，例如TCP协议，但是主流的RPC还没有采用UDP传输协议。</li><li><strong>消息封装格式</strong>。选择或设计一种协议来封装信息进行组装发送。比如，dubbo中消息体数据包含dubbo版本号、接口名称、接口版本、方法名称、参数类型列表、参数、附加信息等。</li><li><strong>序列化</strong>。信息在网络传输中要以二进制格式进行传输。序列化和反序列化，是对象到而二进制数据的转换。常见的序列化方法有JSON、Hessian、Protostuff等。</li><li><strong>网络IO模型</strong>。可以采用非阻塞式同步IO,也可以在服务器上实现对多路IO模型的支持。</li><li><strong>线程管理方式</strong>。在高并发请求下，可以使用单个线程运行服务的具体实现，但是会出现请求阻塞等待现象。也可以为每一个RPC具体服务的实现开启一个独立的线程运行，最大线程数有限制，可以使用线程池来管理多个线程的分配和调度。</li></ol><h1 id="第一版RPC"><a href="#第一版RPC" class="headerlink" title="第一版RPC"></a>第一版RPC</h1><p>第一个版本简单实现了RPC的最基本功能，即<strong>服务信息的发送与接收</strong>、<strong>序列化方式</strong>和<strong>动态代理</strong>等。<br>项目利用Springboot来实现依赖注入与参数配置，使用netty实现NIO方式的数据传输，使用Hessian来实现对象序列化。<br><strong>动态代理</strong><br>这里要提到代理模式，它的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系。<br>根据创建代理类的时间点，又可以分为静态代理和动态代理。<br>在以往的静态代理中需要手动为每一个目标编写对应的代理类。如果系统已经有了成百上千个类，工作量太大了。<br>静态代理由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口与被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。<br>代理类在程序运行时创建的代理方式被称为代理模式。在静态代理中，代理类是自己定义好的，在运行之前就已经编译完成了。而在动态代理中，可以很方便地对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。可以通过<code>InvocationHandler</code>接口来实现。</p><p><strong>客户端的动态代理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; interfaceClass)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;interfaceClass&#125;, <span class="keyword">new</span> LwRpcClientDynamicProxy&lt;T&gt;(interfaceClass));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LwRpcClientDynamicProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; clazz;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LwRpcClientDynamicProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LwRequest lwRequest = <span class="keyword">new</span> LwRequest();</span><br><span class="line">        String requestId = UUID.randomUUID().toString();</span><br><span class="line">        String className = method.getDeclaringClass().getName();</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">        lwRequest.setRequestId(requestId);</span><br><span class="line">        lwRequest.setClassName(className);</span><br><span class="line">        lwRequest.setMethodName(methodName);</span><br><span class="line">        lwRequest.setParameterTypes(parameterTypes);</span><br><span class="line">        lwRequest.setParameters(args);</span><br><span class="line">        NettyClient nettyClient = <span class="keyword">new</span> NettyClient(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        log.info(<span class="string">"开始连接服务器端:&#123;&#125;"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">        LwResponse send = nettyClient.send(lwRequest);</span><br><span class="line">        log.info(<span class="string">"请求后返回的结果:&#123;&#125;"</span>, send.getResult());</span><br><span class="line">        <span class="keyword">return</span> send.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务端会利用在客户端获取到的类名。参数等信息利用反射机制进行调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt;[] parameterTypes = request.getParameterTypes();</span><br><span class="line">        Object[] paramethers = request.getParameters();</span><br><span class="line">        <span class="comment">// 使用CGLIB 反射</span></span><br><span class="line">        FastClass fastClass = FastClass.create(serviceClass);</span><br><span class="line">        FastMethod fastMethod = fastClass.getMethod(methodName, parameterTypes);</span><br><span class="line">        <span class="keyword">return</span> fastMethod.invoke(serviceBean, paramethers);</span><br></pre></td></tr></table></figure><p><strong>Netty客户端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line">    <span class="keyword">private</span> LwResponse response;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup group;</span><br><span class="line">    <span class="keyword">private</span> ChannelFuture future = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> NettyClientHandler nettyClientHandler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(String host, Integer port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LwResponse <span class="title">send</span><span class="params">(LwRequest request)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        nettyClientHandler = <span class="keyword">new</span> NettyClientHandler(request);</span><br><span class="line">        group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">5000</span>)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">65535</span>, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> LwRpcEncoder(LwRequest.class, <span class="keyword">new</span> HessianSerializer()));</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> LwRpcDecoder(LwResponse.class, <span class="keyword">new</span> HessianSerializer()));</span><br><span class="line">                        pipeline.addLast(nettyClientHandler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(<span class="string">"host:"</span> + host);</span><br><span class="line">        future = bootstrap.connect(host, port).sync();</span><br><span class="line">        nettyClientHandler.getCountDownLatch().await();</span><br><span class="line">        <span class="keyword">this</span>.response = nettyClientHandler.getLwResponse();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        group.shutdownGracefully();</span><br><span class="line">        future.channel().closeFuture().syncUninterruptibly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> LwResponse response = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> LwRequest request;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClientHandler</span><span class="params">(LwRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CountDownLatch <span class="title">getCountDownLatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LwResponse <span class="title">getLwResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"客户端向客户端发送消息"</span>);</span><br><span class="line">        ctx.writeAndFlush(request);</span><br><span class="line">        log.info(<span class="string">"客户端请求成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LwResponse lwResponse = (LwResponse) msg;</span><br><span class="line">        log.info(<span class="string">"收到服务端的信息:&#123;&#125;"</span>, lwResponse.getResult());</span><br><span class="line">        <span class="keyword">this</span>.response = lwResponse;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端发送服务信息时，用LwQuest类进行封装，返回的结果用LwResponse进行封装，当客户端读取到服务器端返回的响应时，在<code>NettyClientHandler</code>中进行处理，并利用<code>CountDownLatch</code>进行线程的阻塞和运行。<br><strong>Netty服务端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup boss = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup worker = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServerHandler serverHandler;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.address&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"成功"</span>);</span><br><span class="line">        boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(boss, worker)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">65535</span>, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> LwRpcEncoder(LwResponse.class, <span class="keyword">new</span> HessianSerializer()));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> LwRpcDecoder(LwRequest.class, <span class="keyword">new</span> HessianSerializer()));</span><br><span class="line">                            pipeline.addLast(serverHandler);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            String[] strs = address.split(<span class="string">":"</span>);</span><br><span class="line">            String addr = strs[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> port = Integer.valueOf(strs[<span class="number">1</span>]);</span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(addr, port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        boss.shutdownGracefully().sync();</span><br><span class="line">        worker.shutdownGracefully().sync();</span><br><span class="line">        log.info(<span class="string">"关闭netty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">LwRequest</span>&gt; <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, LwRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LwResponse lwResponse = <span class="keyword">new</span> LwResponse();</span><br><span class="line">        lwResponse.setRequestId(msg.getRequestId());</span><br><span class="line">        log.info(<span class="string">"从客户端接收到请求信息:&#123;&#125;"</span>, msg);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object result = handler(msg);</span><br><span class="line">            lwResponse.setResult(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            lwResponse.setCause(throwable);</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        channelHandlerContext.writeAndFlush(lwResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">handler</span><span class="params">(LwRequest request)</span> <span class="keyword">throws</span> ClassNotFoundException, InvocationTargetException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(request.getClassName());</span><br><span class="line">        Object serviceBean = applicationContext.getBean(clazz);</span><br><span class="line">        Class&lt;?&gt; serviceClass = serviceBean.getClass();</span><br><span class="line">        String methodName = request.getMethodName();</span><br><span class="line">        log.info(<span class="string">"获取到的服务类:&#123;&#125;"</span>, serviceBean);</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = request.getParameterTypes();</span><br><span class="line">        Object[] paramethers = request.getParameters();</span><br><span class="line">        <span class="comment">// 使用CGLIB 反射</span></span><br><span class="line">        FastClass fastClass = FastClass.create(serviceClass);</span><br><span class="line">        FastMethod fastMethod = fastClass.getMethod(methodName, parameterTypes);</span><br><span class="line">        <span class="keyword">return</span> fastMethod.invoke(serviceBean, paramethers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Netty服务端中，会利用``serverHandler`来处理从客户端中接收的信息，并利用反射的思想调用本地的方法，并将处理的结构封装在LwResponse中。</p><p><code>LwRequest</code>和<code>LwRespnse</code>要想在网络中进行传输，需要转化为二进制转换。具体方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HessianSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object object) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        Hessian2Output output = <span class="keyword">new</span> Hessian2Output(byteArrayOutputStream);</span><br><span class="line">        output.writeObject(object);</span><br><span class="line">        output.flush();</span><br><span class="line">        <span class="keyword">return</span> byteArrayOutputStream.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Hessian2Input input = <span class="keyword">new</span> Hessian2Input(<span class="keyword">new</span> ByteArrayInputStream(bytes));</span><br><span class="line">        <span class="keyword">return</span> (T) input.readObject(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LwRpcDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="keyword">private</span> Serializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LwRpcDecoder</span><span class="params">(Class&lt;?&gt; clazz, Serializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (byteBuf.readableBytes() &lt; <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        byteBuf.markReaderIndex();</span><br><span class="line">        <span class="keyword">int</span> dataLength = byteBuf.readInt();</span><br><span class="line">        <span class="keyword">if</span> (dataLength &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            channelHandlerContext.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (byteBuf.readableBytes() &lt; dataLength) &#123;</span><br><span class="line">            byteBuf.resetReaderIndex();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[dataLength];</span><br><span class="line">        byteBuf.readBytes(data);</span><br><span class="line"></span><br><span class="line">        Object obj = serializer.deserialize(clazz, data);</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LwRpcEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="keyword">private</span> Serializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LwRpcEncoder</span><span class="params">(Class&lt;?&gt; clazz, Serializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object in, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (clazz.isInstance(in)) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = serializer.serialize(in);</span><br><span class="line">            out.writeInt(data.length);</span><br><span class="line">            out.writeBytes(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是RPC&quot;&gt;&lt;a href=&quot;#什么是RPC&quot; class=&quot;headerlink&quot; title=&quot;什么是RPC&quot;&gt;&lt;/a&gt;什么是RPC&lt;/h1&gt;&lt;p&gt;RPC (Remote Procedure Call Protocol), 远程过程调用，通俗的解释就是：客
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>轻量级分布式锁的设计原理分析与实现</title>
    <link href="https://github.com/spurstong/2020/01/17/%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>https://github.com/spurstong/2020/01/17/轻量级分布式锁的设计原理分析及实现/</id>
    <published>2020-01-17T10:02:06.498Z</published>
    <updated>2020-01-23T09:51:36.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要设计分布式锁"><a href="#为什么要设计分布式锁" class="headerlink" title="为什么要设计分布式锁"></a>为什么要设计分布式锁</h1><p>  在简单的单机系统中，当存在多个线程同时要修改某个共享变量时，为了数据的操作安全，往往需要通过加锁的方法，在同一时刻同一代码块只能有一个进程执行操作，存在很多加锁的方式，比如在java中有synchronize或Lock子类等。<br>  但是在分布式中，会存在多个主机，即会存在多个jvm, 在jvm之间数据是不能共享的，上面的方法只能在一个jvm中执行有效，在多个jvm中同一变量可能会有不同的值。所以我们要设计一种跨jvm的共享互斥机制来控制共享变量资源的访问，这也是提出分布式锁的初衷。</p><h1 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h1><p>为了将分布式锁实现较好的性能，我们需要解决下面几个重要的问题：</p><ul><li>一个方法或代码片段在同一时刻只能被一个进程所执行。</li><li>高可用的获取锁与释放锁功能。</li><li>避免死锁</li><li>锁只能被持有该锁的客户端删除或者释放。</li><li>容错，在服务器宕机时，锁依然能得到释放或者其他服务器可以进行加锁。</li></ul><p>下面分别利用redis和zookeeper来实现加锁和解锁机制。</p><h1 id="基于Redis的加锁第一版"><a href="#基于Redis的加锁第一版" class="headerlink" title="基于Redis的加锁第一版"></a>基于Redis的加锁第一版</h1><p>本版本通过变量sign设置锁的唯一标识，确保只有拥有该锁的客户端才能删除它，其他客户端不能删除。<br>利用阻塞锁的思想， 通过<code>while(System.currentTimeMillis() &lt; endTime)</code>和<code>Thread.sleep()</code>相结合，在设置的规定时间内进行多次尝试。<br>但是<code>setnx</code>操作和<code>expire</code>分割开了，不具有<strong>原子性</strong>，可能会出现问题。<br>比如说，在执行到<code>jedis.expire</code>时，可能系统发生了崩溃，导致锁没有设置过期时间，导致发生死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addLockVersion1</span><span class="params">(String key, <span class="keyword">int</span> blockTime, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (blockTime &lt;=<span class="number">0</span> || expireTime &lt;= <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           jedis = jedisPool.getResource();</span><br><span class="line">           String sign = UUID.randomUUID().toString();</span><br><span class="line">           String token = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">//设置阻塞尝试时间</span></span><br><span class="line">           <span class="keyword">long</span> endTime = System.currentTimeMillis() + blockTime;</span><br><span class="line">           <span class="keyword">while</span> (System.currentTimeMillis() &lt; endTime) &#123;</span><br><span class="line">               <span class="keyword">if</span> (jedis.setnx(key, sign) == <span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="comment">// 添加成功，设置锁的过期时间，防止死锁</span></span><br><span class="line">                   jedis.expire(key, expireTime);</span><br><span class="line">                   <span class="comment">// 在释放锁时用于验证</span></span><br><span class="line">                   token = sign;</span><br><span class="line">                   <span class="keyword">return</span> token;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//加锁失败，休眠一段时间，再进行尝试。</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(DEFAULT_SLEEP_TIME);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   Thread.currentThread().interrupt();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">               jedis.close();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="基于Redis的加锁第二版"><a href="#基于Redis的加锁第二版" class="headerlink" title="基于Redis的加锁第二版"></a>基于Redis的加锁第二版</h1><p>通过设置key对应的value值为锁的过期时间，当遇到系统崩溃，致使利用<code>expire</code>设置锁过期时间失败时，通过获取value值，来判断当前锁是否过期，如果该锁已经过期了，则进行重新获取。</p><p>但是它也存在一些问题。当锁过期时，如果多个进程同时执行<code>jedis.getSet</code>方法，虽然只有一个进程可以获得该锁，但是这个进程的锁的过期时间可能被其他进程的锁所覆盖。<br>该锁没有设置唯一标识，也会被其他客户端锁释放，不满足只能被锁的拥有者锁释放的条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addLockVersion2</span><span class="params">(String key, <span class="keyword">int</span> blockTime, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (blockTime &lt;=<span class="number">0</span> || expireTime &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            <span class="keyword">long</span> endTime = System.currentTimeMillis() + blockTime;</span><br><span class="line">            <span class="keyword">while</span> (System.currentTimeMillis() &lt; endTime) &#123;</span><br><span class="line">                <span class="keyword">long</span> redisExpierTime = System.currentTimeMillis() + expireTime;</span><br><span class="line">                <span class="keyword">if</span> (jedis.setnx(key, redisExpierTime + <span class="string">""</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    jedis.expire(key, expireTime);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String oldRedisExpierTime = jedis.get(key);</span><br><span class="line">                    <span class="comment">// 当锁设置成功，但是没有通过expire成功设置过期时间，但是根据存的值判断出它实际上已经过期了</span></span><br><span class="line">                    <span class="keyword">if</span> (oldRedisExpierTime != <span class="keyword">null</span> &amp;&amp; Long.parseLong(oldRedisExpierTime) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">                        String lastRedisExpierTime = jedis.getSet(key, System.currentTimeMillis() + blockTime + <span class="string">""</span>);</span><br><span class="line">                        <span class="comment">//获取到该锁，没有被其他线程所修改</span></span><br><span class="line">                        <span class="keyword">if</span> (lastRedisExpierTime.equals(oldRedisExpierTime)) &#123;</span><br><span class="line">                            jedis.expire(key, expireTime);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//加锁失败，休眠一段时间，再进行尝试。</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(DEFAULT_SLEEP_TIME);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="基于Redis的加锁第三版"><a href="#基于Redis的加锁第三版" class="headerlink" title="基于Redis的加锁第三版"></a>基于Redis的加锁第三版</h1><p>具体通过<code>set</code>方法来实现<code>setnx</code>和<code>expire</code>的相加功能，实现了原子操作。<br>如果key不存在时，就进行加锁操作，并对锁设置一个有效期，同时uniqueId表示加锁的客户端；如果key存在，不做任何操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addLockVersion3</span><span class="params">(String key, String uniqueId, <span class="keyword">int</span> blockTime, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> endTime = System.currentTimeMillis() + blockTime;</span><br><span class="line">            <span class="keyword">while</span> (System.currentTimeMillis() &lt; endTime) &#123;</span><br><span class="line">                jedis = jedisPool.getResource();</span><br><span class="line">                String result = jedis.set(key, uniqueId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">                <span class="keyword">if</span> (LOCK_STATE.equals(result))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(DEFAULT_SLEEP_TIME);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="基于Redis的加锁第四版"><a href="#基于Redis的加锁第四版" class="headerlink" title="基于Redis的加锁第四版"></a>基于Redis的加锁第四版</h1><p>为了使对同一个对象添加多次锁，并且不发生阻塞，即实现类似可重入锁，我们借鉴了<code>ReetrantLock</code>的思想，添加了变量<code>states</code>来控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addLockVersion4</span><span class="params">(String key, String uniqueId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> state = states.get();</span><br><span class="line">        <span class="keyword">if</span> (state &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            states.set(state+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> doLock(key, uniqueId, expireTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doLock</span><span class="params">(String key, String uniqueId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (expireTime &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            String result = jedis.set(key, uniqueId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">            <span class="keyword">if</span> (LOCK_STATE.equals(result))</span><br><span class="line">                states.set(states.get() + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="基于Redis的加锁第五版"><a href="#基于Redis的加锁第五版" class="headerlink" title="基于Redis的加锁第五版"></a>基于Redis的加锁第五版</h1><p>从上面可知，利用<code>setnx</code>和<code>expire</code>实现加锁机制时因为不是原子操作，会产生一些问题，我们可用lua脚本来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addLockVersion5</span><span class="params">(String key, String uniqueId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            String luaScript = <span class="string">"if redis.call('setnx',KEYS[1],ARGV[1]) == 1 then"</span> +</span><br><span class="line">                    <span class="string">"redis.call('expire',KEYS[1],ARGV[2]) return 1 else return 0 end"</span>;</span><br><span class="line">            List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            keys.add(key);</span><br><span class="line">            values.add(uniqueId);</span><br><span class="line">            values.add(String.valueOf(expireTime));</span><br><span class="line">            Object result = jedis.eval(luaScript, keys, values);</span><br><span class="line">            <span class="keyword">if</span> ((Long)result == <span class="number">1L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="基于Redis的释放锁第一版"><a href="#基于Redis的释放锁第一版" class="headerlink" title="基于Redis的释放锁第一版"></a>基于Redis的释放锁第一版</h1><p>在解锁时首先判断加速与解锁是否是同一个客户端，然后利用<code>del</code>方法进行删除。<br>但是会出现一些问题。<br>当方法执行到判断内部时，即将要执行<code>del</code>方法时，该锁已经过期了，并被其他的客户端所请求应有，此时执行<code>del</code>会造成锁的误删。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLockVersion1</span><span class="params">(String key, String uniqueId)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            <span class="comment">//加锁与解锁是否是同一个客户端</span></span><br><span class="line">            String lockId = jedis.get(key);</span><br><span class="line">            <span class="keyword">if</span> (lockId != <span class="keyword">null</span> &amp;&amp; lockId.equals(uniqueId)) &#123;</span><br><span class="line">                jedis.del(key);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="基于Redis的释放锁第二版"><a href="#基于Redis的释放锁第二版" class="headerlink" title="基于Redis的释放锁第二版"></a>基于Redis的释放锁第二版</h1><p>从上面的分析来看，我们要确保删除的原子性，利用lua脚本可以保证一点。<br>在脚本语言里，KEYS[1]和ARGV[1]分别表示传入的key名和唯一标识符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLockVersion2</span><span class="params">(String key, String uniqueId)</span> </span>&#123;</span><br><span class="line">        String luaScript = <span class="string">"if  redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            result = jedis.eval(luaScript, Collections.singletonList(key), Collections.singletonList(uniqueId));</span><br><span class="line">            <span class="keyword">if</span> ((Long)result == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="基于Redis的释放锁第三版"><a href="#基于Redis的释放锁第三版" class="headerlink" title="基于Redis的释放锁第三版"></a>基于Redis的释放锁第三版</h1><p>在利用可重入锁思想时，只有当<code>states=1</code>时才能被释放，大于0时，只能进行减1操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLockVersion3</span><span class="params">(String key, String uniqueId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> state = states.get();</span><br><span class="line">        <span class="keyword">if</span> (state &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            states.set(states.get() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.doRelease(key, uniqueId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doRelease</span><span class="params">(String key, String uniqueId)</span> </span>&#123;</span><br><span class="line">        String luaScript = <span class="string">"if  redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            result = jedis.eval(luaScript, Collections.singletonList(key), Collections.singletonList(uniqueId));</span><br><span class="line">            <span class="keyword">if</span> ((Long)result == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            states.set(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="利用Zookeeper实现分布式锁"><a href="#利用Zookeeper实现分布式锁" class="headerlink" title="利用Zookeeper实现分布式锁"></a>利用Zookeeper实现分布式锁</h1><p>Zookeeper提供一个多层次的节点命名空间，每个节点都用一个以斜杠（/）分割的路径表示，<br>而且每个节点都有父节点（根节点除外），非常类似于文件系统。</p><p><strong>基本思想流程</strong></p><ul><li>在某父节点下添加创建一个节点，</li><li>获取该父节点下的所有子节点，并进行排序，获得有个有序序列</li><li>如果当前添加的节点是序列中序号最小的节点，表示获取锁成功</li><li>如果不是最小的节点，则对在有序列表中的它的前一个节点进行监听，当被监听的节点被删除后，会通知该节点获取锁。</li><li>解锁的时候删除当前节点。</li></ul><p><strong>实现代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">zklock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ZkClient zkClient;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String currentLockPath;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATENT_LOCK_PATH = <span class="string">"distribute_lock"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RETEY_TIMES = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WAIT_TIME = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">zklock</span><span class="params">(ZkClient zkClient, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zkClient = zkClient;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!zkClient.exists(PATENT_LOCK_PATH)) &#123;</span><br><span class="line">            zkClient.createPersistent(PATENT_LOCK_PATH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> iscompleted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!iscompleted) &#123;</span><br><span class="line">            iscompleted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//创建当前目录下的临时有序节点</span></span><br><span class="line">                currentLockPath = zkClient.createEphemeralSequential(PATENT_LOCK_PATH + <span class="string">"/"</span>, System.currentTimeMillis());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count++ &lt; MAX_RETEY_TIMES) &#123;</span><br><span class="line">                    iscompleted = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">throw</span>  e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        zkClient.delete(currentLockPath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查是否是最小的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkMinNode</span><span class="params">(String localPath)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; children = zkClient.getChildren(PATENT_LOCK_PATH);</span><br><span class="line">        Collections.sort(children);</span><br><span class="line">        <span class="keyword">int</span> index = children.indexOf(localPath.substring(PATENT_LOCK_PATH.length()+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (countDownLatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String waitPath = PATENT_LOCK_PATH + <span class="string">"/"</span> + children.get(index-<span class="number">1</span>);</span><br><span class="line">            waitForLock(waitPath, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听有序序列中的前一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">waitForLock</span><span class="params">(String waitPath, <span class="keyword">boolean</span> useTime)</span> </span>&#123;</span><br><span class="line">        countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        zkClient.subscribeDataChanges(waitPath, <span class="keyword">new</span> IZkDataListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataChange</span><span class="params">(String s, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataDeleted</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                 checkMinNode(currentLockPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (!zkClient.exists(waitPath)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (useTime == <span class="keyword">true</span>)</span><br><span class="line">                countDownLatch.await(DEFAULT_WAIT_TIME, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于Redis和Zookeeper的分布式锁的优劣"><a href="#基于Redis和Zookeeper的分布式锁的优劣" class="headerlink" title="基于Redis和Zookeeper的分布式锁的优劣"></a>基于Redis和Zookeeper的分布式锁的优劣</h1><ul><li>Redis是nosql数据库，主要特点是缓存；</li><li>Zookeeper是分布式协调工具，主要用于分布式解决方案。</li></ul><p><strong>加锁机制</strong></p><ul><li>Redis: 通过<code>set</code>方法创建key， 因为Redis的key是唯一的，谁先创建成功，谁能够先获得锁。</li><li>Zookeeper: 会在Zookeeper上创建一个临时节点，因为Zookeeper节点命名路径保证唯一，只要谁先创建成功，谁能够获取到锁。</li></ul><p><strong>释放锁</strong></p><ul><li>Redis: 为了确保锁的一致性问题，在删除的redis的key时，需要判断是否是之前拥有该锁的客户端；通过设置有效期解决死锁。</li><li>Zookeeper: 直接关闭临时节点session会话连接，因为临时节点生命周期与session会话绑定在一块，如果session会话连接关闭的话，该临时节点也会被删除。</li></ul><p>就性能而言，redis是Nosql数据库，性能优于zookeeper;就健壮性而言，zookeeper明显优于redis。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么要设计分布式锁&quot;&gt;&lt;a href=&quot;#为什么要设计分布式锁&quot; class=&quot;headerlink&quot; title=&quot;为什么要设计分布式锁&quot;&gt;&lt;/a&gt;为什么要设计分布式锁&lt;/h1&gt;&lt;p&gt;  在简单的单机系统中，当存在多个线程同时要修改某个共享变量时，为了数据的操
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redo日志、undo日志、binlog日志与doublewrite分析</title>
    <link href="https://github.com/spurstong/2020/01/11/redo%E6%97%A5%E5%BF%97%E3%80%81undo%E6%97%A5%E5%BF%97%E3%80%81binlog%E6%97%A5%E5%BF%97%E4%B8%8Edoulewrite%E6%93%8D%E4%BD%9C/"/>
    <id>https://github.com/spurstong/2020/01/11/redo日志、undo日志、binlog日志与doulewrite操作/</id>
    <published>2020-01-11T07:46:35.000Z</published>
    <updated>2020-01-11T07:47:14.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="binlog日志-（二进制日志）"><a href="#binlog日志-（二进制日志）" class="headerlink" title="binlog日志 （二进制日志）"></a>binlog日志 （二进制日志）</h1><p>二进制日志记录了对MySQL数据库<strong>执行更改的所有操作</strong>，它是一种逻辑操作，其记录的是对应的SQL语句。但是，不会记录SELECT和SHOW这类操作，因为这类操作对数据本身并没有修改。</p><h2 id="二进制文件格式"><a href="#二进制文件格式" class="headerlink" title="二进制文件格式"></a>二进制文件格式</h2><p>MySQL通过binlog_format参数来设置二进制文件格式。</p><ul><li><strong>STATEMENT格式</strong>。 最基础的版本。它记录的是日志的逻辑SQL语句。</li><li><strong>ROW格式</strong>。记录的不是简单的逻辑SQL语句，而是记录表的行更改情况，记录的是表中每个字段的值。</li><li><strong>MIXED格式</strong>。MySQL默认采用STATEMENT格式进行记录，但是一旦判断可能会有数据不一致的情况，则会有ROW格式来记录。</li></ul><h2 id="二进制文件的用途"><a href="#二进制文件的用途" class="headerlink" title="二进制文件的用途"></a>二进制文件的用途</h2><ul><li><strong>恢复</strong>。某些数据的恢复需要二进制文件。</li><li><strong>复制</strong>。通过复制和执行二进制文件进行两个数据库之间的实时同步。</li><li><strong>审计</strong>。判断是否有对数据库进行注入的攻击。</li></ul><p>在默认情况下，二进制文件并不是在每次写的时候同步到磁盘中。因此，当数据库所在操作系统发生宕机时，可能会有最后一部分数据没有写入到二进制日志文件中，这会给恢复和复制带来问题。<br>所有未提交的二进制日志会被记录到一个缓存中，等该事务提交时直接将缓存的二进制日志写入二进制日志文件，而该缓存的大小由binlog_cache_size决定。</p><h1 id="Redo日志"><a href="#Redo日志" class="headerlink" title="Redo日志"></a>Redo日志</h1><p>binlog主要用来做数据归档，但它不具备崩溃恢复的能力，如果你的系统突然崩溃宕机，重启后可能会有部分数据丢失，而Redo日志能够有效解决这个问题。可以把它看做一种恢复操作，它恢复提交事务修改的页操作。大部分情况下，Redo是<strong>物理日志</strong>，记录的是数据页的物理操作。<br>它主要有两部分：（1）重做日志缓冲，其是丢失的；（2）重做日志文件，其是持久的。</p><h2 id="Redo的整体流程"><a href="#Redo的整体流程" class="headerlink" title="Redo的整体流程"></a>Redo的整体流程</h2><ol><li>先将原始数据从磁盘中读入内存中，修改数据的内存拷贝</li><li>生成一条重做日志并写入重做日志缓存中，记录的是数据被修改后的值</li><li>当事务提交时，将重做日志缓存中的内容刷新追加到重做日志文件中。</li><li>定期将内存中修改的数据刷新到磁盘中。<h2 id="何时写入到Redo-重做日志文件-中"><a href="#何时写入到Redo-重做日志文件-中" class="headerlink" title="何时写入到Redo(重做日志文件)中"></a>何时写入到Redo(重做日志文件)中</h2></li></ol><ul><li>master thread 每一秒将重做日志缓存刷新到重做日志文件中。</li><li>每次事务提交时。</li><li>当重做日志缓存池剩余空间小于1/2时。</li></ul><h2 id="Redo日志与二进制日志的不同"><a href="#Redo日志与二进制日志的不同" class="headerlink" title="Redo日志与二进制日志的不同"></a>Redo日志与二进制日志的不同</h2><p>从表面上看，它们非常相似，都是记录了数据库操作的日志，但从本质上看，两者有非常大的不同。</p><ol><li><strong>产生位置不同</strong>。重做日志是在InnoDB存储引擎层中产生，而二进制日志是在MySQL数据库的上层产生。</li><li><strong>记录的内容形式不同</strong>。二进制日志是一种逻辑日志，其记录的是对应的SQL语句，但是在ROW格式下，它记录的是物理文件；而重做日志是物理格式日志，其记录的是对于每个页的修改。</li><li><strong>写入磁盘的时间点不同</strong>。二进制日志只是在事务提交完成后进行一次写入，而InnoDB存储引擎的重做日志在事务进行中不断被写入，</li></ol><h1 id="Undo日志"><a href="#Undo日志" class="headerlink" title="Undo日志"></a>Undo日志</h1><p>当用户执行的事务或语句由于某种原因失败时，又或者用户用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。还有一个作用是MVCC。</p><p>undo存放在数据库内部的一个特殊段中，成为undo端（undo segment）。undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。<br>在MVCC中，当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读。</p><h2 id="undo-log格式"><a href="#undo-log格式" class="headerlink" title="undo log格式"></a>undo log格式</h2><ul><li><p>insert undo log<br>是指在insert操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见，故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p></li><li><p>updae undo log<br>记录的是对delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除，提交时放入到undo log链表，等待purge线程进行最后的删除。</p></li></ul><h2 id="purge"><a href="#purge" class="headerlink" title="purge"></a>purge</h2><p>例如语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>其中，表t上列a有聚集索引，列b上有辅助索引。当执行delete删除操作时，仅是将主键列等于1的记录delete flag设置为1，记录并没有被删除，即记录还是存在于B+树中，其次，对于辅助索引上列a等于1，b等于1的记录同样没有做任何处理，甚至没有产生undo log。而真正删除这行记录的操作其实被“延迟”了，在purge操作中完成。<br>在MVCC下，有可能其他事务也在引用该行记录，故InnoDB需要保存记录之前的版本，当该条记录不被任何事务所引用时，那么可以执行真正的delete操作。</p><h1 id="doublewrite-两次写"><a href="#doublewrite-两次写" class="headerlink" title="doublewrite(两次写)"></a>doublewrite(两次写)</h1><p>doublewrite能够确保InnoDB存储引擎的数据页的可靠性。<br>如果InnnoDB存储引擎正在写入某个页到表中，可能只写了页中的一部分就发生了宕机等故障，造成部分写失效。需要对数据进行恢复。<br>可能首先想到实现数据恢复的做法是利用Redo log（重做日志）,但是重做日志记录的是对页的物理操作，但是如果这个页已经发生了损坏，再对其页页进行重做就没有意义了。这时就用到了<strong>doublewrite</strong>操作。<br>简单的说，在应用重做日志之前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/%E6%95%B0%E6%8D%AE%E5%BA%93doublewrite/1.png" alt="doublewrite步骤"><br>doublewrite由两部分组成，一部分是内存中的doublewrite,大小为2MB;另一部分是物理磁盘上共享表空间中连续的128个页，即两个区，大小同样我2MB。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer,之后通过double write再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。<br>如果操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，InnoDB存储引擎可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件中，再应用重做日志。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;binlog日志-（二进制日志）&quot;&gt;&lt;a href=&quot;#binlog日志-（二进制日志）&quot; class=&quot;headerlink&quot; title=&quot;binlog日志 （二进制日志）&quot;&gt;&lt;/a&gt;binlog日志 （二进制日志）&lt;/h1&gt;&lt;p&gt;二进制日志记录了对MySQL
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rocketMq消息主从同步机制</title>
    <link href="https://github.com/spurstong/2019/12/04/rocketMq%E6%B6%88%E6%81%AF%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    <id>https://github.com/spurstong/2019/12/04/rocketMq消息主从同步机制/</id>
    <published>2019-12-04T10:05:44.505Z</published>
    <updated>2019-12-05T14:39:21.545Z</updated>
    
    <content type="html"><![CDATA[<p>RocketMQ具有高可用性，消息消费到达主服务器Master后需要将消息同步到消息从服务器Slave,如果主服务器Master宕机后，消息消费者可以向Slave拉取消息。</p><h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p>主服务器Master启动，监听从服务器Slave的监听；从服务器Slave启动，主动向主服务器建立Tcp长连接，然后获取从服务器Slave的commitlog的最大偏移量，以此偏移量向主服务器Master主动拉取消息（间隔5s发送一次），主服务器根据偏移量，与自身commitlog文件的最大偏移量进行比较，如果大于Slave的最大偏移量，主服务器Master将向从服务器Slave返回一定数量的消息，将消息写入到Slave的commitlog文件中，该过程循环进行，如果从服务器Slave的最大偏移量大于等于主服务器Master的最大偏移量，说明主从服务器数据同步完成。</p><h1 id="相关类介绍"><a href="#相关类介绍" class="headerlink" title="相关类介绍"></a>相关类介绍</h1><p>HAservice: 主从同步核心实现类<br>AcceptSocketService： HA Master端监听客户端连接实现类<br>GroupTransferService: 主从同步通知实现类<br>HAClient: HA Client端实现类（从服务器）<br>HAConnection: HA Master服务端HA连接对象的封装，与Broker从服务器的网络读写实现类<br>ReadSocketService: HA Master网络读实现类<br>WriterSocketService: HA Master网络写实现类</p><h1 id="主从同步Slave端实现"><a href="#主从同步Slave端实现" class="headerlink" title="主从同步Slave端实现"></a>主从同步Slave端实现</h1><p>相关类是HAClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HAClient</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READ_MAX_BUFFER_SIZE = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// 主节点IP:PORT</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;String&gt; masterAddress = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">        <span class="comment">// 向Master汇报Slave最大Offset</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer reportOffset = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> lastWriteTimestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// Slave向Master汇报Offset，汇报到哪里</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> currentReportedOffset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> dispatchPostion = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从Master接收数据Buffer</span></span><br><span class="line">        <span class="keyword">private</span> ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);</span><br><span class="line">        <span class="keyword">private</span> ByteBuffer byteBufferBackup = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与Master进行连接</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">connectMaster</span><span class="params">()</span> <span class="keyword">throws</span> ClosedChannelException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == socketChannel) &#123;</span><br><span class="line">                String addr = <span class="keyword">this</span>.masterAddress.get();</span><br><span class="line">                <span class="keyword">if</span> (addr != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    SocketAddress socketAddress = RemotingUtil.string2SocketAddress(addr);</span><br><span class="line">                    <span class="keyword">if</span> (socketAddress != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.socketChannel = RemotingUtil.connect(socketAddress);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.socketChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.socketChannel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_READ);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 每次连接时，要重新拿到最大的Offset</span></span><br><span class="line">                <span class="keyword">this</span>.currentReportedOffset = HAService.<span class="keyword">this</span>.defaultMessageStore.getMaxPhyOffset();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.lastWriteTimestamp = System.currentTimeMillis();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.socketChannel != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>Slave服务器连接Master服务器，获取当前文件的最大偏移量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isTimeToReportOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">long</span> interval =</span><br><span class="line">               HAService.<span class="keyword">this</span>.defaultMessageStore.getSystemClock().now() - <span class="keyword">this</span>.lastWriteTimestamp;</span><br><span class="line">           <span class="keyword">boolean</span> needHeart = interval &gt; HAService.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig()</span><br><span class="line">               .getHaSendHeartbeatInterval();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> needHeart;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>判断是否向Master反馈当前待拉取偏移量，默认间隔5s发送一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">reportSlaveMaxOffset</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> maxOffset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.reportOffset.position(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">this</span>.reportOffset.limit(<span class="number">8</span>);</span><br><span class="line">  <span class="keyword">this</span>.reportOffset.putLong(maxOffset);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.reportOffset.position(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">this</span>.reportOffset.limit(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送失败了试三次，成功就成功</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> &amp;&amp; <span class="keyword">this</span>.reportOffset.hasRemaining(); i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.socketChannel.write(<span class="keyword">this</span>.reportOffset);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">log.error(<span class="keyword">this</span>.getServiceName()</span><br><span class="line">+ <span class="string">"reportSlaveMaxOffset this.socketChannel.write exception"</span>, e);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> !<span class="keyword">this</span>.reportOffset.hasRemaining();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向Master服务器反馈拉取偏移量，如果发送失败，会再进行尝试，总共三次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">processReadEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> readSizeZeroTimes = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.byteBufferRead.hasRemaining()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> readSize = <span class="keyword">this</span>.socketChannel.read(<span class="keyword">this</span>.byteBufferRead);</span><br><span class="line">                    <span class="keyword">if</span> (readSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        lastWriteTimestamp = HAService.<span class="keyword">this</span>.defaultMessageStore.getSystemClock().now();</span><br><span class="line">                        readSizeZeroTimes = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">boolean</span> result = <span class="keyword">this</span>.dispatchReadRequest();</span><br><span class="line">                        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                            log.error(<span class="string">"HAClient, dispatchReadRequest error"</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readSize == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (++readSizeZeroTimes &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// TODO ERROR</span></span><br><span class="line">                        log.info(<span class="string">"HAClient, processReadEvent read socket &lt; 0"</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    log.info(<span class="string">"HAClient, processReadEvent read socket exception"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>处理网络请求，即处理从Master服务器传回的消息数据。循环判断readByteBuffer是否有剩余空间，如果存在剩余空间，则将通道里的数据读入到读缓存区中。<br> 1） 如果读取到的字节数大于0，重置读取到0字节的次数，并更新最后一次写入时间戳，然后将读取到的所有消息全部追加到消息内存映射文件中，然后再次反馈拉取进度给服务器。<br> 2） 如果连续3次从网络通道里读取到0个字节，则结束本次读，并返回true。<br> 3） 如果读取到的字节数小于0或发生IO异常，则返回false。</p><h1 id="主服务器Master处理请求"><a href="#主服务器Master处理请求" class="headerlink" title="主服务器Master处理请求"></a>主服务器Master处理请求</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HAConnection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HAService haService;</span><br><span class="line">    <span class="comment">// 网络socket通道</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="comment">// 客户端连接地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String clientAddr;</span><br><span class="line">    <span class="comment">// 服务端向从服务器slave写数据服务类</span></span><br><span class="line">    <span class="keyword">private</span> WriteSocketService writeSocketService;</span><br><span class="line">    <span class="comment">// 服务端从从服务器slave读数据服务类</span></span><br><span class="line">    <span class="keyword">private</span> ReadSocketService readSocketService;</span><br><span class="line">    <span class="comment">// 从服务器slave请求拉取数据的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> slaveRequestOffset = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从服务器slave反馈已拉取完成的数据偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> slaveAckOffset = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>Master服务器每隔1s处理一次slave发起的拉取请求。<br>首先会调用proccessReadEvent方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">processReadEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> readSizeZeroTimes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.byteBufferRead.hasRemaining()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.byteBufferRead.flip();</span><br><span class="line">                <span class="keyword">this</span>.processPostion = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.byteBufferRead.hasRemaining()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> readSize = <span class="keyword">this</span>.socketChannel.read(<span class="keyword">this</span>.byteBufferRead);</span><br><span class="line">                    <span class="keyword">if</span> (readSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        readSizeZeroTimes = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">this</span>.lastReadTimestamp = HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getSystemClock().now();</span><br><span class="line">                        <span class="keyword">if</span> ((<span class="keyword">this</span>.byteBufferRead.position() - <span class="keyword">this</span>.processPostion) &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">                            <span class="keyword">int</span> pos = <span class="keyword">this</span>.byteBufferRead.position() - (<span class="keyword">this</span>.byteBufferRead.position() % <span class="number">8</span>);</span><br><span class="line">                            <span class="keyword">long</span> readOffset = <span class="keyword">this</span>.byteBufferRead.getLong(pos - <span class="number">8</span>);</span><br><span class="line">                            <span class="keyword">this</span>.processPostion = pos;</span><br><span class="line"></span><br><span class="line">                            HAConnection.<span class="keyword">this</span>.slaveAckOffset = readOffset;</span><br><span class="line">                            <span class="keyword">if</span> (HAConnection.<span class="keyword">this</span>.slaveRequestOffset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                HAConnection.<span class="keyword">this</span>.slaveRequestOffset = readOffset;</span><br><span class="line">                                log.info(<span class="string">"slave["</span> + HAConnection.<span class="keyword">this</span>.clientAddr + <span class="string">"] request offset "</span> + readOffset);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            HAConnection.<span class="keyword">this</span>.haService.notifyTransferSome(HAConnection.<span class="keyword">this</span>.slaveAckOffset);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readSize == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (++readSizeZeroTimes &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log.error(<span class="string">"read socket["</span> + HAConnection.<span class="keyword">this</span>.clientAddr + <span class="string">"] &lt; 0"</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    log.error(<span class="string">"processReadEvent exception"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>1) 如果byteBufferRead没有剩余空间，则调用byteBufferRead.flip()清空，并设置processPostion为0，表示从头开始处理。<br>2) 当byteBuffer有剩余空间时，先预设readSizeZeroTimes为0，如果读取的字节大于0并且本次读取到的内容大于8，则表明收到了从服务器Slave一条拉取消息的请求，并调用<strong>notifyTransferSome</strong>方法。<br>3) 如果读取到的字节数等于0，则判断readSizeZeroTimes，当小于3时需要再进行循环处理，如果大于3，说明该批次请求已成功处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyTransferSome</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">long</span> value = <span class="keyword">this</span>.push2SlaveMaxOffset.get(); offset &gt; value; ) &#123;</span><br><span class="line">           <span class="keyword">boolean</span> ok = <span class="keyword">this</span>.push2SlaveMaxOffset.compareAndSet(value, offset);</span><br><span class="line">           <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">               <span class="keyword">this</span>.groupTransferService.notifyTransferSome();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               value = <span class="keyword">this</span>.push2SlaveMaxOffset.get();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>该方法的参数offset记录的是从服务器slave反馈的已拉取完成的数据偏移量，<br>push2SlaveMaxOffset记录的是写入到Slave的最大偏移量。<br>如果从服务器slave确认的偏移量大于push2SlaveMaxOffset,说明该批次主从同步成功，并更新push2SlaveMaxOffset,<br>则唤醒GroupTransferService线程，各消息发送者线程再次判断自己</p><p>然后介绍WriteSocketService线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (-<span class="number">1</span> == HAConnection.<span class="keyword">this</span>.slaveRequestOffset) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure><p>如果<strong>slaveRequestOffset</strong>等于-1，说明Master还未收到从服务器的拉取请求，放弃本事件的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (-<span class="number">1</span> == <span class="keyword">this</span>.nextTransferFromWhere) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (<span class="number">0</span> == HAConnection.<span class="keyword">this</span>.slaveRequestOffset) &#123;</span><br><span class="line">                           <span class="keyword">long</span> masterOffset = HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getCommitLog().getMaxOffset();</span><br><span class="line">                           masterOffset =</span><br><span class="line">                               masterOffset</span><br><span class="line">                                   - (masterOffset % HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig()</span><br><span class="line">                                   .getMapedFileSizeCommitLog());</span><br><span class="line"></span><br><span class="line">                           <span class="keyword">if</span> (masterOffset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                               masterOffset = <span class="number">0</span>;</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                           <span class="keyword">this</span>.nextTransferFromWhere = masterOffset;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="keyword">this</span>.nextTransferFromWhere = HAConnection.<span class="keyword">this</span>.slaveRequestOffset;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       log.info(<span class="string">"master transfer data from "</span> + <span class="keyword">this</span>.nextTransferFromWhere + <span class="string">" to slave["</span> + HAConnection.<span class="keyword">this</span>.clientAddr</span><br><span class="line">                           + <span class="string">"], and slave request "</span> + HAConnection.<span class="keyword">this</span>.slaveRequestOffset);</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure><p>如果<strong>nextTransferFromWhere</strong>等于-1，表示初次进行数据传输，计算待传输的物理偏移量，如果slaveRequestOffset为0，则从当前commitlog文件最大偏移量开始传输，否则根据从服务器的拉取请求偏移量开始传输。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.lastWriteOver) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">long</span> interval =</span><br><span class="line">                            HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getSystemClock().now() - <span class="keyword">this</span>.lastWriteTimestamp;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (interval &gt; HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig()</span><br><span class="line">                            .getHaSendHeartbeatInterval()) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// Build Header</span></span><br><span class="line">                            <span class="keyword">this</span>.byteBufferHeader.position(<span class="number">0</span>);</span><br><span class="line">                            <span class="keyword">this</span>.byteBufferHeader.limit(headerSize);</span><br><span class="line">                            <span class="keyword">this</span>.byteBufferHeader.putLong(<span class="keyword">this</span>.nextTransferFromWhere);</span><br><span class="line">                            <span class="keyword">this</span>.byteBufferHeader.putInt(<span class="number">0</span>);</span><br><span class="line">                            <span class="keyword">this</span>.byteBufferHeader.flip();</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">this</span>.lastWriteOver = <span class="keyword">this</span>.transferData();</span><br><span class="line">                            <span class="keyword">if</span> (!<span class="keyword">this</span>.lastWriteOver)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.lastWriteOver = <span class="keyword">this</span>.transferData();</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="keyword">this</span>.lastWriteOver)</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure><p>判断上次写事件是否已将消息全部写入客户端，如果已全部写入，并且当前系统时间与上次最后写入的时间间隔大于HA心跳检测时间，则发送一个心跳包，避免长连接由于空闲被关闭；如果上次数据未写完，则先传输上一次的数据，如果消息还是未全部传输，则结束此次事件处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SelectMappedBufferResult selectResult =</span><br><span class="line">                        HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getCommitLogData(<span class="keyword">this</span>.nextTransferFromWhere);</span><br><span class="line">                    <span class="keyword">if</span> (selectResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> size = selectResult.getSize();</span><br><span class="line">                        <span class="keyword">if</span> (size &gt; HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize()) &#123;</span><br><span class="line">                            size = HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">long</span> thisOffset = <span class="keyword">this</span>.nextTransferFromWhere;</span><br><span class="line">                        <span class="keyword">this</span>.nextTransferFromWhere += size;</span><br><span class="line"></span><br><span class="line">                        selectResult.getByteBuffer().limit(size);</span><br><span class="line">                        <span class="keyword">this</span>.selectMappedBufferResult = selectResult;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Build Header</span></span><br><span class="line">                        <span class="keyword">this</span>.byteBufferHeader.position(<span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">this</span>.byteBufferHeader.limit(headerSize);</span><br><span class="line">                        <span class="keyword">this</span>.byteBufferHeader.putLong(thisOffset);</span><br><span class="line">                        <span class="keyword">this</span>.byteBufferHeader.putInt(size);</span><br><span class="line">                        <span class="keyword">this</span>.byteBufferHeader.flip();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">this</span>.lastWriteOver = <span class="keyword">this</span>.transferData();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        HAConnection.<span class="keyword">this</span>.haService.getWaitNotifyObject().allWaitForRunning(<span class="number">100</span>);</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure><p>传输消息到从服务器slave<br>1) 根据消息从服务器slave请求的待拉取偏移量，查找该偏移量之后的所有的可读消息，如果未查到匹配的消息，通知所有等待线程继续等待100ms。<br>2) 如果匹配到消息，且查找到的消息总长度大于配置的一次传输最大字节数，则会进行截取，可能会包含不完整的消息。</p><p>主服务器Master会一直执行该线程，每次事件处理完成后等待1s。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWaitTransfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!<span class="keyword">this</span>.requestsRead.isEmpty()) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (CommitLog.GroupCommitRequest req : <span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">                       <span class="keyword">boolean</span> transferOK = HAService.<span class="keyword">this</span>.push2SlaveMaxOffset.get() &gt;= req.getNextOffset();</span><br><span class="line">                       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; !transferOK &amp;&amp; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                           <span class="keyword">this</span>.notifyTransferObject.waitForRunning(<span class="number">1000</span>);</span><br><span class="line">                           transferOK = HAService.<span class="keyword">this</span>.push2SlaveMaxOffset.get() &gt;= req.getNextOffset();</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">if</span> (!transferOK) &#123;</span><br><span class="line">                           log.warn(<span class="string">"transfer messsage to slave timeout, "</span> + req.getNextOffset());</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       req.wakeupCustomer(transferOK);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">this</span>.requestsRead.clear();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>GroupTransferService#doWaitTransfer()方法<br>该类是主从同步复制的实现类</p><p>在进行主从同步时，有同步主从模式和异步主从模式，当主服务器Master发送消息给从服务器Slave时，需要先判断上一次同步主从复制的结果，如果Slave中已成功复制的最大偏移量是否大于Master发送给Slave消息后返回的下一条消息的起始偏移量，如果大于，则说明上一个主从同步复制已经完成，则会唤醒阻塞等待的消息发送到Slave的命令。</p><p>RocketMq读写分离与其他中间件的实现方式完全不同，RoketMq是消息者首先向主服务器Master发起拉取消息请求，然后主服务器返回一批消息，然后会根据主服务器负载压力与主从同步情况，建议下次消息拉取是从主服务器还是从从服务器拉取。</p><p>决定消费者是否向从服务器拉取消息消费的值存在 GetMessageResult 类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> suggestPullingFromSlave = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>其默认值为 false，即默认消费者不会消费从服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> diff = maxOffsetPy - maxPhyOffsetPulling;</span><br><span class="line"><span class="keyword">long</span> memory = (<span class="keyword">long</span>) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE</span><br><span class="line">    * (<span class="keyword">this</span>.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / <span class="number">100.0</span>));</span><br><span class="line">getResult.setSuggestPullingFromSlave(diff &gt; memory);</span><br></pre></td></tr></table></figure><p>其中 maxOffsetPy 为当前最大物理偏移量，maxPhyOffsetPulling 为本次消息拉取最大物理偏移量，他们的差即可表示消息堆积量，TOTAL_PHYSICAL_MEMORY_SIZE 表示当前系统物理内存，accessMessageInMemoryMaxRatio 的默认值为 40，以上逻辑即可算出当前消息堆积量是否大于物理内存的 40 %，如果大于则将 suggestPullingFromSlave 设置为 true。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RocketMQ具有高可用性，消息消费到达主服务器Master后需要将消息同步到消息从服务器Slave,如果主服务器Master宕机后，消息消费者可以向Slave拉取消息。&lt;/p&gt;
&lt;h1 id=&quot;整体流程&quot;&gt;&lt;a href=&quot;#整体流程&quot; class=&quot;headerlin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ消费者消息队列负载均衡</title>
    <link href="https://github.com/spurstong/2019/11/30/RocketMQ%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://github.com/spurstong/2019/11/30/RocketMQ消费者消息队列负载均衡/</id>
    <published>2019-11-30T10:23:21.282Z</published>
    <updated>2019-11-30T14:57:35.198Z</updated>
    
    <content type="html"><![CDATA[<p>先从整体流程上简单梳理一下消息队列负载的过程。</p><p>消息队列负载由Rebalance线程默认每隔20s进行一次消息队列负载，获取主题队列信息mqSet与消费组当前所有消费者cidAll,然后按照某一种负载算法进行队列分配，分配原则为同一个消费者可以分配多个消息消息队列，同一个消息消费队列同一时间只会分配给一个消费者。此时，可以计算当前消费者分配到消息队列集合，对比原先的负载队列与当前的分配队列。如果新队列集合中不包含原来的队列，则停止原先队列消息消费并移除，如果原先队列中不包含新分配队列则创建PullRequest。</p><h1 id="何时会触发启动"><a href="#何时会触发启动" class="headerlink" title="何时会触发启动"></a>何时会触发启动</h1><ul><li>每隔20s会自动进行一次</li><li>每次有新的consumer加入到消费组中时，就会执行一次。</li></ul><h1 id="提供的分配算法"><a href="#提供的分配算法" class="headerlink" title="提供的分配算法"></a>提供的分配算法</h1><ul><li>AllocateMessageQueueAveragely: 平均分配。</li><li>AllocateMessageQueueAveragelyByCircle: 平均轮询分配</li><li>AllocateMessageQueueConsistentHash: 一致性hash</li><li>AllocateMessageQueueByConfig: 根据配置，为每一个消费者配置固定的消息队列。</li><li>AllocateMessageQueueByMachineRoom: 根据Broker部署机房名，对每个消费者负责不同的Broker上的队列。</li></ul><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>进行负载均衡是在RebalanceService线程中启动的，一个MQClientInstance持有一个RebalanceService实现，并随着MQClientInstance的启动而启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line">       <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">           <span class="comment">//waitInterval默认为20s。</span></span><br><span class="line">           <span class="keyword">this</span>.waitForRunning(waitInterval);</span><br><span class="line">           <span class="comment">//定时负载均衡</span></span><br><span class="line">           <span class="keyword">this</span>.mqClientFactory.doRebalance();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* group */</span>, MQConsumerInner&gt; consumerTable = <span class="keyword">new</span> ConcurrentHashMap&lt;String, MQConsumerInner&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, MQConsumerInner&gt; entry : <span class="keyword">this</span>.consumerTable.entrySet()) &#123;</span><br><span class="line">            MQConsumerInner impl = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    impl.doRebalance();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"doRebalance exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMQPushConsumerImpl</span> <span class="keyword">implements</span> <span class="title">MQConsumerInner</span></span></span><br></pre></td></tr></table></figure><p>从上面可以看出，MQClientinstance遍历已注册的消费者，对消费者执行doRebalance方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ConcurrentMap&lt;String <span class="comment">/* topic */</span>, SubscriptionData&gt; subscriptionInner =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;String, SubscriptionData&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, SubscriptionData&gt; subTable = <span class="keyword">this</span>.getSubscriptionInner();</span><br><span class="line">        <span class="keyword">if</span> (subTable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">final</span> String topic = entry.getKey();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.rebalanceByTopic(topic, isOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                        log.warn(<span class="string">"rebalanceByTopic Exception"</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.truncateMessageQueueNotMyTopic();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面是遍历订阅信息对每个主题的队列进行重新负载。接下来将执行<em>rebalanceByTopic</em>方法，会根据广播模式或集群模式分别采用不同的方法进行处理。在此处，只解释集群模式下的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">List&lt;String&gt; cidAll = <span class="keyword">this</span>.mQClientFactory.findConsumerIdList(topic, consumerGroup);</span><br></pre></td></tr></table></figure><p>获取该主题下的队列信息和该消费组内当前所有的消费者ID。每个DefaultMQPushConsumerImpl都持有一个单独的RebalanceImpl对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mqSet != <span class="keyword">null</span> &amp;&amp; cidAll != <span class="keyword">null</span>) &#123;</span><br><span class="line">    List&lt;MessageQueue&gt; mqAll = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line">    mqAll.addAll(mqSet);</span><br><span class="line"></span><br><span class="line">   Collections.sort(mqAll);</span><br><span class="line">   Collections.sort(cidAll);</span><br><span class="line"></span><br><span class="line">   AllocateMessageQueueStrategy strategy = <span class="keyword">this</span>.allocateMessageQueueStrategy;</span><br><span class="line"></span><br><span class="line">   List&lt;MessageQueue&gt; allocateResult = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">//根据策略进行分配</span></span><br><span class="line">   allocateResult = strategy.allocate(<span class="comment">//</span></span><br><span class="line">   <span class="keyword">this</span>.consumerGroup, <span class="comment">//</span></span><br><span class="line">   <span class="keyword">this</span>.mQClientFactory.getClientId(), <span class="comment">//</span></span><br><span class="line">   mqAll, <span class="comment">//</span></span><br><span class="line">   cidAll);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">   log.error(<span class="string">"AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;"</span>, strategy.getName(),</span><br><span class="line">   e);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AllocateMessageQueueStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Allocating by consumer id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumerGroup current consumer group</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> currentCID current consumer id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mqAll message queue set in current topic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cidAll consumer set in current consumer group</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The allocate result of given strategy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;MessageQueue&gt; <span class="title">allocate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String consumerGroup,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String currentCID,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> List&lt;MessageQueue&gt; mqAll,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> List&lt;String&gt; cidAll</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br></pre></td></tr></table></figure><p>对该主题下的队列信息和该消费组内当前所有的消费者ID进行排序，确保一个消费组的成员看到的顺序是一致的，防止同一个消费队列不会被多个消费者分配。<br><strong>allocateResult</strong>记录的是当前消费者的所分配的消息队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> Set&lt;MessageQueue&gt; allocateResultSet = <span class="keyword">new</span> HashSet&lt;MessageQueue&gt;();</span><br><span class="line"> <span class="keyword">if</span> (allocateResult != <span class="keyword">null</span>) &#123;</span><br><span class="line"> allocateResultSet.addAll(allocateResult);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">boolean</span> changed = <span class="keyword">this</span>.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);</span><br></pre></td></tr></table></figure><p>调用<code>updateProcessQueueTableInRebalance</code>对比消息队列是否发生变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateProcessQueueTableInRebalance</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> Set&lt;MessageQueue&gt; mqSet, <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = <span class="keyword">this</span>.processQueueTable.entrySet().iterator();</span><br><span class="line">       <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">           Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();</span><br><span class="line">           MessageQueue mq = next.getKey();</span><br><span class="line">           ProcessQueue pq = next.getValue();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (mq.getTopic().equals(topic)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!mqSet.contains(mq)) &#123;</span><br><span class="line">                   pq.setDropped(<span class="keyword">true</span>);</span><br><span class="line">                   <span class="keyword">if</span> (<span class="keyword">this</span>.removeUnnecessaryMessageQueue(mq, pq)) &#123;</span><br><span class="line">                       it.remove();</span><br><span class="line">                       changed = <span class="keyword">true</span>;</span><br><span class="line">                       log.info(<span class="string">"doRebalance, &#123;&#125;, remove unnecessary mq, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pq.isPullExpired()) &#123;</span><br><span class="line">                   <span class="keyword">switch</span> (<span class="keyword">this</span>.consumeType()) &#123;</span><br><span class="line">                       <span class="keyword">case</span> CONSUME_ACTIVELY:</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       <span class="keyword">case</span> CONSUME_PASSIVELY:</span><br><span class="line">                           pq.setDropped(<span class="keyword">true</span>);</span><br><span class="line">                           <span class="keyword">if</span> (<span class="keyword">this</span>.removeUnnecessaryMessageQueue(mq, pq)) &#123;</span><br><span class="line">                               it.remove();</span><br><span class="line">                               changed = <span class="keyword">true</span>;</span><br><span class="line">                               log.error(<span class="string">"[BUG]doRebalance, &#123;&#125;, remove unnecessary mq, &#123;&#125;, because pull is pause, so try to fixed it"</span>,</span><br><span class="line">                                   consumerGroup, mq);</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       <span class="keyword">default</span>:</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       List&lt;PullRequest&gt; pullRequestList = <span class="keyword">new</span> ArrayList&lt;PullRequest&gt;();</span><br><span class="line">       <span class="keyword">for</span> (MessageQueue mq : mqSet) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!<span class="keyword">this</span>.processQueueTable.containsKey(mq)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (isOrder &amp;&amp; !<span class="keyword">this</span>.lock(mq)) &#123;</span><br><span class="line">                   log.warn(<span class="string">"doRebalance, &#123;&#125;, add a new mq failed, &#123;&#125;, because lock failed"</span>, consumerGroup, mq);</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">this</span>.removeDirtyOffset(mq);</span><br><span class="line">               ProcessQueue pq = <span class="keyword">new</span> ProcessQueue();</span><br><span class="line">               <span class="comment">//计算消息队列开始消费位置</span></span><br><span class="line">               <span class="keyword">long</span> nextOffset = <span class="keyword">this</span>.computePullFromWhere(mq);</span><br><span class="line">               <span class="keyword">if</span> (nextOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   ProcessQueue pre = <span class="keyword">this</span>.processQueueTable.putIfAbsent(mq, pq);</span><br><span class="line">                   <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       log.info(<span class="string">"doRebalance, &#123;&#125;, mq already exists, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       log.info(<span class="string">"doRebalance, &#123;&#125;, add a new mq, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">                       PullRequest pullRequest = <span class="keyword">new</span> PullRequest();</span><br><span class="line">                       pullRequest.setConsumerGroup(consumerGroup);</span><br><span class="line">                       pullRequest.setNextOffset(nextOffset);</span><br><span class="line">                       pullRequest.setMessageQueue(mq);</span><br><span class="line">                       pullRequest.setProcessQueue(pq);</span><br><span class="line">                       pullRequestList.add(pullRequest);</span><br><span class="line">                       changed = <span class="keyword">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   log.warn(<span class="string">"doRebalance, &#123;&#125;, add new mq failed, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//马上执行拉请求</span></span><br><span class="line">       <span class="keyword">this</span>.dispatchPullRequest(pullRequestList);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> changed;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeDirtyOffset</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从上面看，<strong>processQueueTable</strong>记录的是当前消费者负载的消息队列缓存表，该方法里面的<strong>mqSet</strong>记录的的是当前消费者经过负载分配后的消息队列集合。如果<strong>processQueueTable</strong>中的消息队列在<strong>mqSet</strong>中不存在，说明该消息队列已经被分配给其他消费者，所以需要暂停该消息队列消息的消费，通过** pq.setDropped(true);<strong>该语句即可。<br>然后通过</strong>removeUnnecessaryMessageQueue**方法判断是否该mq从缓存中移除。</p><p>之后，开始遍历本次负载分配给该消费者的消息队列结合mqSet。如果processQueueTable中没有包含该消息队列，表示这是本次新增加的消息队列。<br>首先从内存中移除该消息队列的消息进度，然后调用<strong>computePullFromWhere</strong>从磁盘中读取该消息队列的消费进度，创建一个PullRequest对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">computePullFromWhere</span><span class="params">(MessageQueue mq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> ConsumeFromWhere consumeFromWhere = <span class="keyword">this</span>.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeFromWhere();</span><br><span class="line">        <span class="keyword">final</span> OffsetStore offsetStore = <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore();</span><br><span class="line">        <span class="keyword">switch</span> (consumeFromWhere) &#123;</span><br><span class="line">            <span class="keyword">case</span> CONSUME_FROM_LAST_OFFSET_AND_FROM_MIN_WHEN_BOOT_FIRST:</span><br><span class="line">            <span class="keyword">case</span> CONSUME_FROM_MIN_OFFSET:</span><br><span class="line">            <span class="keyword">case</span> CONSUME_FROM_MAX_OFFSET:</span><br><span class="line">            <span class="keyword">case</span> CONSUME_FROM_LAST_OFFSET: &#123;</span><br><span class="line">                <span class="keyword">long</span> lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);</span><br><span class="line">                <span class="keyword">if</span> (lastOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    result = lastOffset;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// First start,no offset</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> == lastOffset) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                        result = <span class="number">0L</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            result = <span class="keyword">this</span>.mQClientFactory.getMQAdminImpl().maxOffset(mq);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">                            result = -<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CONSUME_FROM_FIRST_OFFSET: &#123;</span><br><span class="line">                <span class="keyword">long</span> lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);</span><br><span class="line">                <span class="keyword">if</span> (lastOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    result = lastOffset;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> == lastOffset) &#123;</span><br><span class="line">                    result = <span class="number">0L</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CONSUME_FROM_TIMESTAMP: &#123;</span><br><span class="line">                <span class="keyword">long</span> lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);</span><br><span class="line">                <span class="keyword">if</span> (lastOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    result = lastOffset;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> == lastOffset) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            result = <span class="keyword">this</span>.mQClientFactory.getMQAdminImpl().maxOffset(mq);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">                            result = -<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">long</span> timestamp = UtilAll.parseDate(<span class="keyword">this</span>.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeTimestamp(),</span><br><span class="line">                                UtilAll.YYYYMMDDHHMMSS).getTime();</span><br><span class="line">                            result = <span class="keyword">this</span>.mQClientFactory.getMQAdminImpl().searchOffset(mq, timestamp);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">                            result = -<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面看出，主要有三种计算消息进度的方法，有些大同小异。</p><ul><li><p>CONSUME_FROM_LAST_OFFSET:从队列最新偏移量开始消费<br>首先从磁盘中获取该消息队列的消费进度，如果大于0，说明该消息队列已经被消费过了，下次消费从该位置继续消费。如果等于-1，说明是首次消费，则从该消息队列的最大偏移量开始消费，如果小于-1，则说明该消息进度文件中存储了错误的偏移量，返回-1。</p></li><li><p>CONSUME_FROM_FIRST_OFFSET： 从头开始消费<br>首先从磁盘中获取该消息队列的消费进度，如果大于0，说明该消息队列已经被消费过了，下次消费从该位置继续消费。如果等于-1，说明是首次消费，则返回0，从头开始消费，如果小于-1，则说明该消息进度文件中存储了错误的偏移量，返回-1。</p></li><li><p>CONSUME_FROM_TIMESTAMP: 从消费者启动的时间戳对应的消费进度开始消费</p></li></ul><p>首先从磁盘中获取该消息队列的消费进度，如果大于0，说明该消息队列已经被消费过了，下次消费从该位置继续消费。如果等于-1，尝试去操作消息存储时间戳作为消费者启动的时间戳，如果能找到则返回找到的偏移量，找不到则返回0；如果小于-1，则说明该消息进度文件中存储了错误的偏移量，返回-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.dispatchPullRequest(pullRequestList);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchPullRequest</span><span class="params">(List&lt;PullRequest&gt; pullRequestList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (PullRequest pullRequest : pullRequestList) &#123;</span><br><span class="line">            <span class="comment">//马上执行拉请求</span></span><br><span class="line">            <span class="keyword">this</span>.defaultMQPushConsumerImpl.executePullRequestImmediately(pullRequest);</span><br><span class="line">            log.info(<span class="string">"doRebalance, &#123;&#125;, add a new pull request &#123;&#125;"</span>, consumerGroup, pullRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在该方法的最后，会调用<strong>dispatchPullRequest</strong>方法，将PullRequest加入到PullMessageService中，以唤醒PullMessageService线程，进行消息拉取。</p><p>到这里，消费者负载均衡方面就结束了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先从整体流程上简单梳理一下消息队列负载的过程。&lt;/p&gt;
&lt;p&gt;消息队列负载由Rebalance线程默认每隔20s进行一次消息队列负载，获取主题队列信息mqSet与消费组当前所有消费者cidAll,然后按照某一种负载算法进行队列分配，分配原则为同一个消费者可以分配多个消息消息
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ并发消费</title>
    <link href="https://github.com/spurstong/2019/11/28/RocketMQ%E5%B9%B6%E5%8F%91%E6%B6%88%E8%B4%B9/"/>
    <id>https://github.com/spurstong/2019/11/28/RocketMQ并发消费/</id>
    <published>2019-11-28T11:43:03.299Z</published>
    <updated>2019-12-04T10:10:40.085Z</updated>
    
    <content type="html"><![CDATA[<p>拉取完消息后，将消息存放在ProcessQueue消息处理队列中，然后进行消息消费。</p><p>RocketMQ使用ConsumeMessageServie来实现消息消费，支持顺序消费和并发消费。在这里主要讲一下并发消费的流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeMessageConcurrentlyService</span> <span class="keyword">implements</span> <span class="title">ConsumeMessageService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = ClientLogger.getLog();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultMQPushConsumerImpl defaultMQPushConsumerImpl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultMQPushConsumer defaultMQPushConsumer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageListenerConcurrently messageListener;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; consumeRequestQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor consumeExecutor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String consumerGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduledExecutorService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService cleanExpireMsgExecutors;</span><br></pre></td></tr></table></figure><h1 id="启动位置"><a href="#启动位置" class="headerlink" title="启动位置"></a>启动位置</h1><p>从服务器拉取到消息后回调PullCallBack回调方法后，先将消息放入到ProcessQueue中，然后把消息提交到消息线程池中执行，则会调用ConsumeMessageConcurrentlyService.submitConsumeRequest方法开始消息消费</p><p>msgs: 消息列表<br>processQueue: 消息处理队列<br>messageQueue: 消息所属消费<br>dispatchToconsume: 是否转发到消费线程池，并发消费时忽略该参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitConsumeRequest</span><span class="params">(//</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> List&lt;MessageExt&gt; msgs, //</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ProcessQueue processQueue, //</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> MessageQueue messageQueue, //</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">boolean</span> dispatchToConsume)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> consumeBatchSize = <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line">        <span class="comment">//类似分页，一页consumeBatchSize，如果大于一页就一页一页取。</span></span><br><span class="line">        <span class="keyword">if</span> (msgs.size() &lt;= consumeBatchSize) &#123;</span><br><span class="line">            ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgs, processQueue, messageQueue);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> total = <span class="number">0</span>; total &lt; msgs.size(); ) &#123;</span><br><span class="line">                List&lt;MessageExt&gt; msgThis = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeBatchSize);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumeBatchSize; i++, total++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (total &lt; msgs.size()) &#123;</span><br><span class="line">                        msgThis.add(msgs.get(total));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgThis, processQueue, messageQueue);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (; total &lt; msgs.size(); total++) &#123;</span><br><span class="line">                        msgThis.add(msgs.get(total));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>首先获取系统设置的consumeMessageBatchMaxSize,即一次消息消费任务ConsumeRequest中包含的消息条数，默认为1，msgs默认最多为32，当msgs数量超过consumeMessageMaxSize时，采取分页处理。然后将consumeRequest提交到线程池。consumeRequest的run方法开始执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumeRequest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;MessageExt&gt; msgs;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ProcessQueue processQueue;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> MessageQueue messageQueue;</span><br></pre></td></tr></table></figure><p>下面对run方法进行拆分，分批次进行介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">                log.info(<span class="string">"the message queue not be able to consume, because it's dropped. group=&#123;&#125; &#123;&#125;"</span>, ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>首先判断该processQueue的drop是否为true,如果drop为true,则说明该消息队列已经被分配给消费组里的其他消费者了，则要停止对该消息队列的消费。</p><p>如果有消费钩子函数的话，要执行钩子函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> beginTimestamp = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">            ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.resetRetryTopic(msgs);</span><br><span class="line">                <span class="keyword">if</span> (msgs != <span class="keyword">null</span> &amp;&amp; !msgs.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    MessageAccessor.setConsumeStartTimeStamp(msg, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始调用自己些的消费监听进行消费</span></span><br><span class="line">status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resetRetryTopic</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> String groupTopic = MixAll.getRetryTopic(consumerGroup);</span><br><span class="line">       <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">           String retryTopic = msg.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span><br><span class="line">           <span class="keyword">if</span> (retryTopic != <span class="keyword">null</span> &amp;&amp; groupTopic.equals(msg.getTopic())) &#123;</span><br><span class="line">               msg.setTopic(retryTopic);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过调用<strong>resetRetryTopic</strong>来恢复重试消息主题名。<br>RocketMQ将消息存入到commitlog文件时，如果发现消息的延迟级别delayTimeLevel大于0，会首先将重试主题存入在消息的属性中，然后设置主题名称为SCHEDULE_TOPIC，以便时间到后重新参与消息消费。</p><p>然后执行具体的消息消费，调用应用程序消息监听器的consumeMessage方法,返回消费结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == status) &#123;</span><br><span class="line">               log.warn(<span class="string">"consumeMessage return null, Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;"</span>,</span><br><span class="line">                   ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup,</span><br><span class="line">                   msgs,</span><br><span class="line">                   messageQueue);</span><br><span class="line">               status = ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>返回的结果可能是CONSUME_SUCCESS(消费成功)或RECONSUME_LATER（需要重新消费）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!processQueue.isDropped()) &#123;</span><br><span class="line">                ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.processConsumeResult(status, context, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">"processQueue is dropped without process consume result. messageQueue=&#123;&#125;, msgs=&#123;&#125;"</span>, messageQueue, msgs);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>执行完消费后，需要对该ProcessQueue进行验证，如果drop为true,将不对结果进行处理。否则，调用<strong>processConsumeResult</strong>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ackIndex = context.getAckIndex();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (consumeRequest.getMsgs().isEmpty())</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (status) &#123;</span><br><span class="line">         <span class="keyword">case</span> CONSUME_SUCCESS:</span><br><span class="line">             <span class="keyword">if</span> (ackIndex &gt;= consumeRequest.getMsgs().size()) &#123;</span><br><span class="line">                 ackIndex = consumeRequest.getMsgs().size() - <span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">int</span> ok = ackIndex + <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">int</span> failed = consumeRequest.getMsgs().size() - ok;</span><br><span class="line">             <span class="keyword">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), ok);</span><br><span class="line">             <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), failed);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> RECONSUME_LATER:</span><br><span class="line">             <span class="comment">//需要稍微重试的</span></span><br><span class="line">             ackIndex = -<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(),</span><br><span class="line">                 consumeRequest.getMsgs().size());</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>当消费结果是成功时，计算成功的个数和失败的个数。，更新ackInex。<br>当消费结果是失败时，将ackIndex重置为-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">            <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                    MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                    log.warn(<span class="string">"BROADCASTING, the message consume failed, drop it, &#123;&#125;"</span>, msg.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">                List&lt;MessageExt&gt; msgBackFailed = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeRequest.getMsgs().size());</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                    MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                    <span class="keyword">boolean</span> result = <span class="keyword">this</span>.sendMessageBack(msg, context);</span><br><span class="line">                    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                        msg.setReconsumeTimes(msg.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line">                        msgBackFailed.add(msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!msgBackFailed.isEmpty()) &#123;</span><br><span class="line">                    consumeRequest.getMsgs().removeAll(msgBackFailed);</span><br><span class="line">                    <span class="comment">//请求重试消费</span></span><br><span class="line">                    <span class="keyword">this</span>.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>如果是广播模式，消息不会执行任何操作，只是以警告级别输出到日志文件。</li><li>如果是集群模式，对发送失败的消息执行操作。<br>执行<strong>sendMessageBack</strong>操作。<br>然后更新该消息重新消费的次数，并将要重新消费的消息添加到msgBackFailed集合中。<br>并将需要重新消费的消息从原先的消息集合中移除，然后执行<strong>submitConsumeRequestLater</strong>方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">submitConsumeRequestLater</span><span class="params">(//</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> List&lt;MessageExt&gt; msgs, //</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> ProcessQueue processQueue, //</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> MessageQueue messageQueue//</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.scheduledExecutorService.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.submitConsumeRequest(msgs, processQueue, messageQueue, <span class="keyword">true</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="number">5000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出，它会在5s后重新执行开头介绍的<strong>submitConsumeRequest</strong>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会操作msgTreeMap，如果重试的情况在上面consumeRequest.getMsgs()已经被清空了</span></span><br><span class="line">        <span class="keyword">long</span> offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());</span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从ProcessQueue中移除消费成功的消息集合，返回的偏移量是移除该批消息后最小的偏移量，然后用该偏移量更新消息消费进度，以便在消费者重启后能从上一次的消费进度开始消费，避免消息重复消费。</p><p>下面开始介绍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageBack</span><span class="params">(<span class="keyword">final</span> MessageExt msg, <span class="keyword">final</span> ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> delayLevel = context.getDelayLevelWhenNextConsume();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.defaultMQPushConsumerImpl.sendMessageBack(msg, delayLevel, context.getMessageQueue().getBrokerName());</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           log.error(<span class="string">"sendMessageBack exception, group: "</span> + <span class="keyword">this</span>.consumerGroup + <span class="string">" msg: "</span> + msg.toString(), e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageBack</span><span class="params">(MessageExt msg, <span class="keyword">int</span> delayLevel, <span class="keyword">final</span> String brokerName)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException, MQClientException </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           String brokerAddr = (<span class="keyword">null</span> != brokerName) ? <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(brokerName)</span><br><span class="line">               : RemotingHelper.parseSocketAddressAddr(msg.getStoreHost());</span><br><span class="line">           <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().consumerSendMessageBack(brokerAddr, msg,</span><br><span class="line">               <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), delayLevel, <span class="number">5000</span>, getMaxReconsumeTimes());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           log.error(<span class="string">"sendMessageBack Exception, "</span> + <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), e);</span><br><span class="line"></span><br><span class="line">           Message newMsg = <span class="keyword">new</span> Message(MixAll.getRetryTopic(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());</span><br><span class="line"></span><br><span class="line">           String originMsgId = MessageAccessor.getOriginMessageId(msg);</span><br><span class="line">           MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);</span><br><span class="line"></span><br><span class="line">           newMsg.setFlag(msg.getFlag());</span><br><span class="line">           MessageAccessor.setProperties(newMsg, msg.getProperties());</span><br><span class="line">           MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());</span><br><span class="line">           MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes() + <span class="number">1</span>));</span><br><span class="line">           MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));</span><br><span class="line">           newMsg.setDelayTimeLevel(<span class="number">3</span> + msg.getReconsumeTimes());</span><br><span class="line"></span><br><span class="line">           <span class="keyword">this</span>.mQClientFactory.getDefaultMQProducer().send(newMsg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>MQClientAPIImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerSendMessageBack</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String addr,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> MessageExt msg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String consumerGroup,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">int</span> delayLevel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">int</span> maxConsumeRetryTimes</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">        ConsumerSendMsgBackRequestHeader requestHeader = <span class="keyword">new</span> ConsumerSendMsgBackRequestHeader();</span><br><span class="line">        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONSUMER_SEND_MSG_BACK, requestHeader);</span><br><span class="line"></span><br><span class="line">        requestHeader.setGroup(consumerGroup);</span><br><span class="line">        requestHeader.setOriginTopic(msg.getTopic());</span><br><span class="line">        requestHeader.setOffset(msg.getCommitLogOffset());</span><br><span class="line">        requestHeader.setDelayLevel(delayLevel);</span><br><span class="line">        requestHeader.setOriginMsgId(msg.getMsgId());</span><br><span class="line">        requestHeader.setMaxReconsumeTimes(maxConsumeRetryTimes);</span><br><span class="line"></span><br><span class="line">        RemotingCommand response = <span class="keyword">this</span>.remotingClient.invokeSync(MixAll.brokerVIPChannel(<span class="keyword">this</span>.clientConfig.isVipChannelEnabled(), addr),</span><br><span class="line">            request, timeoutMillis);</span><br><span class="line">        <span class="keyword">assert</span> response != <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (response.getCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> ResponseCode.SUCCESS: &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQBrokerException(response.getCode(), response.getRemark());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ACK消息发送的网络客户端入口：MQClientAPIImpl#consumerSendMessageBack,命令编码：RequestCode.CONSUMER_SEND_MSG_BACK</p><p>客户端以同步方式发送RequestCode.CONSUMER_SEND_MSG_BACK到服务端，服务端中的类SendMessageProcessor#consumerSendMsgBack会接收处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">final</span> ConsumerSendMsgBackRequestHeader requestHeader =</span><br><span class="line">            (ConsumerSendMsgBackRequestHeader) request.decodeCommandCustomHeader(ConsumerSendMsgBackRequestHeader.class);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 消息轨迹：记录消费失败的消息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasConsumeMessageHook() &amp;&amp; !UtilAll.isBlank(requestHeader.getOriginMsgId())) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行hook</span></span><br><span class="line">            ConsumeMessageContext context = <span class="keyword">new</span> ConsumeMessageContext();</span><br><span class="line">            context.setConsumerGroup(requestHeader.getGroup());</span><br><span class="line">            context.setTopic(requestHeader.getOriginTopic());</span><br><span class="line">            context.setCommercialRcvStats(BrokerStatsManager.StatsType.SEND_BACK);</span><br><span class="line">            context.setCommercialRcvTimes(<span class="number">1</span>);</span><br><span class="line">            context.setCommercialOwner(request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.executeConsumeMessageHookAfter(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 确保订阅组存在</span></span><br><span class="line">        SubscriptionGroupConfig subscriptionGroupConfig =</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getGroup());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionGroupConfig) &#123;</span><br><span class="line">            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);</span><br><span class="line">            response.setRemark(<span class="string">"subscription group not exist, "</span> + requestHeader.getGroup() + <span class="string">" "</span></span><br><span class="line">                + FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST));</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 检查Broker权限</span></span><br><span class="line">        <span class="keyword">if</span> (!PermName.isWriteable(<span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerPermission())) &#123;</span><br><span class="line">            response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">            response.setRemark(<span class="string">"the broker["</span> + <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1() + <span class="string">"] sending message is forbidden"</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果重试队列数目为0，则直接丢弃消息</span></span><br><span class="line">        <span class="keyword">if</span> (subscriptionGroupConfig.getRetryQueueNums() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">            response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>获取消费组的订阅配置消息，如果配置消息未空返回配置组消息不存在错误。如果重试队列数量小于1，则直接返回成功，说明该消费组不支持重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String newTopic = MixAll.getRetryTopic(requestHeader.getGroup());</span><br><span class="line"><span class="keyword">int</span> queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % subscriptionGroupConfig.getRetryQueueNums();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是单元化模式，则对 topic 进行设置</span></span><br><span class="line">        <span class="keyword">int</span> topicSysFlag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (requestHeader.isUnitMode()) &#123;</span><br><span class="line">            topicSysFlag = TopicSysFlag.buildSysFlag(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查topic是否存在</span></span><br><span class="line">        TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(<span class="comment">//</span></span><br><span class="line">            newTopic, <span class="comment">//</span></span><br><span class="line">            subscriptionGroupConfig.getRetryQueueNums(), <span class="comment">//</span></span><br><span class="line">            PermName.PERM_WRITE | PermName.PERM_READ, topicSysFlag);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">            response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">            response.setRemark(<span class="string">"topic["</span> + newTopic + <span class="string">"] not exist"</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 检查topic权限</span></span><br><span class="line">        <span class="keyword">if</span> (!PermName.isWriteable(topicConfig.getPerm())) &#123;</span><br><span class="line">            response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">            response.setRemark(String.format(<span class="string">"the topic[%s] sending message is forbidden"</span>, newTopic));</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>当消息需要重新消费时，不会使用原先的消息队列结合，而是重新创建一个重试主题，名称为%RETRY%+消费组名称，并从重试队列中随机选择一个队列，并构建TopicConig主题配置消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询消息，这里如果堆积消息过多，会访问磁盘</span></span><br><span class="line">        <span class="comment">// 另外如果频繁调用，是否会引起gc问题，需要关注 TODO</span></span><br><span class="line">        MessageExt msgExt = <span class="keyword">this</span>.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getOffset());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == msgExt) &#123;</span><br><span class="line">            response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">            response.setRemark(<span class="string">"look message by offset failed, "</span> + requestHeader.getOffset());</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 构造消息</span></span><br><span class="line">        <span class="keyword">final</span> String retryTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == retryTopic) &#123;</span><br><span class="line">            MessageAccessor.putProperty(msgExt, MessageConst.PROPERTY_RETRY_TOPIC, msgExt.getTopic());</span><br><span class="line">        &#125;</span><br><span class="line">        msgExt.setWaitStoreMsgOK(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>根据消息物理偏移量从commitlog文件中获取消息，同时将消息的主题存放到属性中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> delayLevel = requestHeader.getDelayLevel();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();</span><br><span class="line">       <span class="keyword">if</span> (request.getVersion() &gt;= MQVersion.Version.V3_4_9.ordinal()) &#123;</span><br><span class="line">           maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 死信消息处理</span></span><br><span class="line">       <span class="keyword">if</span> (msgExt.getReconsumeTimes() &gt;= maxReconsumeTimes<span class="comment">//</span></span><br><span class="line">           || delayLevel &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           newTopic = MixAll.getDLQTopic(requestHeader.getGroup());</span><br><span class="line">           queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % DLQ_NUMS_PER_GROUP;</span><br><span class="line"></span><br><span class="line">           topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic, <span class="comment">//</span></span><br><span class="line">               DLQ_NUMS_PER_GROUP, <span class="comment">//</span></span><br><span class="line">               PermName.PERM_WRITE, <span class="number">0</span> <span class="comment">// 死信消息不需要同步，不需要较正。</span></span><br><span class="line">           );</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">               response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">               response.setRemark(<span class="string">"topic["</span> + newTopic + <span class="string">"] not exist"</span>);</span><br><span class="line">               <span class="keyword">return</span> response;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>设置消息重试次数，如果消息已重试次数超过maxReconsumeTimes，再次改变newTopic主题为DLQ(%DLQ%)(死信队列)，该主题的权限为只写，说明消息一旦进入了DLQ，该主题的权限为只写，说明消息一旦进入到DLQ队列中，RocketMQ将不负责再次调度进行消费了，需要人工干预。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">        msgInner.setTopic(newTopic);</span><br><span class="line">        msgInner.setBody(msgExt.getBody());</span><br><span class="line">        msgInner.setFlag(msgExt.getFlag());</span><br><span class="line">        MessageAccessor.setProperties(msgInner, msgExt.getProperties());</span><br><span class="line">        msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));</span><br><span class="line">        msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(<span class="keyword">null</span>, msgExt.getTags()));</span><br><span class="line"></span><br><span class="line">        msgInner.setQueueId(queueIdInt);</span><br><span class="line">        msgInner.setSysFlag(msgExt.getSysFlag());</span><br><span class="line">        msgInner.setBornTimestamp(msgExt.getBornTimestamp());</span><br><span class="line">        msgInner.setBornHost(msgExt.getBornHost());</span><br><span class="line">        msgInner.setStoreHost(<span class="keyword">this</span>.getStoreHost());</span><br><span class="line">        msgInner.setReconsumeTimes(msgExt.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 保存源生消息的 msgId</span></span><br><span class="line">        String originMsgId = MessageAccessor.getOriginMessageId(msgExt);</span><br><span class="line">        MessageAccessor.setOriginMessageId(msgInner, UtilAll.isBlank(originMsgId) ? msgExt.getMsgId() : originMsgId);</span><br></pre></td></tr></table></figure><p>根据原先的消息创建一个新的消息对象，重试消息会拥有自己的唯一消息ID并存入到commitlog文件中，并不会去更新原先消息，而是会将原来的主题、消息ID存入消息的属性中，主题名称为重试主题，其他属性与原来消息保持一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PutMessageResult putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br></pre></td></tr></table></figure><p>将消息存放到Commitlog文件中。</p><p>在存入Commitlog文件之前，如果消息的延迟级别delayTimeLevel大于0，替换消息的主题与队列为定时任务主题队列“SCHEDULE_TOPIC_XXXX”,队列ID为延迟级别减1，再次将消息主题、队列存入消息的属性中。</p><p>在Broker端存在一个后台服务线程<strong>ScheduleMessageService</strong>,其中有一个DeliverDelayedMessageTimeTask定时任务线程，它会根据Topic(“SCHEDULE_TOPIC_XXXX”)与QueueId,先查找逻辑消费队列ConsumeQueue,然后根据偏移量，找到ConsumeQueue中的内存映射对象，从commitlog日志中找到消息对象MessageExt,并做一个消息体的转换，由定时延迟队列消息转化Wie重试队列的消息，再次做持久化磁盘，这是才会真正的保存至重试队列中。定时延迟队列只是为了用于暂存的，然后延迟一段时间后再将消息移入到重试队列中。</p><p>RocketMQ会保证消息至少会被消费1次，但是可能会出现消息重复消费问题，需要开发者自己设计解决这一问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;拉取完消息后，将消息存放在ProcessQueue消息处理队列中，然后进行消息消费。&lt;/p&gt;
&lt;p&gt;RocketMQ使用ConsumeMessageServie来实现消息消费，支持顺序消费和并发消费。在这里主要讲一下并发消费的流程。&lt;/p&gt;
&lt;figure class=&quot;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ消息消费之长轮询</title>
    <link href="https://github.com/spurstong/2019/11/26/RocketMQ%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E4%B9%8B%E9%95%BF%E8%BD%AE%E8%AF%A2/"/>
    <id>https://github.com/spurstong/2019/11/26/RocketMQ消息消费之长轮询/</id>
    <published>2019-11-26T14:15:06.159Z</published>
    <updated>2019-11-27T10:24:22.382Z</updated>
    
    <content type="html"><![CDATA[<p>  RocketMQ消费端有两种获取消息的方式，Push方式和Pull方式。但这两种方式都有一定的缺陷，后来采用了一种折中的方法，采用”长轮询“的方式，它既可以拥有Pull的优点，又能达到保证实时性的目的。</p><p>长轮询的思想：<br>服务端接收到新消息请求后，如果队列里没有新消息，并不急于返回，通过一个循环不断查看状态，每次waitForRunning一段时间（默认是5秒），然后再Check。Broker默认最长阻塞时间为15秒，默认情况下当Broker一直没有新消息，第三次Check的时候，等待时间超过最长阻塞时间，就返回空结果。在等待的过程中，Broker收到了新的消息后会直接返回请求结果。<br>“长轮询”的核心是，Broker端hold住客户端过来的请求一小段时间。在这段时间内有新的消息到达，就利用现有的连接立即返回消息给Consumer。</p><p>何时调用？</p><p>当未在Broker中查找到新信息时，状态代码为PULL_NOT_FOUND,会创建拉取任务PullRequest并提交到PullRequestHoldService线程中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ConcurrentMap&lt;String<span class="comment">/* topic@queueId */</span>, ManyPullRequest&gt; pullRequestTable =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;String, ManyPullRequest&gt;(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>该类中有一个重要的参数<code>pullRequestTable</code>,key为“主题@队列号”，value是对应的ManyPullRequest。</p><p>先看一下它的run方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       log.info(<span class="string">"&#123;&#125; service started"</span>, <span class="keyword">this</span>.getServiceName());</span><br><span class="line">       <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//Consumer订阅消息时，Broker是否开启长轮询</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;                <span class="comment">//开启长轮询，每5秒尝试一次</span></span><br><span class="line">                   <span class="keyword">this</span>.waitForRunning(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//没有开启长轮询，默认等待1秒再次尝试                this.waitForRunning(this.brokerController.getBrokerConfig().getShortPollingTimeMills());</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">long</span> beginLockTimestamp = <span class="keyword">this</span>.systemClock.now();</span><br><span class="line">               <span class="keyword">this</span>.checkHoldRequest();</span><br><span class="line">               <span class="keyword">long</span> costTime = <span class="keyword">this</span>.systemClock.now() - beginLockTimestamp;</span><br><span class="line">               <span class="keyword">if</span> (costTime &gt; <span class="number">5</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">                   log.info(<span class="string">"[NOTIFYME] check hold request cost &#123;&#125; ms."</span>, costTime);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">               log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       log.info(<span class="string">"&#123;&#125; service end"</span>, <span class="keyword">this</span>.getServiceName());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出，如果开启了长轮询，每5s尝试一次，利用checkHoldRequest方法来判断是否有新消息的产生。如果未开启长轮询，则默认1s再次尝试。</p><p>然后再阅读一下checkHoldRequest方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkHoldRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String key : <span class="keyword">this</span>.pullRequestTable.keySet()) &#123;</span><br><span class="line">            String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> == kArray.length) &#123;</span><br><span class="line">                String topic = kArray[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> queueId = Integer.parseInt(kArray[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> offset = <span class="keyword">this</span>.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.notifyMessageArriving(topic, queueId, offset);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"check hold request failed. topic=&#123;&#125;, queueId=&#123;&#125;"</span>, topic, queueId, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出，它会遍历pullRequestTable，从key名中可以得到主题名topic和队列名queueId,然后通过topic和queueID获取到该消息队列的最大偏移量，之后调用notifyMessageArriving方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyMessageArriving</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">int</span> queueId, <span class="keyword">final</span> <span class="keyword">long</span> maxOffset, <span class="keyword">final</span> Long tagsCode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">long</span> msgStoreTime, <span class="keyword">byte</span>[] filterBitMap, Map&lt;String, String&gt; properties)</span> </span>&#123;</span><br><span class="line">       String key = <span class="keyword">this</span>.buildKey(topic, queueId);</span><br><span class="line">       ManyPullRequest mpr = <span class="keyword">this</span>.pullRequestTable.get(key);</span><br><span class="line">       <span class="keyword">if</span> (mpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">           List&lt;PullRequest&gt; requestList = mpr.cloneListAndClear();</span><br><span class="line">           <span class="keyword">if</span> (requestList != <span class="keyword">null</span>) &#123;</span><br><span class="line">               List&lt;PullRequest&gt; replayList = <span class="keyword">new</span> ArrayList&lt;PullRequest&gt;();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span> (PullRequest request : requestList) &#123;</span><br><span class="line">                   <span class="keyword">long</span> newestOffset = maxOffset;</span><br><span class="line">                   <span class="keyword">if</span> (newestOffset &lt;= request.getPullFromThisOffset()) &#123;</span><br><span class="line">                       newestOffset = <span class="keyword">this</span>.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (newestOffset &gt; request.getPullFromThisOffset()) &#123;</span><br><span class="line">                       <span class="keyword">boolean</span> match = request.getMessageFilter().isMatchedByConsumeQueue(tagsCode,</span><br><span class="line">                           <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit(tagsCode, msgStoreTime, filterBitMap));</span><br><span class="line">                       <span class="comment">// match by bit map, need eval again when properties is not null.</span></span><br><span class="line">                       <span class="keyword">if</span> (match &amp;&amp; properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           match = request.getMessageFilter().isMatchedByCommitLog(<span class="keyword">null</span>, properties);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               <span class="keyword">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">                                   request.getRequestCommand());</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                               log.error(<span class="string">"execute request when wakeup failed."</span>, e);</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (System.currentTimeMillis() &gt;= (request.getSuspendTimestamp() + request.getTimeoutMillis())) &#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="keyword">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">                               request.getRequestCommand());</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                           log.error(<span class="string">"execute request when wakeup failed."</span>, e);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   replayList.add(request);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!replayList.isEmpty()) &#123;</span><br><span class="line">                   mpr.addPullRequest(replayList);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在<code>notifyMessageArriving</code>方法中，首先会获取到当前该主题、队列中的所有的挂起拉取任务，如果该消息队列的最大偏移量大于待拉取偏移量，说明有新的消息传入。如果消息匹配后，则调用executeRequestWhenWakeup将消息返回给消息拉取客户端，否则等待下一次尝试。<br>如果挂起超时时间超时，则不继续等待将直接返回客户消息未找到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  RocketMQ消费端有两种获取消息的方式，Push方式和Pull方式。但这两种方式都有一定的缺陷，后来采用了一种折中的方法，采用”长轮询“的方式，它既可以拥有Pull的优点，又能达到保证实时性的目的。&lt;/p&gt;
&lt;p&gt;长轮询的思想：&lt;br&gt;服务端接收到新消息请求后，如果
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ阅读笔记之消息消费的消息拉取</title>
    <link href="https://github.com/spurstong/2019/11/17/RocketMQ%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/"/>
    <id>https://github.com/spurstong/2019/11/17/RocketMQ阅读笔记之消息消费/</id>
    <published>2019-11-17T11:03:07.977Z</published>
    <updated>2019-11-25T15:21:08.194Z</updated>
    
    <content type="html"><![CDATA[<p>消息消费，简而言之就是消费者从消息队列里读取数据。消费者有两种消费方式：</p><ol><li><p><strong>Push方式</strong>。消息服务器接收到信息后，主动把消息推送给消费者，实时性高。但是这样加大了消息服务器的工作压力，会影响其性能。除此之外，不同消费者的处理信息的能力不同，可能无法及时的消费消息，造成 <em>慢消费</em> 问题。相关类是<code>DefaultMQPushConsumer</code>。</p></li><li><p><strong>Pull方式</strong>。消费者主动向消息服务器拉取消息，主动权在消费者这里。主要的问题是循环拉取消息的间隔不好设定，设置的间隔时间太久会增加消息的延迟；设置的事件间隔太短，如果消费服务器里没有可用的消息，那么会造成很多无用的请求开销，影响其性能。相关类是<code>DefaultMQPullConsumer</code>。</p></li></ol><p>消息消费以组的模式开展，一个消费组里可以包含多个消费者，每一个消费组可以订阅多个主题，消费组之间有<em>集群模式</em>和<em>广播模式</em>两种消费模式。</p><ul><li>集群模式:<br>同一个ConsumerGroup里的每个Consumer只消费所订阅消息的一部分内容，同一个ConsumerGroup里的所有的Consumer消费的内容合起来才是订阅的Topic内容的整体，从而达到负载均衡的目的。</li><li>广播模式<br>同一个ConsumerGroup里的每个Consumer都能消费到所订阅Topic的全部信息，也就是一个消息会被多次分发，被多个Consumer消费。</li></ul><p>首先先将一下DefaultMQPushConsumer的相关操作。</p><h2 id="DefaultMQPushConsumer的启动"><a href="#DefaultMQPushConsumer的启动" class="headerlink" title="DefaultMQPushConsumer的启动"></a>DefaultMQPushConsumer的启动</h2><p>启动方法是在DefaultMQPushConsumerImpl.start()方法。</p><p>首先会根据服务状态选择策略。定义的状态如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ServiceState &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service just created,not start</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CREATE_JUST,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service Running</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNING,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service shutdown</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SHUTDOWN_ALREADY,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service Start failure</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    START_FAILED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br></pre></td></tr></table></figure><p>如果是<em>RUNNING<em>、</em>START_FAILED</em>,则跳过该环节，直接进行下一环节。如果是<em>SULTdOWN_ALREDAY</em>，则抛出异常。如果是<em>CREATE_JUST</em>，则需要进入执行该环节的代码。<br>进入里面的区域时，先预设serviceState的值为START_FAILE，在执行一段操作后，如果注册消费者没有成功，则修改serviceState为CREATE_JUST，并抛出异常；如果顺利执行则修改serviceState为RUNNING。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证配置</span></span><br><span class="line"><span class="keyword">this</span>.checkConfig();</span><br><span class="line"><span class="keyword">this</span>.copySubscription();</span><br></pre></td></tr></table></figure><p>订阅主题订阅消息SubscriptionData,并放入到RebalanceImpl的订阅消息中。订阅关系来源主要有两个。</p><ul><li>defaultMQPushConsumer.getSubscription()</li><li>订阅重试主题消息。RocketMQ消息重试是以消费组为单位，而不是主题，消息重试主题为%RETRY%+消费组名。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">copySubscription</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Map&lt;String, String&gt; sub = <span class="keyword">this</span>.defaultMQPushConsumer.getSubscription();</span><br><span class="line">           <span class="keyword">if</span> (sub != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;String, String&gt; entry : sub.entrySet()) &#123;</span><br><span class="line">                   <span class="keyword">final</span> String topic = entry.getKey();</span><br><span class="line">                   <span class="keyword">final</span> String subString = entry.getValue();</span><br><span class="line">                   SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="comment">//</span></span><br><span class="line">                       topic, subString);</span><br><span class="line">                   <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.messageListenerInner) &#123;</span><br><span class="line">               <span class="keyword">this</span>.messageListenerInner = <span class="keyword">this</span>.defaultMQPushConsumer.getMessageListener();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">               <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">                   <span class="keyword">final</span> String retryTopic = MixAll.getRetryTopic(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                   SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="comment">//</span></span><br><span class="line">                       retryTopic, SubscriptionData.SUB_ALL);</span><br><span class="line">                   <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().put(retryTopic, subscriptionData);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"subscription exception"</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>如果当前是集群消费模式，修改实例名为Pid。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;</span><br><span class="line"><span class="keyword">this</span>.defaultMQPushConsumer.changeInstanceNameToPID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化MQClientInstance、ReblanceImple(消息重新负载实现类)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQPushConsumer, <span class="keyword">this</span>.rpcHook);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 设置负载均衡器</span></span><br><span class="line">               <span class="keyword">this</span>.rebalanceImpl.setConsumerGroup(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">               <span class="comment">//设置消费集群模式</span></span><br><span class="line">               <span class="keyword">this</span>.rebalanceImpl.setMessageModel(<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel());</span><br><span class="line">               <span class="comment">//Queue allocation algorithm specifying how message queues are allocated to each consumer clients.</span></span><br><span class="line">               <span class="keyword">this</span>.rebalanceImpl.setAllocateMessageQueueStrategy(<span class="keyword">this</span>.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span><br><span class="line">   </span><br><span class="line">               <span class="keyword">this</span>.rebalanceImpl.setmQClientFactory(<span class="keyword">this</span>.mQClientFactory);</span><br><span class="line">   </span><br><span class="line">               <span class="keyword">this</span>.pullAPIWrapper = <span class="keyword">new</span> PullAPIWrapper(</span><br><span class="line">                   mQClientFactory,</span><br><span class="line">                   <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span><br><span class="line">               <span class="keyword">this</span>.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span><br></pre></td></tr></table></figure><p>处理offset存储方式。<br>如果消息消费是集群模式，那么消息进度保存在Broker上；如果是广播模式，那么消息消费进度存储在消费端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.offsetStore = <span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore();</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">                      <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">                          <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> LocalFileOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">                          <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> RemoteBrokerOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">default</span>:</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">this</span>.offsetStore.load();</span><br></pre></td></tr></table></figure><p>根据MessageListener的具体实现方式选择具体的消息拉取线程实现<br>可以选择顺序消息消费服务或者并行消息消费服务<br>最后执行ConsumerMessageService主要负责消费消息，内部维护一个线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerOrderly) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.consumeOrderly = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                        <span class="keyword">new</span> ConsumeMessageOrderlyService(<span class="keyword">this</span>, (MessageListenerOrderly) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerConcurrently) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.consumeOrderly = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                        <span class="keyword">new</span> ConsumeMessageConcurrentlyService(<span class="keyword">this</span>, (MessageListenerConcurrently) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService.start();</span><br></pre></td></tr></table></figure><p>向MQClientInstance注册消费者，并启动MQClientInstance,在一个JVM中的所有消费者、生产者持有同一个MQClientInstance,MQClientInstance只会启动一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> registerOK = mQClientFactory.registerConsumer(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                    <span class="keyword">this</span>.consumeMessageService.shutdown();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The consumer group["</span> + <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()</span><br><span class="line">                        + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                        <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mQClientFactory.start();</span><br></pre></td></tr></table></figure><p>订阅关系改变，更新NameServer的订阅关系表。<br>检查客户端状态<br>发送心跳条<br>唤醒执行消费者负载均衡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();</span><br><span class="line"><span class="keyword">this</span>.mQClientFactory.checkClientInBroker();</span><br><span class="line">       <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">       <span class="comment">//马上rebalance</span></span><br><span class="line"><span class="keyword">this</span>.mQClientFactory.rebalanceImmediately();</span><br></pre></td></tr></table></figure><p>在上面提到了offset的存储问题。现在先讲一下什么是offset和存储规则。</p><h1 id="消息消费进度记录"><a href="#消息消费进度记录" class="headerlink" title="消息消费进度记录"></a>消息消费进度记录</h1><p>消息消费者在消费一批消息后，需要记录该批消息已经消费完毕，否则当消费者重新启动时又得从消息消费队列的开始消费，这样显然会产生问题。一次消息消费后会从ProcessQueue处理队列中移除该批消息，返回ProcessQueue最小偏移量，并存入到消息进度表中。该消息进度表的存储位置和机制是一个重要的问题。</p><p>由上面可知,有两种消费模式，<em>广播模式</em>  和 <em>集群模式</em></p><p>广播模式： 同一消费组的所有消费者都会消费该主题下的所有消息。即同一个消息会被所有消费者消费，所以每个消费者应该各自独立有一个记录消费进度的文件。<br>广播模式下消息进度存储在消费者本地，主要类是LocalFileOffsetStore.</p><p>集群模式： 同一消费者的所有消费者共同消费该主题下的所有消息，一个消息只能被一个消费者所消费，即每个消费者消费的是该消费主题下的部分消息，所以消息消费进度记录被所有消费者所共享。<br>集群模式消息进度存储文件存放在消息服务端Broker,主要类中RemoteBrokerOffsetStore。</p><h1 id="几个重要有关消息消费的类"><a href="#几个重要有关消息消费的类" class="headerlink" title="几个重要有关消息消费的类"></a>几个重要有关消息消费的类</h1><p>每一个PullRequest代表一个消费的分组单元<br>PullRequest会记录一个topic记录对应的consumerGroup的拉取进度。</p><h2 id="PullRequest"><a href="#PullRequest" class="headerlink" title="PullRequest"></a>PullRequest</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PullRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String consumerGroup;</span><br><span class="line">    # 待拉取消息队列</span><br><span class="line">    <span class="keyword">private</span> MessageQueue messageQueue;</span><br><span class="line">    # 消息处理队列，从Broker拉取到的消费先存入到ProcessQueue,然后提交到消费者消费线程池消费</span><br><span class="line">    <span class="keyword">private</span> ProcessQueue processQueue;</span><br><span class="line">    # 待拉取的MessageQueue偏移量</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line">    # 是否被锁定</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lockedFirst = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>ProcessQueue是MessageQueue在消费端的重现、快照。</p><h2 id="ProcessQueue"><a href="#ProcessQueue" class="headerlink" title="ProcessQueue"></a>ProcessQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> REBALANCE_LOCK_MAX_LIVE_TIME =</span><br><span class="line">        Long.parseLong(System.getProperty(<span class="string">"rocketmq.client.rebalance.lockMaxLiveTime"</span>, <span class="string">"30000"</span>));</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> REBALANCE_LOCK_INTERVAL = Long.parseLong(System.getProperty(<span class="string">"rocketmq.client.rebalance.lockInterval"</span>, <span class="string">"20000"</span>));</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> PULL_MAX_IDLE_TIME = Long.parseLong(System.getProperty(<span class="string">"rocketmq.client.pull.pullMaxIdleTime"</span>, <span class="string">"120000"</span>));</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = ClientLogger.getLog();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lockTreeMap = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    # 消息存储容器，键为消息在ConsumeQueue中的偏移量，value为消息实体</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMap = <span class="keyword">new</span> TreeMap&lt;Long, MessageExt&gt;();</span><br><span class="line">    # ProcessQueue中的消息总数</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong msgCount = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lockConsume = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    # 消息临时存储容器，消息消费线程从ProcessQueue的msgTreeMap中取出消息前，先将消息临时存储在msgTreeMapTemp中。</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMapTemp = <span class="keyword">new</span> TreeMap&lt;Long, MessageExt&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong tryUnlockTimes = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> queueOffsetMax = <span class="number">0L</span>;</span><br><span class="line">    # 当前ProcessQueue是否被丢弃</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> dropped = <span class="keyword">false</span>;</span><br><span class="line">    # 上一次开始消息拉取时间戳</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastPullTimestamp = System.currentTimeMillis();</span><br><span class="line">    # 上一次消息消费时间戳</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastConsumeTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastLockTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> consuming = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> msgAccCnt = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="DefaultMQPushConsumer-客户端消费者实现"><a href="#DefaultMQPushConsumer-客户端消费者实现" class="headerlink" title="DefaultMQPushConsumer 客户端消费者实现"></a>DefaultMQPushConsumer 客户端消费者实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMQPushConsumer</span> <span class="keyword">extends</span> <span class="title">ClientConfig</span> <span class="keyword">implements</span> <span class="title">MQPushConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Internal implementation. Most of the functions herein are delegated to it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">transient</span> DefaultMQPushConsumerImpl defaultMQPushConsumerImpl;</span><br><span class="line"></span><br><span class="line">    # 消费者组名</span><br><span class="line">    <span class="keyword">private</span> String consumerGroup;</span><br><span class="line"></span><br><span class="line">    # 消费模式</span><br><span class="line">    <span class="keyword">private</span> MessageModel messageModel = MessageModel.CLUSTERING;</span><br><span class="line"></span><br><span class="line">   # 消费者从哪个位置消费</span><br><span class="line">   # CONSUME_FROM_LAST_OFFSET: 第一次启动从队列最后位置消费，后续再接着上次消费的进度开始消费</span><br><span class="line">   # CONSUME_FROM_First_OFFSET: 第一次启动从队列开始位置消费，后续再接着上次消费的进度开始消费</span><br><span class="line">   # CONSUME_FROM_TimeStamp: 第一次启动从指定时间点位置消费，后续再接着上次消费的进度开始消费</span><br><span class="line">   # 这里的第一次启动指的是该消费者之前没有消费过该消息队列，如果消费过，则会在Broker端记录消费位置，如果该消费者挂了再启动时，会自动从上次消费的地方开始。</span><br><span class="line">    <span class="keyword">private</span> ConsumeFromWhere consumeFromWhere = ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> String consumeTimestamp = UtilAll.timeMillisToHumanString3(System.currentTimeMillis() - (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">30</span>));</span><br><span class="line">    # 消费分配策略，默认消息平均分配给所有客户端</span><br><span class="line">    <span class="keyword">private</span> AllocateMessageQueueStrategy allocateMessageQueueStrategy;</span><br><span class="line">    # topic对应的订阅tag</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String <span class="comment">/* topic */</span>, String <span class="comment">/* sub expression */</span>&gt; subscription = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    # 客户端消费消息的实现类</span><br><span class="line">    <span class="keyword">private</span> MessageListener messageListener;</span><br><span class="line">    # 存储实现，本地存储或者Broker存储</span><br><span class="line">    <span class="keyword">private</span> OffsetStore offsetStore;</span><br><span class="line">    # Minimum consumer thread number</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> consumeThreadMin = <span class="number">20</span>;</span><br><span class="line">    # Max consumer thread number</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> consumeThreadMax = <span class="number">64</span>;</span><br><span class="line">    # Threshold for dynamic adjustment of the number of thread pool</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> adjustThreadPoolNumsThreshold = <span class="number">100000</span>;</span><br><span class="line">    # 单队列并行消费的最大跨度，用于流量控制</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> consumeConcurrentlyMaxSpan = <span class="number">2000</span>;</span><br><span class="line">    # 一个queue最大消费的消息个数，用于流量控制</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pullThresholdForQueue = <span class="number">1000</span>;</span><br><span class="line">    # 消息拉取时间间隔，默认为0，</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> pullInterval = <span class="number">0</span>;</span><br><span class="line">    # 并发消费时，一次消费消息的数量</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> consumeMessageBatchMaxSize = <span class="number">1</span>;</span><br><span class="line">    # 消息拉取一次的数量</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pullBatchSize = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">     # Whether update subscription relationship when every pull</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> postSubscriptionWhenPull = <span class="keyword">false</span>;</span><br><span class="line">    # Whether the unit of subscription group</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> unitMode = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Max re-consume times. -1 means 16 times.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If messages are re-consumed more than &#123;<span class="doctag">@link</span> #maxReconsumeTimes&#125; before success, it's be directed to a deletion</span></span><br><span class="line"><span class="comment">     * queue waiting.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxReconsumeTimes = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Suspending pulling time for cases requiring slow pulling like flow-control scenario.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> suspendCurrentQueueTimeMillis = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    # Maximum amount of time in minutes a message may block the consuming thread.</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> consumeTimeout = <span class="number">15</span>;</span><br></pre></td></tr></table></figure><h2 id="DefaultMQPushConsumerImpl-消费者具体实现类"><a href="#DefaultMQPushConsumerImpl-消费者具体实现类" class="headerlink" title="DefaultMQPushConsumerImpl 消费者具体实现类"></a>DefaultMQPushConsumerImpl 消费者具体实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMQPushConsumerImpl</span> <span class="keyword">implements</span> <span class="title">MQConsumerInner</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Delay some time when exception occur</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION = <span class="number">3000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Flow control interval</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL = <span class="number">50</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Delay some time when suspend pull service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PULL_TIME_DELAY_MILLS_WHEN_SUSPEND = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BROKER_SUSPEND_MAX_TIME_MILLIS = <span class="number">1000</span> * <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND = <span class="number">1000</span> * <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = ClientLogger.getLog();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultMQPushConsumer defaultMQPushConsumer;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//负载均衡实现类 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RebalanceImpl rebalanceImpl = <span class="keyword">new</span> RebalancePushImpl(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;FilterMessageHook&gt; filterMessageHookList = <span class="keyword">new</span> ArrayList&lt;FilterMessageHook&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> consumerStartTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ConsumeMessageHook&gt; consumeMessageHookList = <span class="keyword">new</span> ArrayList&lt;ConsumeMessageHook&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RPCHook rpcHook;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServiceState serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">    <span class="keyword">private</span> MQClientInstance mQClientFactory;</span><br><span class="line">    <span class="keyword">private</span> PullAPIWrapper pullAPIWrapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> pause = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> consumeOrderly = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> MessageListener messageListenerInner;</span><br><span class="line">    <span class="keyword">private</span> OffsetStore offsetStore;</span><br><span class="line">    <span class="keyword">private</span> ConsumeMessageService consumeMessageService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> flowControlTimes1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> flowControlTimes2 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="消息拉取基本流程"><a href="#消息拉取基本流程" class="headerlink" title="消息拉取基本流程"></a>消息拉取基本流程</h1><p>具体的实现类是DefaultMQPushConsumerImpl<br>消息拉取主要有3个主要步骤：</p><ul><li>消费拉取客户端消息拉取请求封装</li><li>消息服务器查找并返回消息</li><li>消息拉取客户端处理返回的消息</li></ul><ol><li><p>客户端封装消息拉取请求</p><p>1.1 从PullRequest中获取ProcessQueue,如果处理队列当前状态未被丢弃，则更新ProcessQueue的lastPullTimestamp为当前时间戳；如果当前消费者被挂起，则将拉取任务延迟1s再次放入到PullMessageService的拉取任务中，结束本次消息拉取。</p><p>1.2 进行消息拉取流量控制</p><p>PushConsumer有个线程池，消息处理逻辑在各个线程里同时执行，在PushConsumer运行的时候，每个Message Queue都有一个对用的ProcessQueue对象，保存了这个Message Queue 消息处理状态的快照。</p><p>ProcessQueue对象里主要内容是一个TreeMap和一个读写锁。TreeMap里以Message Queue的Offset作为Key，以消息内容的引用为Value,保存了所有从MessageQueue获取的，但是还未被处理的信息，读写锁控制着多个线程对TreeMap对象的并发处理。</p><p>流量控制策略：</p><ul><li>消息处理总数，如果ProcessQueue当前处理的消息超过了pullThresholdForQueue=1000将触发流量控制，放弃本次拉取任务，并且该队列的下一次拉取任务将在50毫秒后才加入到拉取任务队列中。</li><li>ProcessQueue中队列最大偏移量与最小偏移量的间距，不能超过consumeConcurrencyMaxSpan,否则触发流量控制。</li></ul><p>1.3 拉取该主题订阅信息，如果为空，结束本次消息拉取，关于该队列的下一次拉取任务延迟3秒。<br>1.4 构建消息拉取系统标记。<br>1.5 调用PullAPIWrapper.pullKernelImpl方法后与服务端交互。<br>1.6 根据brokerName、BrokerId从MQClientInstance中获取Broker地址，在整个RocketMQ Broker的部署结构中，相同名称的Broker构成主从结构，其BrokerId会不一样，在每次拉取消息后，会给出一个建议，下次拉取从主节点还是从节点拉取。</p></li></ol><p>然后是消息服务端Broker组装消息。会根据处理的结果返回不同的状态编码。<br>主要有下面几种状态编码。</p><ul><li>SUCCESS : 成功</li><li>PULL_RETRY_IMMEDIATElY : 立即重试</li><li>PULL_OFFSET_MOVED : 偏移量移动</li><li>PULL_NOT_FOUND : 未找到消息</li></ul><ol start="3"><li>消息拉取客户端处理消息。</li></ol><p>先分析状态编码为SUCCESS的后续处理步骤。</p><ul><li>更新PullRequest的下一次拉取偏移量，如果msgFoundList为空，则立即将PullRequest放入到PullMessageService的pullRequestQueue,以便PullMessageService能及时唤醒并再次执行消息拉取。</li><li>将拉取到的消息存放到ProcessQueue,然后将拉取到的消息提交到ConsumeMessageService中供消费者消费。</li><li>将消费提交给消费者线程之后PullCallBack将立即返回，可以说本次消息拉取顺利完成，然后根据pullInterval参数，如果pullInterval &gt; 0,则等待pullInterval毫秒后将PullRequest对象放入到PullMessageService的pullRequestQueue中，该消息队列的下次拉取即将被激活，达到持续消息拉取，实现准实时拉取消息的效果。</li></ul><p>如果拉取结果为偏移量非法，首先将ProcessQueue设置dropped为ture,表示丢弃该消息队列，意味着ProcessQueue中拉取的消息将停止消费，然后根据服务端下一次校对的偏移量尝试更新消息消费进度，然后尝试持久化消息消费进度，并将该消息队列从RebalanceImpl的处理队列中移除，意味着暂停该消息队列的消息拉取，等待下一次消息队列重新加载。</p><p>这篇对消息拉取的笔记就暂时写到这里，下一篇阿静详细介绍关于消息拉取失败后的长轮询方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;消息消费，简而言之就是消费者从消息队列里读取数据。消费者有两种消费方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Push方式&lt;/strong&gt;。消息服务器接收到信息后，主动把消息推送给消费者，实时性高。但是这样加大了消息服务器的工作压力，会影响其性能。除此之外，不
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ阅读笔记之消息存储</title>
    <link href="https://github.com/spurstong/2019/11/09/RocketMQ%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/"/>
    <id>https://github.com/spurstong/2019/11/09/RocketMQ阅读笔记之消息存储/</id>
    <published>2019-11-09T14:02:34.819Z</published>
    <updated>2019-11-14T13:40:11.949Z</updated>
    
    <content type="html"><![CDATA[<p>消息存储部分是RocketMQ的重要组成部分，良好的存储机制会有效降低延迟，提高整体效率。RocketMQ利用到了文件系统，将消息存放在磁盘中实现持久化。</p><p>首先先介绍消息存储的整体结构，先大体了解其处理机制。</p><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/RocketMQ%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/1.png" alt="RocketMQ消息存储整体架构"></p><p>从上图中可以看出有几个重要的文件。</p><ul><li><p>CommitLog: 消息存储文件，所有消息主题的消息都存储在CommitLog文件夹中，它以物理文件的方式存放，每台Broker上有一个CommitLog文件夹，里面有多个文件，单个文件的大小默认为1G,文件名表示的是该文件中的第1条信息的物理偏移量。每台Broker上的CommitLog被本机器所有ConsumeQueue共享。在CommitLog中，一个消息的存储长度是不固定的。每条消息的前4个字节存储该条消息的总长度，其余的信息就是在该长度下的消息内容。</p></li><li><p>ConsumerQueue: 消息队列文件，在ConsumerQueue文件夹中存在以topic(主题名)为文件夹名的多个文件夹。然后在每个文件夹里根据消息队列数创建了多个文件夹，文件夹名为0，1，2，..。然后在最里面的文件记录的是某主题下的某消息队列下的文件信息，但是它并没有存储消息的具体信息，它起到了类似于索引的功能，更够使消费者可以快速的在CommitLog文件中查找到所需的信息。</p><p>单个ConsumerQueue文件中默认包含30万个条目，单个文件的长度为30W * 20字节，即每条信息占20字节。前8个字节为commitlog offset,为该条消息在commitlog的实际偏移量，中间4个字节为size,即该条消息的长度，最后8字节为tag hashcode,即存储该条消息的tag的哈希值，用于订阅时消息过滤。</p></li><li><p>IndexFile：索引文件。如果消息包含key值的话，会使用IndexFile来存储消息索引。具体的逻辑结构在后面讲解到。</p></li></ul><h1 id="内存映射技术"><a href="#内存映射技术" class="headerlink" title="内存映射技术"></a>内存映射技术</h1><p>  在Linux操作系统中分为“用户态”和“内核态”，在进行IO操作时，会涉及到这两种形态的切换及read()和write()操作。在执行read()操作时，是系统调用的，期间进行了数据拷贝，它首先将文件内容从硬盘拷贝到内核空间的一个缓冲区，然后再将这些数据拷贝到用户空间，在这个过程中实际上完成了两次的数据拷贝。这样会对访问速度有所影响。</p><p>  针对这种情况，提出了mmap内存映射技术，mmap内存映射和普通标准IO操作的本质区别是它并不需要将文件中的数据先拷贝到OS的内核IO缓冲区，而是可以直接将用户进程私有地址空间的一块区域与文件对象建立映射关系，就好像可以直接从内存中完成对文件读写操作一样。只有当缺页中断发生时，直接将磁盘拷贝至用户态的进程空间内，只进行了一次数据拷贝。</p><p>  <img src="https://raw.githubusercontent.com/spurstong/img_data/master/RocketMQ%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/3.png" alt="标准IO与NIO的区别"></p><h1 id="高可用机制"><a href="#高可用机制" class="headerlink" title="高可用机制"></a>高可用机制</h1><p>  RocketMQ分布式集群是通过Master和Slave的配合达到高可用性的，在Broker的配置文件中，参数brokerId的值为0表示这个Broker是Master,大于0表示该Broker是Slave。Master角色的Broker支持读和写，Slave角色的Broker仅支持读，也就是说,Producer只能和Master角色的Broker连接写入信息；Consumer可以连接Master角色和Slave角色的Broker来读取消息。</p><p>  对于Consumer,当Master不可用或者繁忙的时候，Consumer会自动切换到Slave进行读取消息，实现了消费端的高可用性。</p><p>  对于Producer,在创建topic的时候，把Topic的多个Message Queue创建在多个Broker组上（相同Broker名称，不同BrokerId的机器组成一个Broker组），这样当一个Broker组的Master不可用候，其他组的Master依然可用，Producer仍然可以发送消息。</p><h1 id="内存映射相关类"><a href="#内存映射相关类" class="headerlink" title="内存映射相关类"></a>内存映射相关类</h1><p>  由上面可知，RocketMQ通过使用内存映射文件来提高IO访问性能，现在介绍几个相关的类。</p><p>  <em>MappedFile</em></p><p>  它是CommitLog里面具体文件的映射。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedFile</span> <span class="keyword">extends</span> <span class="title">ReferenceResource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OS_PAGE_SIZE = <span class="number">1024</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);</span><br><span class="line">    <span class="comment">// 当前JVM中映射的虚拟内存总大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong TOTAL_MAPPED_VIRTUAL_MEMORY = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 当前JVM中mmap句柄数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger TOTAL_MAPPED_FILES = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 当前写到什么位置</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> AtomicInteger wrotePosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//ADD BY ChenYang</span></span><br><span class="line">    <span class="comment">// Flush到什么位置</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> AtomicInteger committedPosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger flushedPosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 映射的文件大小，定长</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> fileSize;</span><br><span class="line">    <span class="comment">// 映射的FileChannel对象</span></span><br><span class="line">    <span class="keyword">protected</span> FileChannel fileChannel;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Message will put to here first, and then reput to FileChannel if writeBuffer is not null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> ByteBuffer writeBuffer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> TransientStorePool transientStorePool = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 映射的文件名</span></span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line">    <span class="comment">// 映射的起始偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> fileFromOffset;</span><br><span class="line">    <span class="comment">// 映射的文件</span></span><br><span class="line">    <span class="keyword">private</span> File file;</span><br><span class="line">    <span class="comment">// 映射的内存对象，position永远不变</span></span><br><span class="line">    <span class="keyword">private</span> MappedByteBuffer mappedByteBuffer;</span><br><span class="line">    <span class="comment">// 最后一条消息存储时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> storeTimestamp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> firstCreateInQueue = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>  <em>MappedFileQueue</em></p><p>  MappedFileQueue是MappedFile的管理容器，MappedFileQueue是对存储目录的封装。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedFileQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG_ERROR = LoggerFactory.getLogger(LoggerName.STORE_ERROR_LOGGER_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次触发删除文件，最多删除多少个文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELETE_FILES_BATCH_MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 文件存储位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String storePath;</span><br><span class="line">    <span class="comment">// 每个文件的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mappedFileSize;</span><br><span class="line">    <span class="comment">// 各个文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;MappedFile&gt; mappedFiles = <span class="keyword">new</span> CopyOnWriteArrayList&lt;MappedFile&gt;();</span><br><span class="line">    <span class="comment">// 预分配MapedFile对象服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AllocateMappedFileService allocateMappedFileService;</span><br><span class="line">    <span class="comment">// 当前刷盘指针，表示该指针之前的所有数据全部持久化到磁盘</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> flushedWhere = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前数据提交指针，内存中ByteBuffer当前的写指针，该值大于等于flushedWhere.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> committedWhere = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 最后一条消息存储时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> storeTimestamp = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>  根据消息偏移量offset查找MappedFile时，不会直接使用offset/mappedFileSize，因为消息文件不是永久存在的，RocketMQ会定时删除存储文件，第一个文件不一定是000000000000000000，可能最初的起始文件已经被删除，那么利用上述方法是会产生错误的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MappedFile <span class="title">findMappedFileByOffset</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset, <span class="keyword">final</span> <span class="keyword">boolean</span> returnFirstOnNotFound)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          # 获取第一个MappedFile</span><br><span class="line">          MappedFile mappedFile = <span class="keyword">this</span>.getFirstMappedFile();</span><br><span class="line">          <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">int</span> index = (<span class="keyword">int</span>) ((offset / <span class="keyword">this</span>.mappedFileSize) - (mappedFile.getFileFromOffset() / <span class="keyword">this</span>.mappedFileSize));</span><br><span class="line">              <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.mappedFiles.size()) &#123;</span><br><span class="line">                  LOG_ERROR.warn(<span class="string">"Offset for &#123;&#125; not matched. Request offset: &#123;&#125;, index: &#123;&#125;, "</span> +</span><br><span class="line">                          <span class="string">"mappedFileSize: &#123;&#125;, mappedFiles count: &#123;&#125;"</span>,</span><br><span class="line">                      mappedFile,</span><br><span class="line">                      offset,</span><br><span class="line">                      index,</span><br><span class="line">                      <span class="keyword">this</span>.mappedFileSize,</span><br><span class="line">                      <span class="keyword">this</span>.mappedFiles.size());</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">this</span>.mappedFiles.get(index);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (returnFirstOnNotFound) &#123;</span><br><span class="line">                      <span class="keyword">return</span> mappedFile;</span><br><span class="line">                  &#125;</span><br><span class="line">                  LOG_ERROR.warn(<span class="string">"findMappedFileByOffset failure. "</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          log.error(<span class="string">"findMappedFileByOffset Exception"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  其中，重要的一个公式是<em>(int) ((offset / this.mappedFileSize) - (mappedFile.getFileFromOffset() / this.mappedFileSize));</em>    offset / this.mappedFileSize得到的是假设所有文件没有被删除的情况下该偏移量所处的文件，然后mappedFile.getFileFromOffset() / this.mappedFileSize，获取第一个文件的起始偏移量，如果之前有文件删除的话，计算已删除的文件数。这样就可以得到定位到实际的文件。</p><p><em>ConsumeQueue</em></p><p>ConsumeQueue是消息的逻辑队列，类似数据库的索引文件，存储的指向物理存储的地址，每个topic下的每一个Message Queue都有一个对应的ConsumeQueue文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储单元大小 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CQ_STORE_UNIT_SIZE = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG_ERROR = LoggerFactory.getLogger(LoggerName.STORE_ERROR_LOGGER_NAME);</span><br><span class="line">    <span class="comment">// 存储顶层对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultMessageStore defaultMessageStore;</span><br><span class="line">    <span class="comment">// 存储消息索引的队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MappedFileQueue mappedFileQueue;</span><br><span class="line">    <span class="comment">// Topic</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;</span><br><span class="line">    <span class="comment">// queueId</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> queueId;</span><br><span class="line">    <span class="comment">// 写索引时用到的ByteBuffer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer byteBufferIndex;</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String storePath;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mappedFileSize;</span><br><span class="line">    <span class="comment">// 最后一个消息对应的物理Offset</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxPhysicOffset = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 逻辑队列的最小Offset，删除物理文件时，计算出来的最小Offset</span></span><br><span class="line">    <span class="comment">// 实际使用需要除以 StoreUnitSize</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> minLogicOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> ConsumeQueueExt consumeQueueExt = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><em>IndexFile</em></p><p>如果该消息存在key,可以根据key进行查询，这时需要用到IndexFile索引文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> hashSlotSize = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> indexSize = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> invalidIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hashSlotNum;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> indexNum;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MappedFile mappedFile;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileChannel fileChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MappedByteBuffer mappedByteBuffer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IndexHeader indexHeader;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/RocketMQ%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/4.png" alt="RocketMQ索引文件"></p><p>从大的方面来说，分为3个部分，IndexHead,500w个hsah槽和2000w个Index条目。<br>IndexHead头部，包含40个字节，记录该IndexFile的统计信息，其结构如下：</p><ul><li>beginTimestamp: 该索引文件中包含信息的最小存储时间。</li><li>endTimestamp: 该索引文件中包含信息的最大存储时间。</li><li>beginPhyoffset: 该索引文件中包含的消息在commitlog文件中的最小物理偏移量。</li><li>endPhyoffset: 该索引文件中包含的消息在commitlog文件中的最大物理偏移量。</li><li>hashlogCount: hashlot个数。</li><li>indexCount: Index条目列表当前已使用的个数。</li></ul><p>500w个hsah槽<br>每个Hash槽存储的是落在该Hash槽的hashcode最新的Index的索引，每个Hash槽占4个字节。</p><p>2000w个Index<br>每一个Index条目结构如下：</p><ul><li>hashcode: key的hashcode</li><li>phyoffset: 消息对应的物理偏移量</li><li>timedif: 该消息存储时间与第一条消息的时间戳的差值</li><li>preIndexNo: 该条目的前一条记录的Index索引</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putKey</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">long</span> phyOffset, <span class="keyword">final</span> <span class="keyword">long</span> storeTimestamp)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getIndexCount() &lt; <span class="keyword">this</span>.indexNum) &#123;</span><br><span class="line">           # 消息key的hashcode </span><br><span class="line">           <span class="keyword">int</span> keyHash = indexKeyHashMethod(key);</span><br><span class="line">           # 将key的hashcode与hash槽数量取余，得到该hashcode下的hash槽下标</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">int</span> slotPos = keyHash % <span class="keyword">this</span>.hashSlotNum;</span><br><span class="line">           # 该槽的物理地址</span><br><span class="line">           <span class="keyword">int</span> absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize;</span><br><span class="line"></span><br><span class="line">           FileLock fileLock = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// fileLock = this.fileChannel.lock(absSlotPos, hashSlotSize,</span></span><br><span class="line">               <span class="comment">// false);</span></span><br><span class="line">               # 获取该hashcode的存储的Index索引，</span><br><span class="line">               <span class="keyword">int</span> slotValue = <span class="keyword">this</span>.mappedByteBuffer.getInt(absSlotPos);</span><br><span class="line">               <span class="keyword">if</span> (slotValue &lt;= invalidIndex || slotValue &gt; <span class="keyword">this</span>.indexHeader.getIndexCount()) &#123;</span><br><span class="line">                   slotValue = invalidIndex;</span><br><span class="line">               &#125;</span><br><span class="line">              # 计算待存储消息的时间戳与第一条消息时间戳的差值，并转换为秒</span><br><span class="line">               <span class="keyword">long</span> timeDiff = storeTimestamp - <span class="keyword">this</span>.indexHeader.getBeginTimestamp();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 时间差存储单位由毫秒改为秒</span></span><br><span class="line">               timeDiff = timeDiff / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 25000天后溢出</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getBeginTimestamp() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   timeDiff = <span class="number">0</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeDiff &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                   timeDiff = Integer.MAX_VALUE;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   timeDiff = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">int</span> absIndexPos =</span><br><span class="line">                   IndexHeader.INDEX_HEADER_SIZE + <span class="keyword">this</span>.hashSlotNum * hashSlotSize</span><br><span class="line">                       + <span class="keyword">this</span>.indexHeader.getIndexCount() * indexSize;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 写入真正索引</span></span><br><span class="line">               <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos, keyHash);</span><br><span class="line">               <span class="keyword">this</span>.mappedByteBuffer.putLong(absIndexPos + <span class="number">4</span>, phyOffset);</span><br><span class="line">               <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span>, (<span class="keyword">int</span>) timeDiff);</span><br><span class="line">              <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span> + <span class="number">4</span>, slotValue);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 更新哈希槽</span></span><br><span class="line">               <span class="keyword">this</span>.mappedByteBuffer.putInt(absSlotPos, <span class="keyword">this</span>.indexHeader.getIndexCount());</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 第一次写入</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getIndexCount() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.indexHeader.setBeginPhyOffset(phyOffset);</span><br><span class="line">                   <span class="keyword">this</span>.indexHeader.setBeginTimestamp(storeTimestamp);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">this</span>.indexHeader.incHashSlotCount();</span><br><span class="line">               <span class="keyword">this</span>.indexHeader.incIndexCount();</span><br><span class="line">               <span class="keyword">this</span>.indexHeader.setEndPhyOffset(phyOffset);</span><br><span class="line">               <span class="keyword">this</span>.indexHeader.setEndTimestamp(storeTimestamp);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               log.error(<span class="string">"putKey exception, Key: "</span> + key + <span class="string">" KeyHashCode: "</span> + key.hashCode(), e);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (fileLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       fileLock.release();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           log.warn(<span class="string">"Over index file capacity: index count = "</span> + <span class="keyword">this</span>.indexHeader.getIndexCount()</span><br><span class="line">               + <span class="string">"; index max num = "</span> + <span class="keyword">this</span>.indexNum);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>将该条目信息存储在IndexFile中，在之前的所存储的最后一个Index的后面添加，依次存放hashcode、消息物理偏移值、消息存储时间戳与第一条消息时间戳的差值、上一条相同hashcode的索引位置。并将当前新放入的Index条目个数即下标放入到该key值所处的卡槽位置中，即会覆盖掉原来记录的Index条目的下标，它只会记录最新的Index条目的下标。</p><p>但会存在一种情况，即不同的key可能会存在相同的hashcode，在查找hash槽是根据hashcode查找的，只能记录一个，所以会产生冲突，面对这种情况，在Index索引记录时有一个属性记录了该条目的前一条记录的索引值，即他们的hashcode是相同的。</p><p>下面是根据索引key查找消息，其中有一步是解决了hashcode冲突问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectPhyOffset</span><span class="params">(<span class="keyword">final</span> List&lt;Long&gt; phyOffsets, <span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">int</span> maxNum,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">long</span> begin, <span class="keyword">final</span> <span class="keyword">long</span> end, <span class="keyword">boolean</span> lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mappedFile.hold()) &#123;</span><br><span class="line">            <span class="keyword">int</span> keyHash = indexKeyHashMethod(key);</span><br><span class="line">            <span class="keyword">int</span> slotPos = keyHash % <span class="keyword">this</span>.hashSlotNum;</span><br><span class="line">            <span class="keyword">int</span> absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize;</span><br><span class="line"></span><br><span class="line">            FileLock fileLock = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// fileLock = this.fileChannel.lock(absSlotPos,</span></span><br><span class="line">                    <span class="comment">// hashSlotSize, true);</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> slotValue = <span class="keyword">this</span>.mappedByteBuffer.getInt(absSlotPos);</span><br><span class="line">                <span class="comment">// if (fileLock != null) &#123;</span></span><br><span class="line">                <span class="comment">// fileLock.release();</span></span><br><span class="line">                <span class="comment">// fileLock = null;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (slotValue &lt;= invalidIndex || slotValue &gt; <span class="keyword">this</span>.indexHeader.getIndexCount()</span><br><span class="line">                    || <span class="keyword">this</span>.indexHeader.getIndexCount() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// TODO NOTFOUND</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> nextIndexToRead = slotValue;;) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (phyOffsets.size() &gt;= maxNum) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> absIndexPos =</span><br><span class="line">                            IndexHeader.INDEX_HEADER_SIZE + <span class="keyword">this</span>.hashSlotNum * hashSlotSize</span><br><span class="line">                                + nextIndexToRead * indexSize;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> keyHashRead = <span class="keyword">this</span>.mappedByteBuffer.getInt(absIndexPos);</span><br><span class="line">                        <span class="keyword">long</span> phyOffsetRead = <span class="keyword">this</span>.mappedByteBuffer.getLong(absIndexPos + <span class="number">4</span>);</span><br><span class="line">                        <span class="comment">// int转为long，避免下面计算时间差值时溢出</span></span><br><span class="line">                        <span class="keyword">long</span> timeDiff = (<span class="keyword">long</span>) <span class="keyword">this</span>.mappedByteBuffer.getInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span>);</span><br><span class="line">                       <span class="keyword">int</span> prevIndexRead = <span class="keyword">this</span>.mappedByteBuffer.getInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span> + <span class="number">4</span>);</span><br><span class="line">                        <span class="comment">// 读到了未知数据</span></span><br><span class="line"><span class="keyword">if</span> (timeDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 时间差存储的是秒，再还原为毫秒， long避免溢出</span></span><br><span class="line">                        timeDiff *= <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">long</span> timeRead = <span class="keyword">this</span>.indexHeader.getBeginTimestamp() + timeDiff;</span><br><span class="line">                        <span class="keyword">boolean</span> timeMatched = (timeRead &gt;= begin) &amp;&amp; (timeRead &lt;= end);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (keyHash == keyHashRead &amp;&amp; timeMatched) &#123;</span><br><span class="line">                            phyOffsets.add(phyOffsetRead);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (prevIndexRead &lt;= invalidIndex</span><br><span class="line">                            || prevIndexRead &gt; <span class="keyword">this</span>.indexHeader.getIndexCount()</span><br><span class="line">                            || prevIndexRead == nextIndexToRead || timeRead &lt; begin) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        nextIndexToRead = prevIndexRead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"selectPhyOffset exception "</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fileLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        fileLock.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.mappedFile.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于会存在hash冲突，根据slotValue定位该hash槽最新的一个Item条目，经过一些处理后，会通过 <em>prevIndexRead</em> 获取到该Hashcode下的上一个Index下标，如果大于等于1并且小于最大条目数，则继续查找，否则结束查找。</p><h1 id="文件刷盘机制"><a href="#文件刷盘机制" class="headerlink" title="文件刷盘机制"></a>文件刷盘机制</h1><p>RocketMQ的存储与读写是基于JDK NIO的内存映射机制（MappedByteBuffer）的，消息存储时首先将消息追加到内存，再根据配置的刷盘策略在不同时间进行刷写磁盘，如果是同步刷盘，消息追加到内存后，将同步调用MappedByteBuffer的force方法；如果是异步刷盘，在消息追加到内存后立刻返回给消息发送端，RocketMQ使用一个单独的线程按照某一个设定的频率执行刷盘操作。</p><h1 id="Consume与IndexFile文件的实时更新"><a href="#Consume与IndexFile文件的实时更新" class="headerlink" title="Consume与IndexFile文件的实时更新"></a>Consume与IndexFile文件的实时更新</h1><p>当消息提交存储在Commitlog文件中，ConsumeQueue、IndexFile文件需要及时更新，否则消息无法及时被消费，如何确保消息内容能及时更新到ConsumeQueue、IndexFile等文件，RocketMQ通过开启一个线程ReputMessageService来实时更新消息信息。</p><p>在ReputMessageService线程中有一个重要的参数reputFromOffset,该参数表示从哪个物理偏移量开始转发消息给ConsumeQueue和IndexFile,如果允许重复转发，reputFromOffset设置为CommitLog的提交指针，如果不允许重复转发，reputFromOffset设置为CommitLog的内存中最大偏移量。读取的时候会读取该偏移量后的所有消息。</p><p>ReputMessageService线程每执行一次任务推送休息1毫秒就继续推送消息到消息消费队列和索引文件。<br>获取到新增的消息后，会采用不同的方法来对ConsumeQueue和IndexFile文件进行更新。</p><h2 id="根据消息更新对应文件"><a href="#根据消息更新对应文件" class="headerlink" title="根据消息更新对应文件"></a>根据消息更新对应文件</h2><p>获取到新增的消息后，要将这些消息更新到ConsumeQueue或IndexFile中，现以ConsumeQueue文件为例。</p><ul><li>根据消息主题与队列ID,获取到对应的ConsumeQueue文件，ConsumeQueue文件实际是对应的该队列ID下的文件夹，文件夹里有很多文件，在ConsumeQueue属性里面有一个MappedFileQueue,对该文件夹下的所有文件做映射。</li><li>依次将消息偏移量、消息长度、tag hashcode写入到ByteBuffer中，将内容追加到ConsumeQueue的内存映射文件中，ConsumeQueue的刷盘方式固定为异步刷盘方式。</li></ul><h1 id="过期文件删除机制"><a href="#过期文件删除机制" class="headerlink" title="过期文件删除机制"></a>过期文件删除机制</h1><p>CommitLog、ConsumeQueue文件是基于内存映射机制并在启动的时候会加载commitlog、ConsumeQueue目录下的所有文件，为了避免内存与磁盘的浪费，不可能将消息永久的存储在消息服务器上。</p><p>RocketMQ顺序写CommitLog文件、ConsumeQueue文件，所有写操作全部落在了最后一个CommitLog或ConsumeQueue文件上，之前的文件在下一个文件创建后将不会再更新，如果非当前写文件在下一个文件创建后将不会再被更新，则认为是过期文件，默认的过期时间是72小时。</p><p>RocketMQ会在下面几种情况下执行删除文件操作。</p><ul><li>指定删除文件的时间点，通过设置deleteWhen设置一天的固定时间执行一次删除过期文件操作，默认是凌晨4点</li><li>磁盘空间是否充足，如果磁盘空间不充足，则会触发过期文件删除操作。</li><li>可以通过调用excuteDeleteFilesManualy方法手动触发过期文件删除。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;消息存储部分是RocketMQ的重要组成部分，良好的存储机制会有效降低延迟，提高整体效率。RocketMQ利用到了文件系统，将消息存放在磁盘中实现持久化。&lt;/p&gt;
&lt;p&gt;首先先介绍消息存储的整体结构，先大体了解其处理机制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ阅读笔记之消息发送</title>
    <link href="https://github.com/spurstong/2019/10/31/RocketMQ%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/"/>
    <id>https://github.com/spurstong/2019/10/31/RocketMQ阅读笔记之消息发送/</id>
    <published>2019-10-31T15:16:01.333Z</published>
    <updated>2019-11-09T07:10:38.794Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章中我们可以了解到NameServer需要等Broker失效至少120s才能将该Broker从路由表中移除，那如果在Broker故障期间，消息生产者Producer根据获取到的路由信息可能包含已经宕机的Broker,会导致消息发送失败，在接下来的消息发送阶段会解决这个问题。</p><a id="more"></a><h1 id="初识消息有关类"><a href="#初识消息有关类" class="headerlink" title="初识消息有关类"></a>初识消息有关类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8445773977080406428L</span>;  </span><br><span class="line">    # 消息所属主题</span><br><span class="line">    <span class="keyword">private</span> String topic;</span><br><span class="line"> # 消息Flag</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> flag;</span><br><span class="line"> # 扩展属性</span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, String&gt; properties;</span><br><span class="line"> # 消息体</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">byte</span>[] body;</span><br><span class="line"> <span class="keyword">private</span> String transactionId;</span><br></pre></td></tr></table></figure><p>其中，Message扩展属性主要包括下面几个：</p><ul><li>tag : 消息Tag,用于消息过滤</li><li>keys ：Message索引建，多个用空格隔开，RocketMQ可以根据这些key快速检索到消息</li><li>waitStoreMsgOK ： 消息发送时是否等到消息存储完成后再返回</li><li>delayTimeLevel : 消息延迟级别，用于定时消息或消息重试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMQProducer</span> <span class="keyword">extends</span> <span class="title">ClientConfig</span> <span class="keyword">implements</span> <span class="title">MQProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InternalLogger log = ClientLogger.getLog();    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrapping internal implementations for virtually all methods presented in this class. */</span>  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">transient</span> DefaultMQProducerImpl defaultMQProducerImpl;   </span><br><span class="line">  # 生产者所属组，消息服务器在回查事务状态时会随机选择该组中的任何一个生产者发起事务回查请求</span><br><span class="line">  <span class="keyword">private</span> String producerGroup;   </span><br><span class="line">  <span class="keyword">private</span> String createTopicKey = MixAll.AUTO_CREATE_TOPIC_KEY_TOPIC;    </span><br><span class="line">  # 默认主题在每一个Broker队列的数量</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> defaultTopicQueueNums = <span class="number">4</span>;    </span><br><span class="line">  # 发送消息默认超时时间，默认3秒</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> sendMsgTimeout = <span class="number">3000</span>;</span><br><span class="line">  # 消息体超过该值则启用压缩，默认4K     </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> compressMsgBodyOverHowmuch = <span class="number">1024</span> * <span class="number">4</span>;    </span><br><span class="line">  # 同步方式发送消息重试次数，默认为2，总共执行3次</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> retryTimesWhenSendFailed = <span class="number">2</span>;</span><br><span class="line">  # 异步方式发送消息重试次数，默认为2    </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> retryTimesWhenSendAsyncFailed = <span class="number">2</span>; </span><br><span class="line">  # 允许发送的最大消息长度   </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxMessageSize = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>; <span class="comment">// 4M    </span></span><br><span class="line">  <span class="keyword">private</span> TraceDispatcher traceDispatcher = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">MessageQueue</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6191200464116433425L</span>;</span><br><span class="line"> <span class="keyword">private</span> String topic;</span><br><span class="line"> <span class="keyword">private</span> String brokerName;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> queueId;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicPublishInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> orderTopic = <span class="keyword">false</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">boolean</span> haveTopicRouterInfo = <span class="keyword">false</span>;</span><br><span class="line"> <span class="keyword">private</span> List&lt;MessageQueue&gt; messageQueueList = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadLocalIndex sendWhichQueue = <span class="keyword">new</span> ThreadLocalIndex();</span><br><span class="line"> <span class="keyword">private</span> TopicRouteData topicRouteData;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicRouteData</span> <span class="keyword">extends</span> <span class="title">RemotingSerializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String orderTopicConf;</span><br><span class="line">    <span class="keyword">private</span> List&lt;QueueData&gt; queueDatas;</span><br><span class="line">    <span class="keyword">private</span> List&lt;BrokerData&gt; brokerDatas;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br></pre></td></tr></table></figure><h1 id="发送信息总体过程"><a href="#发送信息总体过程" class="headerlink" title="发送信息总体过程"></a>发送信息总体过程</h1><ol><li>发送消息的入口  DefaultMQProducerImpl#send()  ，默认消息发送以同步方式发送，默认超时时间为3s。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg, SendCallback sendCallback)</span> <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException </span>&#123;</span><br><span class="line">       send(msg, sendCallback, <span class="keyword">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg, SendCallback sendCallback, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.sendDefaultImpl(msg, CommunicationMode.ASYNC, sendCallback, timeout);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"unknownn exception"</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>调用sendDefaultImpl，形参为下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendDefaultImpl</span><span class="params">(//</span></span></span><br><span class="line"><span class="function"><span class="params">       Message msg, //</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> CommunicationMode communicationMode, //</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> SendCallback sendCallback, //</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> <span class="keyword">long</span> timeout//</span></span></span><br><span class="line"><span class="function"><span class="params">   )</span></span></span><br></pre></td></tr></table></figure></li></ol><p>其中，CommunicationMode表示消息发送的方式，同步、异步和单向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CommunicationMode &#123;</span><br><span class="line">    SYNC,</span><br><span class="line">    ASYNC,</span><br><span class="line">    ONEWAY,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会验证服务服务是否可用，消息是否符合规范，具体的验证就不解释了。<br>然后记录当前时间，后面会判断是否timeout。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> beginTimestampFirst = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> beginTimestampPrev = beginTimestampFirst;</span><br></pre></td></tr></table></figure><p>根据要发送消息的topic,寻找该topic的路由信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br></pre></td></tr></table></figure><p>当前类有一个属性，记录所有topic的路由信息和消息队列信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* topic */</span>, TopicPublishInfo&gt; topicPublishInfoTable =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;String, TopicPublishInfo&gt;();</span><br></pre></td></tr></table></figure><p>首先从topicPublishInfoTable中查找该topic的topicPublishInfoTable信息，<br>如果不存在当前topic的信息或者当前topicPublishInfoTable不可用，则先新创建一个TopicPublishInfo()，并放入到topicPublishInfoTable中，然后向NameServer查询该topic的路由信息，此时会调用MQClientInstance的updateTopicRouteInfoFromNameServer(topic)方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TopicPublishInfo <span class="title">tryToFindTopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存中获取 Topic发布信息</span></span><br><span class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    <span class="comment">// 当无或者可用的 Topic信息时，从Namesrv获取一次 并且缓存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == topicPublishInfo || !topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.topicPublishInfoTable.putIfAbsent(topic, <span class="keyword">new</span> TopicPublishInfo());<span class="comment">//如果key存在的情况下，在putIfAbsent下不会修改</span></span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic); <span class="comment">//进行调用获取规则存下来</span></span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, <span class="keyword">true</span>, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock lockNamesrv = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure><p>MQClientInstance#updateTopicRouteInfoFromNameServer方法,LOCK_TIMEOUT_MILLIS默认是3秒，在此处用到了ReentrantLock.tryLock。<br>该锁的方法的简单解释：<br>假如线程A和线程B使用同一个锁Lock,此时线程A首先获取锁Lock.lock(),并且始终持有不释放，如果此时B要去获取锁，调用tryLock(3000, mils),则说明在3秒内如果线程A释放锁，会获取到锁并返回true,否则3秒过后会获取不到锁并返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.lockNamesrv.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br></pre></td></tr></table></figure><p>如果isDefault为true,则使用默认主题去查询，如果查询到路由信息，则替换路由信息中读写队列个数为消息生产者默认的队列个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TopicRouteData topicRouteData;</span><br><span class="line"><span class="keyword">if</span> (isDefault &amp;&amp; defaultMQProducer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getDefaultTopicRouteInfoFromNameServer(defaultMQProducer.getCreateTopicKey(),</span><br><span class="line">        <span class="number">1000</span> * <span class="number">3</span>);<span class="comment">//获取topic规则</span></span><br><span class="line">    <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (QueueData data : topicRouteData.getQueueDatas()) &#123;</span><br><span class="line">            <span class="keyword">int</span> queueNums = Math.min(defaultMQProducer.getDefaultTopicQueueNums(), data.getReadQueueNums());</span><br><span class="line">            data.setReadQueueNums(queueNums);</span><br><span class="line">            data.setWriteQueueNums(queueNums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果isDefault为false,则使用参数topic去查询，如果未查询到路由信息，则返回false,表示路由信息未变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getTopicRouteInfoFromNameServer(topic, <span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果路由信息找到，与本地缓存中的路由信息进行对比，判断路由信息是否发生了变化，如果没有发生变化，则直接返回fasle。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">    TopicRouteData old = <span class="keyword">this</span>.topicRouteTable.get(topic);</span><br><span class="line">    <span class="keyword">boolean</span> changed = topicRouteDataIsChange(old, topicRouteData);</span><br><span class="line">    <span class="keyword">if</span> (!changed) &#123;</span><br><span class="line">        changed = <span class="keyword">this</span>.isNeedUpdateTopicRouteInfo(topic);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"the topic[&#123;&#125;] route info changed, old[&#123;&#125;] ,new[&#123;&#125;]"</span>, topic, old, topicRouteData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果发生了变化，先对topicRouteData进行复制，然后根据获得的topicRouteData信息对brokerAddrTable进行更新，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (changed) &#123;</span><br><span class="line">    TopicRouteData cloneTopicRouteData = topicRouteData.cloneTopicRouteData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BrokerData bd : topicRouteData.getBrokerDatas()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerAddrTable.put(bd.getBrokerName(), bd.getBrokerAddrs());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据topicRouteData中的List&lt;\queueData&gt;转化成topicPublishInfo的List&lt;\MessageQueue&gt;列表。具体的是在topicRouteData2TopicPublishInfo中实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TopicPublishInfo publishInfo = topicRouteData2TopicPublishInfo(topic, topicRouteData);</span><br><span class="line">publishInfo.setHaveTopicRouterInfo(<span class="keyword">true</span>);</span><br><span class="line">Iterator&lt;Entry&lt;String, MQProducerInner&gt;&gt; it = <span class="keyword">this</span>.producerTable.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Entry&lt;String, MQProducerInner&gt; entry = it.next();</span><br><span class="line">    MQProducerInner impl = entry.getValue();</span><br><span class="line">    <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        impl.updateTopicPublishInfo(topic, publishInfo);<span class="comment">//更新topic的PublishInfo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环遍历路由信息的QueueData信息，如果队列没有写权限，则继续遍历下一个QueueData,根据brokerName找到brokerData信息，找不到或没有找到Master节点，则遍历下一个QueueData,根据写队列个数，根据topic+序号创建MessageQueue,填充topicPublishInfo的List&lt;\QueueMessage&gt;,此时，完成了消息发送的路由查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//topicRouteData转换为TopicPublishInfo</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TopicPublishInfo <span class="title">topicRouteData2TopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> TopicRouteData route)</span> </span>&#123;</span><br><span class="line">        TopicPublishInfo info = <span class="keyword">new</span> TopicPublishInfo();</span><br><span class="line">        info.setTopicRouteData(route);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有序</span></span><br><span class="line">        <span class="keyword">if</span> (route.getOrderTopicConf() != <span class="keyword">null</span> &amp;&amp; route.getOrderTopicConf().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String[] brokers = route.getOrderTopicConf().split(<span class="string">";"</span>);</span><br><span class="line">            <span class="keyword">for</span> (String broker : brokers) &#123;</span><br><span class="line">                String[] item = broker.split(<span class="string">":"</span>);</span><br><span class="line">                <span class="keyword">int</span> nums = Integer.parseInt(item[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">                    MessageQueue mq = <span class="keyword">new</span> MessageQueue(topic, item[<span class="number">0</span>], i);</span><br><span class="line">                    info.getMessageQueueList().add(mq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            info.setOrderTopic(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//无序</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;QueueData&gt; qds = route.getQueueDatas();</span><br><span class="line">            Collections.sort(qds);<span class="comment">//按照brokerName升序进行排序的</span></span><br><span class="line">            <span class="keyword">for</span> (QueueData qd : qds) &#123;</span><br><span class="line">                <span class="keyword">if</span> (PermName.isWriteable(qd.getPerm())) &#123;</span><br><span class="line">                    BrokerData brokerData = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (BrokerData bd : route.getBrokerDatas()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (bd.getBrokerName().equals(qd.getBrokerName())) &#123;</span><br><span class="line">                            brokerData = bd;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == brokerData) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!brokerData.getBrokerAddrs().containsKey(MixAll.MASTER_ID)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qd.getWriteQueueNums(); i++) &#123;</span><br><span class="line">                        MessageQueue mq = <span class="keyword">new</span> MessageQueue(topic, qd.getBrokerName(), i);</span><br><span class="line">                        info.getMessageQueueList().add(mq);<span class="comment">//由于brokerName是排序的，TopicPublishInfo里面的messageQueueList就是有序的了从小到大</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            info.setOrderTopic(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取到路由信息之后，如果该路由信息可用，则先计算尝试的次数，如果发送模式是sync,则是3次，其他情况下是1次。<br>之后记录上次发送失败的broker名称，在第一次发送的时候，lastBrokerName为null,然后根据消息队列选择策略选择消息队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">    MessageQueue mq = <span class="keyword">null</span>;</span><br><span class="line">    Exception exception = <span class="keyword">null</span>;</span><br><span class="line">    SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//发送模式是sync 会有3次其他1次</span></span><br><span class="line">    <span class="keyword">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? <span class="number">1</span> + <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">            String[] brokersSent = <span class="keyword">new</span> String[timesTotal];</span><br><span class="line">            <span class="keyword">for</span> (; times &lt; timesTotal; times++) &#123;</span><br><span class="line">                String lastBrokerName = <span class="keyword">null</span> == mq ? <span class="keyword">null</span> : mq.getBrokerName(); <span class="comment">//第一次的确是null 但是如果第二次呢？ 所以这里存在的意义</span></span><br><span class="line">                MessageQueue tmpmq = <span class="keyword">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName);<span class="comment">//选择一个queue</span></span><br><span class="line">                <span class="keyword">if</span> (tmpmq != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mq = tmpmq;</span><br><span class="line">                    brokersSent[times] = mq.getBrokerName();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line">                        <span class="comment">//调用sendKernelImpl发送消息  发送消息核心</span></span><br><span class="line">                        sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        <span class="comment">//更新Broker可用信息</span></span><br><span class="line">                        <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line">                        <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">                            <span class="keyword">case</span> ASYNC:</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">case</span> SYNC:</span><br><span class="line">                                <span class="keyword">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">return</span> sendResult;</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">true</span>);</span><br><span class="line">                        log.warn(String.format(<span class="string">"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        exception = e;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">true</span>);</span><br><span class="line">                        log.warn(String.format(<span class="string">"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        exception = e;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">true</span>);</span><br><span class="line">                        log.warn(String.format(<span class="string">"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        exception = e;</span><br><span class="line">                        <span class="keyword">switch</span> (e.getResponseCode()) &#123;</span><br><span class="line">                           <span class="comment">// 如下异常continue，进行发送消息重试</span></span><br><span class="line">                            <span class="keyword">case</span> ResponseCode.TOPIC_NOT_EXIST:</span><br><span class="line">                            <span class="keyword">case</span> ResponseCode.SERVICE_NOT_AVAILABLE:</span><br><span class="line">                            <span class="keyword">case</span> ResponseCode.SYSTEM_ERROR:</span><br><span class="line">                            <span class="keyword">case</span> ResponseCode.NO_PERMISSION:</span><br><span class="line">                            <span class="keyword">case</span> ResponseCode.NO_BUYER_ID:</span><br><span class="line">                            <span class="keyword">case</span> ResponseCode.NOT_IN_CURRENT_UNIT:</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                <span class="keyword">if</span> (sendResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">return</span> sendResult;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">throw</span> e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line">                        log.warn(String.format(<span class="string">"sendKernelImpl exception, throw exception, InvokeID: %s, RT: %sms, Broker: %s"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line">                        log.warn(<span class="string">"sendKernelImpl exception"</span>, e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>消息队列选择策略。<br>有两种策略， sendLatencyFaultEnable=false, 默认不启用Broker故障延迟机制。<br>                       sendLatencyFaultEnable=true,启用Broker故障延迟机制。<br> 先介绍默认的消息队列选择策略，调用TopicPublishInfo#selectOneMessageQueue<br> 当第一次调用时，lastBrokerName为null,对sendWhichQueue本地线程变量进行加1，并与当前路由表中消息队列个数取模，返回该位置的MessageQueue。<br> 如果该消息发送失败，则可能会进行重试发送，此时，lastBrokerName不是null,会记录上次信息发送失败的BrokerName,之后获取sendWhichQueue本地线程变量进行加1，并与当前路由表中消息队列个数取模，获取该位置上的MessageQueue,如果获取的该信息的BrokerName与上一次发送失败的lastBrokerName不相同，则返回该信息，否则再遍历下一个消息，直到第一个不与lastBrokerName相同的消息返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastBrokerName == <span class="keyword">null</span>) &#123;<span class="comment">//第一次进入就是空的</span></span><br><span class="line">            <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="keyword">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.messageQueueList.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = Math.abs(index++) % <span class="keyword">this</span>.messageQueueList.size();</span><br><span class="line">                <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                    pos = <span class="number">0</span>;</span><br><span class="line">                MessageQueue mq = <span class="keyword">this</span>.messageQueueList.get(pos);</span><br><span class="line">                <span class="keyword">if</span> (!mq.getBrokerName().equals(lastBrokerName)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mq;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> index = <span class="keyword">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line">       <span class="keyword">int</span> pos = Math.abs(index) % <span class="keyword">this</span>.messageQueueList.size();</span><br><span class="line">       <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">           pos = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.messageQueueList.get(pos);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>接下来讲解启用Broker故障延迟机制的消息选择策略<br>前面部分和上述介绍的差不多，根据index先获取当前位置的消息，然后判断该消息队列是否可用，通过isAvailable方法判断。如果该消息队列可用，在上次发送，或者这次发送的消息队列的broker姓名与上次发送失败的broker姓名一致，则返回该消息队列。<br>如果所有的broker都预计不可用，随机选择一个不可用的broker,再从路由信息中选择下一个消息队列，将该消息队列的broker重置为上面随机选择的broker,并重置queueId,并返回该消息队列。但是，如果该随机选择的broker内已经没有要发送的消息队列时，则需要将该broker从latencyFaultTolerance中移除，并利用默认的选择机制选择一个消息队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延迟故障容错，维护每个Broker的发送消息的延迟</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> LatencyFaultTolerance&lt;String&gt; latencyFaultTolerance = <span class="keyword">new</span> LatencyFaultToleranceImpl();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123; <span class="comment">//发送消息延迟容错开关</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</span><br><span class="line">            <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</span><br><span class="line">            <span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</span><br><span class="line">                    <span class="keyword">return</span> mq;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</span><br><span class="line">        <span class="keyword">int</span> writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</span><br><span class="line">        <span class="keyword">if</span> (writeQueueNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> MessageQueue mq = tpInfo.selectOneMessageQueue();</span><br><span class="line">            <span class="keyword">if</span> (notBestBroker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mq.setBrokerName(notBestBroker);</span><br><span class="line">                mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mq;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            latencyFaultTolerance.remove(notBestBroker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.eror(<span class="string">"Error occurred when selecting message queue"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tpInfo.selectOneMessageQueue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面部分是根据不同策略选择消息队列的具体解释，获取到消息队列之后，返回到发送消息的最外层方法endDefaultImpl中，执行消息发送步骤。</p><h1 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h1><p>tmpmq是选择获取到的消息队列。<br>brokersSent是存储消息发送的broker,由上面可知，如果发送方式是同步，则该数组长度为3，其他方式下长度为1。然后记录当前时间，然后执行<em>sendKernelImpl</em>方法进行发送消息。之后，获取发送完之后的时间，执行<em>updateFaultItem</em>方法来更新Broker异常信息，一个broker会对应一个faultItem。<br>之后，根据消息发送的方式，如果是同步的，如果此次消息没有成功，则可以再进行尝试，如果是异步或者单向，则执行结束。如果期间发送了异常，则会调用<em>updateFaultItem</em>方法来更新Broker异常信息。<br>接下来详细介绍<em>sendKernelImpl</em>方法和<em>updateFaultItem</em>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue tmpmq = <span class="keyword">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName)</span><br><span class="line"><span class="keyword">if</span> (tmpmq != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mq = tmpmq;</span><br><span class="line">    brokersSent[times] = mq.getBrokerName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//调用sendKernelImpl发送消息  发送消息核心</span></span><br><span class="line">        sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);</span><br><span class="line">        endTimestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//更新Broker可用信息</span></span><br><span class="line">        <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> ASYNC:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> SYNC:</span><br><span class="line">                <span class="keyword">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> sendResult;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="DefaultMQProducerImpl-sendKernelImpl"><a href="#DefaultMQProducerImpl-sendKernelImpl" class="headerlink" title="DefaultMQProducerImpl.sendKernelImpl"></a>DefaultMQProducerImpl.sendKernelImpl</h2><p>该方法的形参有：</p><ul><li>Message msg : 待发送的消息</li><li>MessageQueue mq : 消息将发送到该消息队列上</li><li>CommunicationMode commuicationMode : 消息发送模式，SYNC、ASYNC、ONEWAy</li><li>SendCallback sendCallback :异步消息回调函数</li><li>TopicPublishInfo topicPublishInfo ： 主题路由信息</li><li>long timeout:消息发送超时时间</li></ul><ol><li>根据MessageQueue获取Broker的网络地址,如果MQClientInstance的brokerAddrTable未缓存该Broker的信息，则从NameServer主动更新一下topic的路由信息，如果路由更新后还是找不到Broker信息，则抛出MQClientException，提示Broker不存在。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == brokerAddr) &#123;</span><br><span class="line">            tryToFindTopicPublishInfo(mq.getTopic());</span><br><span class="line">            brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>为消息分配全局唯一ID,如果消息体默认超过4K,会对消息体采用zip压缩，并设置消息的系统标记为MessageSysFlag.COMPRESED_FLAG。如果是事务Prepared消息，则设置消息的系统标记为MessageSysFlag.TRANSACTION_PREPARED_TYPE。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//for MessageBatch,ID has been set in the generating process</span></span><br><span class="line"><span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</span><br><span class="line">    MessageClientIDSetter.setUniqID(msg);<span class="comment">//设置设置UNIQ_id，所以当看见msgId的时候为什么解析不一样了懂了吧</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sysFlag = <span class="number">0</span>; <span class="comment">//又是根据位来进行每位是啥的判断</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.tryToCompressMessage(msg)) &#123;</span><br><span class="line">    sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);<span class="comment">//根据事务属性key获取值看是否是事务消息</span></span><br><span class="line"><span class="keyword">if</span> (tranMsg != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line">    sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果注册了消息发送钩子函数，则执行消息发送之前的增强逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">                context = <span class="keyword">new</span> SendMessageContext();</span><br><span class="line">                context.setProducer(<span class="keyword">this</span>);</span><br><span class="line">                context.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">                context.setCommunicationMode(communicationMode);</span><br><span class="line">                context.setBornHost(<span class="keyword">this</span>.defaultMQProducer.getClientIP());</span><br><span class="line">                context.setBrokerAddr(brokerAddr);</span><br><span class="line">                context.setMessage(msg);</span><br><span class="line">                context.setMq(mq);</span><br><span class="line">                String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">                <span class="keyword">if</span> (isTrans != <span class="keyword">null</span> &amp;&amp; isTrans.equals(<span class="string">"true"</span>)) &#123;</span><br><span class="line">                    context.setMsgType(MessageType.Trans_Msg_Half);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (msg.getProperty(<span class="string">"__STARTDELIVERTIME"</span>) != <span class="keyword">null</span> || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    context.setMsgType(MessageType.Delay_Msg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.executeSendMessageHookBefore(context);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></li><li><p>构建消息发送请求包。主要包含下列重要信息：</p></li></ol><ul><li>生产者组、主题名称、默认创建主题Key、该主题在单个Broker默认队列数、队列ID</li><li>消息系统标记、消息发送时间、消息标记、消息扩展属性、消息重试次数、是否是批量信息。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//构建SendMessageRequestHeader</span></span><br><span class="line">SendMessageRequestHeader requestHeader = <span class="keyword">new</span> SendMessageRequestHeader();</span><br><span class="line">    requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">    requestHeader.setTopic(msg.getTopic());</span><br><span class="line">    requestHeader.setDefaultTopic(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey());</span><br><span class="line">    requestHeader.setDefaultTopicQueueNums(<span class="keyword">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</span><br><span class="line">    requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line">    requestHeader.setSysFlag(sysFlag);</span><br><span class="line">    <span class="comment">//生成消息时间戳</span></span><br><span class="line">    requestHeader.setBornTimestamp(System.currentTimeMillis());</span><br><span class="line">    requestHeader.setFlag(msg.getFlag());</span><br><span class="line">    requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line">    requestHeader.setReconsumeTimes(<span class="number">0</span>);</span><br><span class="line">    requestHeader.setUnitMode(<span class="keyword">this</span>.isUnitMode());</span><br><span class="line">    requestHeader.setBatch(msg <span class="keyword">instanceof</span> MessageBatch);</span><br><span class="line">    <span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">        String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</span><br><span class="line">        <span class="keyword">if</span> (reconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</span><br><span class="line">            MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</span><br><span class="line">        <span class="keyword">if</span> (maxReconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</span><br><span class="line">            MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>按照消息发送方式，同步、异步、单向方式进行网络传输。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> ASYNC:</span><br><span class="line">        sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(<span class="comment">//异步发送消息</span></span><br><span class="line">            brokerAddr, <span class="comment">// 1</span></span><br><span class="line">            mq.getBrokerName(), <span class="comment">// 2</span></span><br><span class="line">            msg, <span class="comment">// 3</span></span><br><span class="line">            requestHeader, <span class="comment">// 4</span></span><br><span class="line">            timeout, <span class="comment">// 5</span></span><br><span class="line">            communicationMode, <span class="comment">// 6</span></span><br><span class="line">            sendCallback, <span class="comment">// 7</span></span><br><span class="line">            topicPublishInfo, <span class="comment">// 8</span></span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory, <span class="comment">// 9</span></span><br><span class="line">            <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(), <span class="comment">// 10</span></span><br><span class="line">            context, <span class="comment">//</span></span><br><span class="line">            <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ONEWAY:</span><br><span class="line">    <span class="keyword">case</span> SYNC:</span><br><span class="line">        sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(<span class="comment">//同步以及广播发送消息</span></span><br><span class="line">            brokerAddr,</span><br><span class="line">            mq.getBrokerName(),</span><br><span class="line">            msg,</span><br><span class="line">            requestHeader,</span><br><span class="line">            timeout,</span><br><span class="line">            communicationMode,</span><br><span class="line">            context,</span><br><span class="line">            <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">    context.setSendResult(sendResult);</span><br><span class="line">    <span class="keyword">this</span>.executeSendMessageHookAfter(context); <span class="comment">//发送消息后逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sendResult;</span><br></pre></td></tr></table></figure></li><li><p>之后就是按照不同的方式进行发送。在发送之前会检查消息发送是否合理，检查该Broker是否有写权限，该Topic是否可以进行消息发送，在NameServer端存储主题的配置信息，除此之外，开始检查队列，如果队列不合法，返回错误码</p></li><li><p>如果消息重试次数超过允许的最大重试次数，消息将进入到DLD延迟队列。延迟队列主题：%DLQ%+消费组名，</p></li><li><p>调用DefaultMessageStore.putMessage进行消息存储。</p></li></ol><h2 id="DefaultMQProducerImpl-updateFaultItem"><a href="#DefaultMQProducerImpl-updateFaultItem" class="headerlink" title="DefaultMQProducerImpl.updateFaultItem"></a>DefaultMQProducerImpl.updateFaultItem</h2><p>由上面可知，在执行消息发送完之后和出现发送异常的时候，会调用该方法对broker进行异常更新。<br>形参解释：</p><ul><li>brokerName : broker名称</li><li>currentLatency : 本次消息发送延迟时间currentLatency </li><li>isolation : 是否隔离，如果为true,则使用默认时长30s来计算BroKer故障规避时长；如果为false,则使用本次消息发送延迟时间来计算Broker故障规避时长。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">boolean</span> isolation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">            <span class="keyword">long</span> duration = computeNotAvailableDuration(isolation ? <span class="number">30000</span> : currentLatency);</span><br><span class="line">            <span class="keyword">this</span>.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>利用<em>computeNotAvailableDuration()</em> 方法计算规避时长。<br>从latencyMax数组尾部开始查找，找到第一个比currentLatency小的下标，然后从notAvailableDuration数组中获取需要规避的时长。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延迟级别数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] latencyMax = &#123;<span class="number">50L</span>, <span class="number">100L</span>, <span class="number">550L</span>, <span class="number">1000L</span>, <span class="number">2000L</span>, <span class="number">3000L</span>, <span class="number">15000L</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不可用时长数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] notAvailableDuration = &#123;<span class="number">0L</span>, <span class="number">0L</span>, <span class="number">30000L</span>, <span class="number">60000L</span>, <span class="number">120000L</span>, <span class="number">180000L</span>, <span class="number">600000L</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">computeNotAvailableDuration</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> currentLatency)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = latencyMax.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentLatency &gt;= latencyMax[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.notAvailableDuration[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据broker名称从缓存表faultItemTable中获取FaultItem,如果找到则更新FaultItem,否则创建FaultItem。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, FaultItem&gt; faultItemTable = <span class="keyword">new</span> ConcurrentHashMap&lt;String, FaultItem&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">final</span> <span class="keyword">long</span> notAvailableDuration)</span> </span>&#123;</span><br><span class="line">    FaultItem old = <span class="keyword">this</span>.faultItemTable.get(name);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == old) &#123;</span><br><span class="line">        <span class="keyword">final</span> FaultItem faultItem = <span class="keyword">new</span> FaultItem(name);</span><br><span class="line">        faultItem.setCurrentLatency(currentLatency);</span><br><span class="line">        faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line"></span><br><span class="line">        old = <span class="keyword">this</span>.faultItemTable.putIfAbsent(name, faultItem);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.setCurrentLatency(currentLatency);</span><br><span class="line">            old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        old.setCurrentLatency(currentLatency);</span><br><span class="line">        old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>一个broker对应一个faultItem,记录broker名称、消息发送时长和broker恢复正常时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FaultItem</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">FaultItem</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> currentLatency;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> startTimestamp;</span><br></pre></td></tr></table></figure><h1 id="批量消息发送"><a href="#批量消息发送" class="headerlink" title="批量消息发送"></a>批量消息发送</h1><p>批量消息发送就是将同一主题的多条信息一起打包发送到消息服务端，减少网络调用次数。<br>单挑信息发送时，消息体的内容将保存在body中。批量消息发送，需要将多条消息体的内容采用固定格式存储在body中。<br>在消息发送端，调用batch方法，将一批消息封装成MessageBatch对象，之后的处理流程与上面的基本一致，只需要将该集合的每一条消息的消息体body聚合成一个byte[]数值，在消息服务端能够从该byte[]数值中正确解析消息即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章中我们可以了解到NameServer需要等Broker失效至少120s才能将该Broker从路由表中移除，那如果在Broker故障期间，消息生产者Producer根据获取到的路由信息可能包含已经宕机的Broker,会导致消息发送失败，在接下来的消息发送阶段会解决这个问题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ阅读笔记之路由中心NameServer</title>
    <link href="https://github.com/spurstong/2019/10/22/RocketMQ%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%B7%AF%E7%94%B1%E4%B8%AD%E5%BF%83NameServer/"/>
    <id>https://github.com/spurstong/2019/10/22/RocketMQ阅读笔记之路由中心NameServer/</id>
    <published>2019-10-22T14:37:25.400Z</published>
    <updated>2019-10-31T12:28:26.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么会有NameServer"><a href="#为什么会有NameServer" class="headerlink" title="为什么会有NameServer"></a>为什么会有NameServer</h1><p>消息中间件一般基于主题的订阅发布机制，消息生产者会发送某一主体（Topic）的消息到消息服务器（Broker）,消息服务器负责该消息的持久化存储，消息消费者订阅感兴趣的主题。通常情况下，为了避免消息服务器的单点故障导致的整个系统瘫痪，通常会部署多台消息服务器共同承担消息的存储。那么消息生产者如何 知道消息要发往哪台消息服务器呢？如果某一台消息服务器宕机了，那么生产者如何在不重启服务的情况下感知。NameServer可以 解决上述问题。</p><p>Broker消息服务器在启动的时候向所有NameServer注册，消息生产者在发送消息之前先从NameServer获取Broker服务器地址列表，然后 根据负载均衡算法从列表中选择一台消息服务器进行消息发送，如果检测到Broker宕机，则从路由注册表中将其移除，但是路由变化不会马上通知消息生产者。</p><p>NameServer本身的高可用可通过部署多台NameServer服务器来实现，但彼此互不通信，也就是NameServer服务器之间在某一时刻的数据并不会完全相同 。</p><h1 id="NameServer作用及重要变量"><a href="#NameServer作用及重要变量" class="headerlink" title="NameServer作用及重要变量"></a>NameServer作用及重要变量</h1><p>NameServer存储路由的基础信息，还能够管理Broker节点，包括路由注册、路由删除等功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* clusterName */</span>, Set&lt;String<span class="comment">/* brokerName */</span>&gt;&gt; clusterAddrTable; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable; <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br></pre></td></tr></table></figure><p>从上面可以看出数据类型都是HashMap,  其中，QueueData记录的是消息队列的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueData</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">QueueData</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String brokerName;</span><br><span class="line"> # 读队列数量</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> readQueueNums;</span><br><span class="line"> # 写队列数量</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> writeQueueNums;</span><br><span class="line"> # 读写权限，具体含义参考PermName</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> perm;</span><br><span class="line"> # topic同步标记，具体含义参考TopicSysFlag</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> topicSynFlag;</span><br></pre></td></tr></table></figure><ul><li><p>记录集群信息，存储集群中所有Broker名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrokerData</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">BrokerData</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cluster;</span><br><span class="line"> <span class="keyword">private</span> String brokerName;</span><br><span class="line"> <span class="keyword">private</span> HashMap&lt;Long<span class="comment">/* brokerId */</span>, String<span class="comment">/* broker address */</span>&gt; brokerAddrs;</span><br></pre></td></tr></table></figure></li><li><p>Broker状态信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrokerLiveInfo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> lastUpdateTimestamp;</span><br><span class="line"> <span class="keyword">private</span> DataVersion dataVersion;</span><br><span class="line"> <span class="keyword">private</span> Channel channel;</span><br><span class="line"> <span class="keyword">private</span> String haServerAddr;</span><br></pre></td></tr></table></figure></li><li><p>topicQueueTable: Topic消息队列路由信息 ，消息发送时根据路由表进行负载均衡。</p></li><li><p>brokerAddrTable: Broker基础信息，包含brokerName、所属集群名称、主备Broker地址。</p></li><li><p>clusterAddrTable: Broker状态信息，存储集群中所有Broker名称。</p></li><li><p>brokerLiveTable: Broker状态信息。NameServer每次收到心跳包时会替换该信息。</p></li><li><p>filterServerTable: Broker上的FilterServer列表，用于类模式消息过滤。</p></li></ul><h1 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h1><p>Broker启动时向集群中所有的NameServer发送心跳语句，每隔30s向集群中所有NameServer发送心跳包，NameServer收到Broker心跳包时会更新brokerLiveTable缓存中BrokerLiveInfo的lastUpdateTimestamp,然后NameServer每隔10s扫描brokerLiveTable,如果连续120s没有收到心跳包，NameServer将移除该Broker的路由信息同时关闭Socket连接。</p><h1 id="NameServer处理心跳包"><a href="#NameServer处理心跳包" class="headerlink" title="NameServer处理心跳包"></a>NameServer处理心跳包</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RegisterBrokerResult <span class="title">registerBroker</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> String clusterName,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">final</span> String brokerAddr,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">final</span> String brokerName,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">final</span> <span class="keyword">long</span> brokerId,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">final</span> String haServerAddr,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">final</span> TopicConfigSerializeWrapper topicConfigWrapper,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">final</span> List&lt;String&gt; filterServerList,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">final</span> Channel channel)</span> </span>&#123;</span><br><span class="line">    RegisterBrokerResult result = <span class="keyword">new</span> RegisterBrokerResult();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.writeLock().lockInterruptibly();    Set&lt;String&gt; brokerNames = <span class="keyword">this</span>.clusterAddrTable.get(clusterName);</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">null</span> == brokerNames) &#123;</span><br><span class="line">                brokerNames = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"> <span class="keyword">this</span>.clusterAddrTable.put(clusterName, brokerNames);</span><br><span class="line">  &#125;</span><br><span class="line">            brokerNames.add(brokerName);   <span class="keyword">boolean</span> registerFirst = <span class="keyword">false</span>;    BrokerData brokerData = <span class="keyword">this</span>.brokerAddrTable.get(brokerName);</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">null</span> == brokerData) &#123;</span><br><span class="line">                registerFirst = <span class="keyword">true</span>;</span><br><span class="line">  brokerData = <span class="keyword">new</span> BrokerData(clusterName, brokerName, <span class="keyword">new</span> HashMap&lt;Long, String&gt;());</span><br><span class="line"> <span class="keyword">this</span>.brokerAddrTable.put(brokerName, brokerData);</span><br><span class="line">  &#125;</span><br><span class="line">            Map&lt;Long, String&gt; brokerAddrsMap = brokerData.getBrokerAddrs();</span><br><span class="line">  <span class="comment">//Switch slave to master: first remove &lt;1, IP:PORT&gt; in namesrv, then add &lt;0, IP:PORT&gt;</span></span><br><span class="line"> <span class="comment">//The same IP:PORT must only have one record in brokerAddrTable  Iterator&lt;Entry&lt;Long, String&gt;&gt; it = brokerAddrsMap.entrySet().iterator();</span></span><br><span class="line"> <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                Entry&lt;Long, String&gt; item = it.next();</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">null</span> != brokerAddr &amp;&amp; brokerAddr.equals(item.getValue()) &amp;&amp; brokerId != item.getKey()) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">  &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String oldAddr = brokerData.getBrokerAddrs().put(brokerId, brokerAddr);</span><br><span class="line">  registerFirst = registerFirst || (<span class="keyword">null</span> == oldAddr);   <span class="keyword">if</span> (<span class="keyword">null</span> != topicConfigWrapper</span><br><span class="line">                &amp;&amp; MixAll.MASTER_ID == brokerId) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion())</span><br><span class="line">                    || registerFirst) &#123;</span><br><span class="line">                    ConcurrentMap&lt;String, TopicConfig&gt; tcTable =</span><br><span class="line">                        topicConfigWrapper.getTopicConfigTable();</span><br><span class="line"> <span class="keyword">if</span> (tcTable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Map.Entry&lt;String, TopicConfig&gt; entry : tcTable.entrySet()) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.createAndUpdateQueueData(brokerName, entry.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            BrokerLiveInfo prevBrokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.put(brokerAddr,</span><br><span class="line"> <span class="keyword">new</span> BrokerLiveInfo(</span><br><span class="line">                    System.currentTimeMillis(),</span><br><span class="line">  topicConfigWrapper.getDataVersion(),</span><br><span class="line">  channel,</span><br><span class="line">  haServerAddr));</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">null</span> == prevBrokerLiveInfo) &#123;</span><br><span class="line">                log.info(<span class="string">"new broker registered, &#123;&#125; HAServer: &#123;&#125;"</span>, brokerAddr, haServerAddr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (filterServerList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (filterServerList.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.filterServerTable.remove(brokerAddr);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.filterServerTable.put(brokerAddr, filterServerList);</span><br><span class="line">  &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (MixAll.MASTER_ID != brokerId) &#123;</span><br><span class="line">                String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);</span><br><span class="line"> <span class="keyword">if</span> (masterAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    BrokerLiveInfo brokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.get(masterAddr);</span><br><span class="line"> <span class="keyword">if</span> (brokerLiveInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());</span><br><span class="line">  result.setMasterAddr(masterAddr);</span><br><span class="line">  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.writeLock().unlock();</span><br><span class="line">  &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"registerBroker Exception"</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result; &#125;</span><br></pre></td></tr></table></figure><ul><li>路由注册需要加写锁，防止并发修改RouteInfoManager中的路由表。首先判断Broker所属集群是否存在，如果不存在，则创建，然后将broker名加入到集群Broker集合中。</li><li>维护BrokerData信息，首先从brokerAddrTable根据BrokerName尝试获取Broker信息，如果不存在，则新建BrokerData并放入到brokerAddrTable,registerFirst设置为true；如果存在，直接替换原来的，registerFirst设置为false,表示非第一次注册。</li><li>如果Broker为Master,并且Broker Topic配置信息发生变化或者是初次注册，则需要创建或更新Topic路由元数据，填充topicQueueTable,其实就是为默认主题自动注册路由信息。根据TopicConfig创建QueueData的数据结构，然后更新topicQueueTable。</li><li>更新BrokerLiveInfo,存活Broker信息表，BrokerLiveInfo是执行路由删除的重要依据。</li><li>注册Broker的过滤器Server地址列表，一个Broker上会关联多个FilterServer消息过滤服务器。</li></ul><h1 id="路由删除"><a href="#路由删除" class="headerlink" title="路由删除"></a>路由删除</h1><p>NameServer会每隔10s扫描brokerLiveTable状态表，如果BrokerLive的lastUpdateTimestamp的时间戳距当前时间超过120s,则认为Broker失效，移除该Broker,关闭与Broker连接，并同时更新topicQueueTable、brokerAddrTable、brokerLiveTable、filterServerTable。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么会有NameServer&quot;&gt;&lt;a href=&quot;#为什么会有NameServer&quot; class=&quot;headerlink&quot; title=&quot;为什么会有NameServer&quot;&gt;&lt;/a&gt;为什么会有NameServer&lt;/h1&gt;&lt;p&gt;消息中间件一般基于主题的订阅发布机制
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HashTable源码分析</title>
    <link href="https://github.com/spurstong/2019/10/22/HashTable%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/spurstong/2019/10/22/HashTable源码分析/</id>
    <published>2019-10-22T10:47:06.517Z</published>
    <updated>2019-10-22T12:55:02.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Map的架构"><a href="#Map的架构" class="headerlink" title="Map的架构"></a>Map的架构</h1><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/HashTable%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png" alt="1.png"><br>从上面图中可以看出，Map类型的子类主要有TreeMap、HashMap和HashTable等。<br>其中，TreeMap和HashMap主要继承的是AbstractMap，也同时实现了Map接口，而HashTable则继承了Directionary，同时也实现了Map接口。<br>HashMap和HashTable的内容都是键值对，都不保证次序，但HashMap是线程不安全的，而HashTable是线程安全的，它的key和value都不允许为空。</p><p>HashTable的继承情况如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>其中，Dictionary抽象类定义了键值对的基本操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dictionary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> Enumeration&lt;K&gt; <span class="title">keys</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> Enumeration&lt;V&gt; <span class="title">elements</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HashTable源码分析"><a href="#HashTable源码分析" class="headerlink" title="HashTable源码分析"></a>HashTable源码分析</h1><ol><li>HashTable成员变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键值对数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"><span class="comment">//数组的实际数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">//阈值，用来判断是否要调整HashTable的容量 （threshold = 容量 * loadFactor）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//加载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">//被修改的次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//版本序列号</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1421746759512286392L</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>构造函数<br>HashMap的构造函数有四种形式，你可以手动设置数组的初始化容量和加载因子，如果没有设置，默认的初始化容量值为11，加载因子为0.75, 也可以将一个给定的同等类型的Map构造映射为新的HashTable.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line"> <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+loadFactor);   <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">  table = <span class="keyword">new</span> Entry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">  threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</span><br><span class="line">  putAll(t); &#125;</span><br></pre></td></tr></table></figure></li><li><p>判断是否包含该value</p></li></ol><p>首先将该键值对数组赋值给tab数组，然后从尾到头逆向查找,然后在该位置的单向链表中进行依次查找，找到后返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = tab.length ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.value.equals(value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>判断是否包含该key<br>在获取到该key的hash值后，会与0x7FFFFFFF执行按位与操作，这样做是为了保证index的第一位是0，也就是为了保证得到的是一个正数，因为有符号数的第一位是0时代表为正数，1表示为负数。<br>然后根据index找到该key所在数组中的位置，然后开始单向遍历该位置的链表。如果该节点的hash值与要查找的key的hash值相等，并且key值相等，则返回true。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">     <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">     <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">     <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br></pre></td></tr></table></figure></li></ol><p>返回该key上的值的原理同上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> (V)e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>HashTable扩容</li></ol><p>首先将原来table赋值给oldMap数组，然后将新的数组长度扩展为原来数组长度的2倍+1，如果超出最大值，将设置新的数组长度为最大值。之后，创建一个该新长度的数组。<br>修改次数+1，并设置新的阈值。<br>开始初始化HashTable,根据新的容量长度查找在新的数组的位置，之后采用头插法插入到该位置的单向链表的头部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">       Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">               <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">       &#125;</span><br><span class="line">       Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">       table = newMap;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">           <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">               Entry&lt;K,V&gt; e = old;</span><br><span class="line">               old = old.next;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">               e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">               newMap[index] = e;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>HashTable添加元素</li></ol><p>首先它会判断该数组中是否含有该key值，如果有则进行值替换。<br>如果没有，则利用头插法插入到该数组位置的头结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">   <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">   <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">   <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">              V old = entry.value;</span><br><span class="line">    entry.value = value;</span><br><span class="line">   <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      addEntry(hash, key, value, index);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;   </span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">   <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">          <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">    rehash();    </span><br><span class="line">    tab = table;</span><br><span class="line">    hash = key.hashCode();</span><br><span class="line">    index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">  tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">  count++; &#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>HashTable删除元素<br>如果删除的位置是某一单向链表的非头结点位置，则记录它的前一结点和下一结点，然后将前一结点的next指向它的下一结点。<br>如果是该链表的头结点的话，就将待删除结点的下一结点赋值给头结点。最后，设置待删除结点的值为null.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">     <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">     <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">     <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">     <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    prev.next = e.next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = e.next;</span><br><span class="line">      &#125;</span><br><span class="line">      count--;</span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      e.value = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">return</span> oldValue;</span><br><span class="line">      &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="HashTable与HashMap的不同"><a href="#HashTable与HashMap的不同" class="headerlink" title="HashTable与HashMap的不同"></a>HashTable与HashMap的不同</h1><ol><li>基类不同：HashTable基于Dictionary类，而HashMap是基于AbstractMap。</li><li>null不同：HashMap可以允许存在一个为null和任意个为null的value,但是HashTable中的key和value都不允许为null。</li><li>线程安全：HashMap是单线程安全的，多线程不安全，而Hashtable是多线程安全的。</li><li>遍历不同：HashMap仅支持Iterator的遍历方式，而Hashtable支持Iterrator和Enumeration两种遍历放式。</li><li>存储结构： HashMap是数组+单向链表+红黑树，而HashTable是数组+单向链表</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Map的架构&quot;&gt;&lt;a href=&quot;#Map的架构&quot; class=&quot;headerlink&quot; title=&quot;Map的架构&quot;&gt;&lt;/a&gt;Map的架构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/spurstong/
      
    
    </summary>
    
    
  </entry>
  
</feed>
