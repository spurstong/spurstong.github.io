<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>房东的小黑</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/spurstong/"/>
  <updated>2019-08-23T07:45:23.773Z</updated>
  <id>https://github.com/spurstong/</id>
  
  <author>
    <name>Mara Tong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring源码之bean标签的解析与注册</title>
    <link href="https://github.com/spurstong/2019/08/23/Spring%E6%BA%90%E7%A0%81%E4%B9%8Bbean%E6%A0%87%E7%AD%BE%E7%9A%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%B3%A8%E5%86%8C/"/>
    <id>https://github.com/spurstong/2019/08/23/Spring源码之bean标签的解析与注册/</id>
    <published>2019-08-23T07:35:00.000Z</published>
    <updated>2019-08-23T07:45:23.773Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇中，最后讲到了parseDefaultElement方法和parseCustomElement方法，对标签进行解析。先讲一下对bean标签的解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">            BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">            <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">                    BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">                    getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">                            bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Send registration event.</span></span><br><span class="line">                getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先委托BeanDefinitionDelegate类的parseBeanDefinitionElement方法进行元素解析，返回BeanDefinitionHolder类型的实例bdHolder,此时，bdHolder就已经包含配置文件中的配置的各种属性了，例如：class、name、id</li><li>当返回的bdHolder不为空时若存在默认标签的子节点下再有自定义属性，还需要对自定义标签进行解析。</li><li>解析完成后，需要对解析后的bdHolder进行注册，同样，注册操作委托给了BeanDefinitionReaderUtils的registerDefinition方法。</li><li>最后发出响应事件，通知相关的监听器，这个bean已经加载完成了。<br>下面依次解释每个步骤的含义。<h1 id="解析BeanDefinition"><a href="#解析BeanDefinition" class="headerlink" title="解析BeanDefinition"></a>解析BeanDefinition</h1>先解释一个类BeanDefinitionHolder，<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionHolder</span> <span class="keyword">implements</span> <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> BeanDefinition beanDefinition;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String[] aliases;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BeanDefinitionHolder</span><span class="params">(BeanDefinition beanDefinition, String beanName, @Nullable String[] aliases)</span> </span>&#123;</span><br><span class="line">                Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line">                Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinition = beanDefinition;</span><br><span class="line">                <span class="keyword">this</span>.beanName = beanName;</span><br><span class="line">                <span class="keyword">this</span>.aliases = aliases;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>从上面可以看出，BeanDefinition是BeanDefinition的一个持有者，并存储bean的姓名和别名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//解析id属性</span></span><br><span class="line">            String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">         <span class="comment">//解析name属性</span></span><br><span class="line">            String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">         <span class="comment">//分割name属性</span></span><br><span class="line">            List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">                String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">                aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String beanName = id;</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">                beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"No XML 'id' specified - using '"</span> + beanName +</span><br><span class="line">                            <span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">            <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                                    beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                            <span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">                            <span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">                            <span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">                            String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                            <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                    beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                                    !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                                aliases.add(beanClassName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                            logger.debug(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +</span><br><span class="line">                                    <span class="string">"using generated bean name ["</span> + beanName + <span class="string">"]"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                        error(ex.getMessage(), ele);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要步骤：</p><ol><li>提取元素中的id以及name属性</li><li>进一步解析其他所有属性并统一封装至GenericBeanDefinition类型中的实例中。</li><li>如果监测到bean没有指定的beanName,那儿使用默认规则为此Bean生成beanName</li><li>将获取到的信息封装到BeanDefinitionHolder的实例中。</li></ol><p>先简单介绍BeanDefinition这个接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A BeanDefinition describes a bean instance, which has property values,</span></span><br><span class="line"><span class="comment"> * constructor argument values, and further information supplied by</span></span><br><span class="line"><span class="comment"> * concrete implementations.</span></span><br><span class="line"><span class="comment"> *</span></span><br></pre></td></tr></table></figure><p>上面是源码文档解释，从上可以看出，它描述了一个bean实例，有属性值和构造函数参数值，具体的信息由具体的子类来实现。<br>在配置文件中&lt;bean&gt;元素拥有class、scope、lazy-init等配置属性，BeanDefinition则提供了相应的beanClass、Scope、lazyInit属性，BeanDefinition和&lt;bean&gt;中的元素一一对应。<br>具体的类RootBeanDefinition、GenericBeanDefinition和ChildBeanDefinition。<br>其中RootBeanDefinition是最常用的类，在配置文件中可以配置父&lt;bean&gt;和子&lt;bean&gt;,子&lt;bean&gt;用childBeanDefinition表示，没有子类时，直接用RootBeanDefinition表示。</p><p>Spring通过BeanDefinition将配置文件中的&lt;bean&gt;配置信息转化为容器的内部表示，并将这些BeanDefinition注册到BeanDefinitionRegistry中。Spring容器中的BeanDefinitionRegistry就像是Spring配置信息的内存数据库，主要是以map的形式保存，后续操作直接从BeanDefinitionRegistry中读取配置信息。</p><p><em>BeanDefinitionParserDelegate</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* Stateful delegate <span class="class"><span class="keyword">class</span> <span class="title">used</span> <span class="title">to</span> <span class="title">parse</span> <span class="title">XML</span> <span class="title">bean</span> <span class="title">definitions</span>.</span></span><br><span class="line"><span class="class"> * <span class="title">Intended</span> <span class="title">for</span> <span class="title">use</span> <span class="title">by</span> <span class="title">both</span> <span class="title">the</span> <span class="title">main</span> <span class="title">parser</span> <span class="title">and</span> <span class="title">any</span> <span class="title">extension</span></span></span><br></pre></td></tr></table></figure><p>从上面的定义中可以看出它是代表类，用于处理XML Bean定义的类，干的都是脏活累活。<br> import/alias/bean等element以及element的子节点以及属性都是它解析并且填充到BeanDefinition中然后使用ReaderContext中的Registry(实际就是DefaultListableBeanFactory)来将该BeanDefinition注册。</p><h1 id="Bean的注册"><a href="#Bean的注册" class="headerlink" title="Bean的注册"></a>Bean的注册</h1><p>Spring提供了BeanFactory对Bean进行获取，但Bean的注册和管理并不是在BeanFactory中进行，而是在BeanDefinitionRegistry中进行，这里BeanFactory只提供了查阅的功能。<br>Spring的Bean信息注册保存在一个个BeanDefinition中的。</p><p>我们以ClassPathXmlApplicationContext为例</p><ol><li>在它的构造函数中主要的逻辑方法有两个。<br>首先调用<em>setConfigLocations()</em>来设置配置文件路径并可以修改配置文件中的属性值。<br>然后调用<code>refresh()</code>方法。它是代码的核心，用来对Bean进行注册和初始化。</li><li>在refresh()方法中,主要有下面几个步骤</li></ol><ul><li>BeanFactory的初始化，并且加载配置文件中相关的bean信息。</li><li>调用<em>postProcessBeanFactory(beanFactory)</em>抽象方法，用于供给子类对已经生成的BeanFactory的一些信息进行定制，<em>registerBeanPostProcessors</em>对BeanPostProcessor进行注册。<br>BeanPostProcessor是一个扩展点，有两个方法，分别对应IOC容器对对象初始化前的操作和初始化后的操作。</li><li>初始化国际化信息</li><li>注册和调用相关的监听器</li><li>实例化注册的bean信息</li></ul><ol start="3"><li>对于bean的注册，我们需要关注<em>refreshBeanFactory()</em>方法，<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123; <span class="comment">// 如果BeanFactory已经创建则对其进行销毁</span></span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建BeanFactory实例</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId()); <span class="comment">// 为当前BeanFactory设置一个标识id</span></span><br><span class="line">        customizeBeanFactory(beanFactory); <span class="comment">// 设置BeanFacotry的定制化属性信息</span></span><br><span class="line">        loadBeanDefinitions(beanFactory); <span class="comment">// 加载xml文件信息</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>从中可以看出中间最重要的方法是<em>loadBeanDefinitions</em><br>将加载XML文件中的bean信息交给<strong>XmlBeanDefinitionReader</strong>来处理。<br>它会依次读取每个xml配置文件中的bean信息，<br>将xml文件转化为一个InputStream,再转化为InputSource,进而转化为一个Document对象，该对象保存着各个XML文件中各个节点和子节点的相关信息，然后获取到Document的根节点信息，调用<code>BeanDefinitionDocumentReader.registerBeanDefinitions(root)</code>进行注册。<br>然后开始解析xml文件，封装成BeanDefinition并完成注册，该点在文章开头已经讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一篇中，最后讲到了parseDefaultElement方法和parseCustomElement方法，对标签进行解析。先讲一下对bea
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring源码之Bean容器的基本实现</title>
    <link href="https://github.com/spurstong/2019/08/17/Spring%E6%BA%90%E7%A0%81%E4%B9%8BBean%E5%8A%A0%E8%BD%BD%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/spurstong/2019/08/17/Spring源码之Bean加载解析/</id>
    <published>2019-08-17T10:07:00.000Z</published>
    <updated>2019-08-17T12:26:01.126Z</updated>
    
    <content type="html"><![CDATA[<p>XmlBeanFactory继承自DefaultListableBeanFactory,而DefaultListableBeanFactory是整个bean加载的核心部分，是Spring注册及加载bean的默认实现，对于XmlBeanFactory,使用了自定义的XML读取器XmlBeanDefinitionReader,实现了个性化的BeanDefinitionReader读取。</p><a id="more"></a><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>作为Spring源码的第一篇，首先先简单介绍Spring的整体架构<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/Spring%E6%BA%90%E7%A0%81%E4%B9%8BBean%E5%8A%A0%E8%BD%BD/1.png" alt="1.png"></p><ol><li>Core Container(核心容器)<br>它包含了Core、Beans、Context和Expression Language模块。<br>Core和Beans模块是框架的基础部分，提供控制反转和依赖注入特性。基础概念是BeanFactory，它提供对Factory模式的经典实现来消除对程序性单例模式的需要，并真正地允许你从程序逻辑中分离出依赖关系和配置。Core模块主要包含Spring模块基本的核心工具类，Context模块构建于Core和Beans模块基础之上，提供一种类似于JDNI注册器的框架式的对象访问方法。ApplicationContext接口是Context模块的关键。</li><li>Data Access / Integration<br>包含了JDBC、ORM、OXM、JMS和Transaction模块。<br>ORM模块为流行的对象-关系映射API，如JPA、JDO、Hibernate、iBatis等，提供了一个交互层。</li><li>WEB<br>Web上下文模块建立在应用程序上下文模块之上，为基于Web的应用程序提供了上下文。</li><li>AOP<br>它让你可以定义例如方法拦截器和切点，从而将逻辑代码分开，降低它们之间的耦合性。Spring AOP模块为基于Spring的应用程序中的对象提供了事务管理服务，通过使用Spring AOP,不用依赖EJB组件，就可以将声明性事务管理集成到应用程序中。</li></ol><h1 id="Bean容器"><a href="#Bean容器" class="headerlink" title="Bean容器"></a>Bean容器</h1><p>bean是Spring中最核心的东西，因为Spring就像是个大水桶，而bean就像是容器中的水，水桶脱离了水也就没什么作用了。在这里我讲解一下利用读取XML文件进行Bean容器的基本实现。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/Spring%E6%BA%90%E7%A0%81%E4%B9%8BBean%E5%8A%A0%E8%BD%BD/2.png" alt="2.png"></p><p>核心类一： <em>DefaultListableBeanFactory</em></p><p>XmlBeanFactory继承自DefaultListableBeanFactory,而DefaultListableBeanFactory是整个bean加载的核心部分，是Spring注册及加载bean的默认实现，对于XmlBeanFactory,使用了自定义的XML读取器XmlBeanDefinitionReader,实现了个性化的BeanDefinitionReader读取。<br>现在先简单介绍上图中各个类的作用，具体的使用信息在后面的文章会讲到。</p><ul><li>singletonBeanRegistry: 定义对单例的注册及获取。</li><li>BeanFactory: 定义获取bean及bean的各种属性。</li><li>DefaultSingletonBeanRegistry: 对接口SingletonBeanRegistry各函数的实现。</li><li>HierarchicalBeanFactory: 继承BeanFactory,增加了对parentFactory的支持。</li><li>BeanDefinitionRegistry: 定义对BeanDefinition的各种增删改操作。</li><li>ConfigurableBeanFactory: 提供配置Factory的各种方法。</li><li>ListableBeanFactory: 根据各种 条件获取bean的配置清单。</li><li>AutowireCapableBeanFactory: 提供创建bean、自动注入、初始化以及应用bean的后处理器。<br>DefaultListableBeanFactory综合了上面的所有功能，主要是对bean注册后的处理。</li></ul><p>XmlBeanFactory对DefaultListableBeanFactory类进行了扩展，主要用于从XML文档中读取BeanDefinition,以及注册及获取bean。</p><p>核心类二：  XmlBeanDefinitionReader<br>对资源文件进行读取、解析及注册<br>简单介绍该类继承的抽象类和接口</p><ul><li>ResourceLoader: 定义资源加载器，主要应用于根据给定的资源文件地址返回对应的Resource.</li><li>BeanDefinitionReader: 主要定义资源文件读取并转换为BeanDefinition的各个功能。</li><li>BeanDefinitionDocumentReader: 定义读取Document并注册BeanDefinition.<h1 id="容器的基础XmlBeanFactory"><a href="#容器的基础XmlBeanFactory" class="headerlink" title="容器的基础XmlBeanFactory"></a>容器的基础XmlBeanFactory</h1>当前获取创建beanFactory的代码如下<blockquote><p>BeanFactory bf = new XmlBeanFactory(new ClassPathResource(“beanFactoryTest.xml”))</p></blockquote></li></ul><p>首先，读取配置文件，用ClassPathResource进行封装。<br>在Java中，将不同来源的资源抽象成URL,通过注册不同的handler来处理不同来源的资源的读取逻辑。Spring抽象出一个统一的接口来对这些底层资源进行统一访问,即Resource.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InputStreamSource</span> </span>&#123; </span><br><span class="line"><span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span> <span class="keyword">extends</span> <span class="title">InputStreamSource</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function">URL <span class="title">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line">    <span class="function">URI <span class="title">getURI</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line">    <span class="function">File <span class="title">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line">    <span class="function">Resource <span class="title">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException</span>; </span><br><span class="line">    <span class="function">String <span class="title">getFilename</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对不同来源的资源文件都有相应的Resource实现： </p><ul><li>文件 FileSystemResource</li><li>Classpath资源  ClassPathResource</li><li>URL资源 UrlResource</li><li>InputStream资源 InputStreamResource</li><li>Byte数组  ByteArrayResource </li></ul><ol><li>XmlBeanFactory loadBeanDefinitions(Resource)  –&gt; 进行资源加载</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(resource, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">XmlBeanFactory</span><span class="params">(Resource resource, BeanFactory parentBeanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(parentBeanFactory);</span><br><span class="line">            <span class="keyword">this</span>.reader.loadBeanDefinitions(resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可知，主要加载Bean的步骤</p><ul><li>封装资源文件，当进入XmlBeanDefinitionReader后首先对参数Resource使用EncodedResource类进行封装。</li><li>获取输入流。从Resource中获取对应的InputStream并构造InputSource</li><li>通过构造的InputSource实例和Resource实例继续调用函数doLoadBeanDefinitions.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">            Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource);</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="comment">//通过属性来记录已经加载的资源</span></span><br><span class="line">            Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">            <span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">                currentResources = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">                <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                        <span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//从encodedResource中获取封装的Resource对象并再次从Resource中获取其中的inputStream</span></span><br><span class="line">                InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">                    <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//代码的核心方法</span></span><br><span class="line">                    <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    inputStream.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">                        <span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">                currentResources.remove(encodedResource);</span><br><span class="line">                <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><em>核心代码doLoadBeanDefinitions</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">                <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (SAXParseException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                        <span class="string">"Line "</span> + ex.getLineNumber() + <span class="string">" in XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (SAXException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                        <span class="string">"XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                        <span class="string">"Parser configuration exception parsing XML from "</span> + resource, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                        <span class="string">"IOException parsing XML document from "</span> + resource, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</span><br><span class="line">                        <span class="string">"Unexpected exception parsing XML document from "</span> + resource, ex);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要步骤：</p><ol><li>获取对XML文件的检验方式</li><li>加载XML文件，并得到对应的Document.</li><li>根据返回的Document注册Bean信息。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">           <span class="comment">//为DefaultBeanDefinitionDocumentReader</span></span><br><span class="line">            BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">           <span class="comment">//记录统计前的BeanDefinition</span></span><br><span class="line">            <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">          <span class="comment">//加载及注册Bean</span></span><br><span class="line">            documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">         <span class="comment">//记录本次加载的BeanDefinition个数。</span></span><br><span class="line">            <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后调用DefaultBeanDefinitionDocumentReader的registerBeanDefinitions()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">            logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">            Element root = doc.getDocumentElement();</span><br><span class="line">            doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，下面是最最最核心的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line"><span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line"><span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line"><span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line"><span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line"><span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">           <span class="comment">//专门处理解析</span></span><br><span class="line">            BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">            <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">                String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">                    String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                            profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">                    <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                            logger.info(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec +</span><br><span class="line">                                    <span class="string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//解析前处理</span></span><br><span class="line">            preProcessXml(root);</span><br><span class="line">            parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">            <span class="comment">//解析后处理</span></span><br><span class="line">            postProcessXml(root);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>preProcessXml和postProcessXml是两个抽象方法，是为了子类而设计的，这是设计模式的模板方法模式，如果子类想在Bean解析前后做一些处理，那么只需处理这两个方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">                NodeList nl = root.getChildNodes();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">                    Node node = nl.item(i);</span><br><span class="line">                    <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                        Element ele = (Element) node;</span><br><span class="line">                        <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                            <span class="comment">//对bean处理。</span></span><br><span class="line">                            parseDefaultElement(ele, delegate);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//对bean处理</span></span><br><span class="line">                            delegate.parseCustomElement(ele);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                delegate.parseCustomElement(root);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>如果采用Spring默认的配置，Spring当然知道怎么做，但是如果是自定义的,那么就需要用户实现一些接口及配置了。具体的元素解析在下一篇编写。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;XmlBeanFactory继承自DefaultListableBeanFactory,而DefaultListableBeanFactory是整个bean加载的核心部分，是Spring注册及加载bean的默认实现，对于XmlBeanFactory,使用了自定义的XML读取器XmlBeanDefinitionReader,实现了个性化的BeanDefinitionReader读取。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Dubbo之心跳机制</title>
    <link href="https://github.com/spurstong/2019/08/09/Dubbo%E4%B9%8B%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/"/>
    <id>https://github.com/spurstong/2019/08/09/Dubbo之心跳机制/</id>
    <published>2019-08-09T08:40:00.000Z</published>
    <updated>2019-08-16T11:01:44.491Z</updated>
    
    <content type="html"><![CDATA[<p>在网络传输中，怎么确保通道连接的可用性是一个很重要的问题，简单的说，在网络通信中有客户端和服务端，一个负责发送请求，一个负责接收请求，在保证连接有效性的背景下，这两个物体扮演了什么角色，心跳机制能有效的保证连接的可用性，那它的机制是什么，下文中将会详细讲解。</p><a id="more"></a><p>在网络传输中，怎么确保通道连接的可用性是一个很重要的问题，简单的说，在网络通信中有客户端和服务端，一个负责发送请求，一个负责接收请求，在保证连接有效性的背景下，这两个物体扮演了什么角色，心跳机制能有效的保证连接的可用性，那它的机制是什么，下文中将会详细讲解。</p><h1 id="网络层的可用性"><a href="#网络层的可用性" class="headerlink" title="网络层的可用性"></a>网络层的可用性</h1><p>首先讲一下TCP,在dubbo中的通信是基于TCP的，TCP本身并没有长短连接的区别，在短连接中，每次通信时，都会创建Socket,当该次通信结束后，就会调用socket.close()；而在长连接中，每次通信完毕后，不会关闭连接，这样就可以做到连接的复用，长连接的好处是省去了创建连接时的耗时。那么如何确保连接的有效性呢，在TCP中用到了<strong>KeepAlive机制</strong>，keepalive并不是TCP协议的一部分，但是大多数操作系统都实现了这个机制，在一定时间内，在链路上如果<strong>没有数据传送的情况下</strong>，TCP层将会发送相应的keepalive探针来确定连接可用性，探测失败后重试10次（<code>tcp_keepalive_probes</code>）,每次间隔时间为75s(<code>tcp_keepalive_intvl</code>),所有探测失败后，才认为当前连接已经不可用了。</p><p>KeepAlive机制是在网络层保证了连接的可用性，但在应用层我们认为这还是不够的。</p><ul><li>KeepAlive的报活机制只有在链路空闲的情况下才会起作用，假如此时有数据发送，且物理链路已经不通，操作系统这边的链路状态还是E    STABLISHED,这时会发生TCP重传机制，要知道默认的TCP超时重传，指数退避算法也是一个相当长的过程。</li><li>KeepAlive本身是面向网络的，并不是面向于应用的，可能是由于本身GC问题，系统load高等情况，但网络依然是通的，此时，应用已经失去了活性，所以连接自然认为是不可用的。<h1 id="应用层的连接可用性：心跳机制"><a href="#应用层的连接可用性：心跳机制" class="headerlink" title="应用层的连接可用性：心跳机制"></a>应用层的连接可用性：心跳机制</h1>如何理解应用层的心跳？简单的说，就是客户端会开启一个<strong>定时任务</strong>，定时对已经建立连接的对端应用发送请求，服务端则需要特殊处理该请求，返回响应。如果心跳持续多次没有收到响应，客户端会认为连接不可用，主动断开连接。</li></ul><h2 id="客户端如何得知请求失败了？"><a href="#客户端如何得知请求失败了？" class="headerlink" title="客户端如何得知请求失败了？"></a>客户端如何得知请求失败了？</h2><p>在失败的场景下，服务端是不会返回响应的，所以只能在客户端自身上设计了。<br>当客户端发起一个RPC请求时，会设置一个超时时间client_timeout,同时它也会开启一个延迟的client_timeout的定时器。当接收到正常响应时，会移除该定时器；而当计时器倒计时完毕后，还没有被移除，则会认为请求超时，构造一个失败的响应传递给客户端。</p><h2 id="连接建立时创建定时器"><a href="#连接建立时创建定时器" class="headerlink" title="连接建立时创建定时器"></a>连接建立时创建定时器</h2><p>HeaderExchangeClient类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeClient</span><span class="params">(Client client, <span class="keyword">boolean</span> needHeartbeat)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"client == null"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">this</span>.client = client;</span><br><span class="line">       <span class="comment">// 创建信息交换通道</span></span><br><span class="line">       <span class="keyword">this</span>.channel = <span class="keyword">new</span> HeaderExchangeChannel(client);</span><br><span class="line">       <span class="comment">// 获得dubbo版本</span></span><br><span class="line">       String dubbo = client.getUrl().getParameter(Constants.DUBBO_VERSION_KEY);</span><br><span class="line">       <span class="comment">//获得心跳周期配置，如果没有配置，并且dubbo是1.0版本的，则这只为1分钟，否则设置为0</span></span><br><span class="line">       <span class="keyword">this</span>.heartbeat = client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo != <span class="keyword">null</span> &amp;&amp; dubbo.startsWith(<span class="string">"1.0."</span>) ? Constants.DEFAULT_HEARTBEAT : <span class="number">0</span>);</span><br><span class="line">       <span class="comment">// 获得心跳超时配置，默认是心跳周期的三倍</span></span><br><span class="line">       <span class="keyword">this</span>.heartbeatTimeout = client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * <span class="number">3</span>);</span><br><span class="line">       </span><br><span class="line">       <span class="keyword">if</span> (needHeartbeat) &#123;</span><br><span class="line">           <span class="comment">// 开启心跳</span></span><br><span class="line">         <span class="keyword">long</span> tickDuration = calculateLeastDuration(heartbeat);</span><br><span class="line">         heartbeatTimer = <span class="keyword">new</span> HashedWheelTimer(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"dubbo-client-heartbeat"</span>, <span class="keyword">true</span>) , tickDuration, TimeUnit.MILLISECONDS, Constants.TICKS_PER_WHEEL);</span><br><span class="line">         startHeartbeatTimer();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>创建了一个<code>HashedWheelTimer</code>开启心跳检测，这是 Netty 所提供的一个经典的时间轮定时器实现。</p><p><code>HeaderExchangeServer</code>也同时开启了定时器，代码逻辑和上述差不多。</p><h2 id="开启两个定时任务"><a href="#开启两个定时任务" class="headerlink" title="开启两个定时任务"></a>开启两个定时任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeartbeatTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> heartbeatTick = calculateLeastDuration(heartbeat); </span><br><span class="line">   <span class="keyword">long</span> heartbeatTimeoutTick = calculateLeastDuration(heartbeatTimeout);</span><br><span class="line">   HeartbeatTimerTask heartBeatTimerTask =<span class="keyword">new</span>  HeartbeatTimerTask(cp, heartbeatTick, heartbeat);</span><br><span class="line">   ReconnectTimerTask reconnectTimerTask = <span class="keyword">new</span> ReconnectTimerTask(cp, heartbeatTimeoutTick, heartbeatTimeout);</span><br><span class="line">    </span><br><span class="line">  heartbeatTimer.newTimeout(heartBeatTimerTask, heartbeatTick, TimeUnit.MILLISECONDS); </span><br><span class="line">  heartbeatTimer.newTimeout(reconnectTimerTask, heartbeatTimeoutTick, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在该方法中主要开启了两个定时器</p><ul><li><em>HeartbeatTimerTask</em> 主要是定时发送心跳请求</li><li><em>ReconnectTimerTask</em> 主要是心跳失败后处理重连，断连的逻辑</li></ul><h1 id="旧版的心跳处理HeartBeatTask类"><a href="#旧版的心跳处理HeartBeatTask类" class="headerlink" title="旧版的心跳处理HeartBeatTask类"></a>旧版的心跳处理HeartBeatTask类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HeartBeatTask.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通道管理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ChannelProvider channelProvider;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳间隔 单位：ms</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳超时时间 单位：ms</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeatTimeout;</span><br><span class="line"></span><br><span class="line">    HeartBeatTask(ChannelProvider provider, <span class="keyword">int</span> heartbeat, <span class="keyword">int</span> heartbeatTimeout) &#123;</span><br><span class="line">        <span class="keyword">this</span>.channelProvider = provider;</span><br><span class="line">        <span class="keyword">this</span>.heartbeat = heartbeat;</span><br><span class="line">        <span class="keyword">this</span>.heartbeatTimeout = heartbeatTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 遍历所有通道</span></span><br><span class="line">            <span class="keyword">for</span> (Channel channel : channelProvider.getChannels()) &#123;</span><br><span class="line">                <span class="comment">// 如果通道关闭了，则跳过</span></span><br><span class="line">                <span class="keyword">if</span> (channel.isClosed()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 最后一次接收到消息的时间戳</span></span><br><span class="line">                    Long lastRead = (Long) channel.getAttribute(</span><br><span class="line">                            HeaderExchangeHandler.KEY_READ_TIMESTAMP);</span><br><span class="line">                    <span class="comment">// 最后一次发送消息的时间戳</span></span><br><span class="line">                    Long lastWrite = (Long) channel.getAttribute(</span><br><span class="line">                            HeaderExchangeHandler.KEY_WRITE_TIMESTAMP);</span><br><span class="line">                    <span class="comment">// 如果最后一次接收或者发送消息到时间到现在的时间间隔超过了心跳间隔时间</span></span><br><span class="line">                    <span class="keyword">if</span> ((lastRead != <span class="keyword">null</span> &amp;&amp; now - lastRead &gt; heartbeat)</span><br><span class="line">                            || (lastWrite != <span class="keyword">null</span> &amp;&amp; now - lastWrite &gt; heartbeat)) &#123;</span><br><span class="line">                        <span class="comment">// 创建一个request</span></span><br><span class="line">                        Request req = <span class="keyword">new</span> Request();</span><br><span class="line">                        <span class="comment">// 设置版本号</span></span><br><span class="line">                        req.setVersion(Version.getProtocolVersion());</span><br><span class="line">                        <span class="comment">// 设置需要得到响应</span></span><br><span class="line">                        req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="comment">// 设置事件类型，为心跳事件</span></span><br><span class="line">                        req.setEvent(Request.HEARTBEAT_EVENT);</span><br><span class="line">                        <span class="comment">// 发送心跳请求</span></span><br><span class="line">                        channel.send(req);</span><br><span class="line">                        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                            logger.debug(<span class="string">"Send heartbeat to remote channel "</span> + channel.getRemoteAddress()</span><br><span class="line">                                    + <span class="string">", cause: The channel has no data-transmission exceeds a heartbeat period: "</span> + heartbeat + <span class="string">"ms"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果最后一次接收消息的时间到现在已经超过了超时时间</span></span><br><span class="line">                    <span class="keyword">if</span> (lastRead != <span class="keyword">null</span> &amp;&amp; now - lastRead &gt; heartbeatTimeout) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"Close channel "</span> + channel</span><br><span class="line">                                + <span class="string">", because heartbeat read idle time out: "</span> + heartbeatTimeout + <span class="string">"ms"</span>);</span><br><span class="line">                        <span class="comment">// 如果该通道是客户端，也就是请求的服务器挂掉了，客户端尝试重连服务器</span></span><br><span class="line">                        <span class="keyword">if</span> (channel <span class="keyword">instanceof</span> Client) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 重新连接服务器</span></span><br><span class="line">                                ((Client) channel).reconnect();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                <span class="comment">//do nothing</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 如果不是客户端，也就是是服务端返回响应给客户端，但是客户端挂掉了，则服务端关闭客户端连接</span></span><br><span class="line">                            channel.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Exception when heartbeat to remote channel "</span> + channel.getRemoteAddress(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Unhandled exception when heartbeat, cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ChannelProvider</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得所有的通道集合，需要心跳的通道数组</span></span><br><span class="line">        <span class="function">Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它首先遍历所有的Channel,在服务端对用的是所有客户端连接，在客户端对应的是服务端连接，判断当前TCP连接是否空闲，如果<strong>空闲</strong>就发送心跳报文，判断是否空闲，根据Channel是否有读或写来决定，比如一分钟内没有读或写就发送心跳报文，然后是处理超时的问题，处理客户端超时重新建立TCP连接，目前的策略是检查是否在3分钟内都没有成功接受或发送报文，如果在服务端检测则就会主动关闭远程客户端连接。</p><h1 id="新版本的心跳机制"><a href="#新版本的心跳机制" class="headerlink" title="新版本的心跳机制"></a>新版本的心跳机制</h1><h2 id="定时任务一：-发送心跳请求"><a href="#定时任务一：-发送心跳请求" class="headerlink" title="定时任务一： 发送心跳请求"></a>定时任务一： 发送心跳请求</h2><p>在新版本下，去除了HeartBeatTask类,添加了HeartbeatTimerTask和ReconnectTimerTask类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartbeatTimerTask</span> <span class="keyword">extends</span> <span class="title">AbstractTimerTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HeartbeatTimerTask.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> heartbeat;</span><br><span class="line"></span><br><span class="line">    HeartbeatTimerTask(ChannelProvider channelProvider, Long heartbeatTick, <span class="keyword">int</span> heartbeat) &#123;</span><br><span class="line">        <span class="keyword">super</span>(channelProvider, heartbeatTick);</span><br><span class="line">        <span class="keyword">this</span>.heartbeat = heartbeat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long lastRead = lastRead(channel);</span><br><span class="line">            Long lastWrite = lastWrite(channel);</span><br><span class="line">            <span class="keyword">if</span> ((lastRead != <span class="keyword">null</span> &amp;&amp; now() - lastRead &gt; heartbeat)</span><br><span class="line">                    || (lastWrite != <span class="keyword">null</span> &amp;&amp; now() - lastWrite &gt; heartbeat)) &#123;</span><br><span class="line">                Request req = <span class="keyword">new</span> Request();</span><br><span class="line">                req.setVersion(Version.getProtocolVersion());</span><br><span class="line">                req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">                req.setEvent(Request.HEARTBEAT_EVENT);</span><br><span class="line">                channel.send(req);</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Send heartbeat to remote channel "</span> + channel.getRemoteAddress()</span><br><span class="line">                            + <span class="string">", cause: The channel has no data-transmission exceeds a heartbeat period: "</span></span><br><span class="line">                            + heartbeat + <span class="string">"ms"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception when heartbeat to remote channel "</span> + channel.getRemoteAddress(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Dubbo采取的是双向心跳设计，即服务端会向客户端发送心跳，客户端也会向服务端发送心跳，接收的一方更新lastread字段，发送的一方更新lastWrite字段，超过心跳间隙的时间，便发送心跳请求给对端。</p><h2 id="定时任务二：-处理重连和断连"><a href="#定时任务二：-处理重连和断连" class="headerlink" title="定时任务二： 处理重连和断连"></a>定时任务二： 处理重连和断连</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReconnectTimerTask</span> <span class="keyword">extends</span> <span class="title">AbstractTimerTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ReconnectTimerTask.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> idleTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReconnectTimerTask</span><span class="params">(ChannelProvider channelProvider, Long heartbeatTimeoutTick, <span class="keyword">int</span> idleTimeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(channelProvider, heartbeatTimeoutTick);</span><br><span class="line">        <span class="keyword">this</span>.idleTimeout = idleTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long lastRead = lastRead(channel);</span><br><span class="line">            Long now = now();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Rely on reconnect timer to reconnect when AbstractClient.doConnect fails to init the connection</span></span><br><span class="line">            <span class="keyword">if</span> (!channel.isConnected()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    logger.info(<span class="string">"Initial connection to "</span> + channel);</span><br><span class="line">                    ((Client) channel).reconnect();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Fail to connect to "</span> + channel, e);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// check pong at client</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastRead != <span class="keyword">null</span> &amp;&amp; now - lastRead &gt; idleTimeout) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Reconnect to channel "</span> + channel + <span class="string">", because heartbeat read idle time out: "</span></span><br><span class="line">                        + idleTimeout + <span class="string">"ms"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ((Client) channel).reconnect();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.error(channel + <span class="string">"reconnect failed during idle time."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception when reconnect to remote channel "</span> + channel.getRemoteAddress(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不同类型处理机制不同，当超过设置的心跳总时间后，客户端选择的是重新连接，服务端是选择直接断开连接。</p><h1 id="心跳改进方案"><a href="#心跳改进方案" class="headerlink" title="心跳改进方案"></a>心跳改进方案</h1><p>Netty对空闲连接的检测提供了天然的支持，使用IdleStateHandler可以很方便的实现空闲检测逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(<span class="keyword">long</span> readerIdleTime, <span class="keyword">long</span> writerIdleTime, <span class="keyword">long</span> allIdleTime, TimeUnit unit)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>readerIdleTime: 读超时的时间</li><li>writerIdleTime: 写超时的时间</li><li>allIdleTime: 所有类型的超时时间<br>客户端和服务端配置<br>客户端：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="string">"clientIdleHandler"</span>, <span class="keyword">new</span> IdleStateHandler(<span class="number">60</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="string">"serverIdleHandler"</span>,<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面看出，客户端配置了read超时为60s，服务端配置了write/read超时未200s，</p><h2 id="空闲超时逻辑-客户端"><a href="#空闲超时逻辑-客户端" class="headerlink" title="空闲超时逻辑-客户端"></a>空闲超时逻辑-客户端</h2><p>对于空闲超时的处理逻辑，客户端和服务端是不同的，首先来看客户端的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        <span class="comment">// send heartbeat</span></span><br><span class="line">        sendHeartBeat();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检测到空闲超时后，采取的行为是向服务端发送心跳包，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendHeartBeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Invocation invocation = <span class="keyword">new</span> Invocation();</span><br><span class="line">    invocation.setInvocationType(InvocationType.HEART_BEAT);</span><br><span class="line">    channel.writeAndFlush(invocation).addListener(<span class="keyword">new</span> CallbackFuture() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(Future future)</span> </span>&#123;</span><br><span class="line">            RPCResult result = future.get();</span><br><span class="line">            <span class="comment">//超时 或者 写失败</span></span><br><span class="line">            <span class="keyword">if</span> (result.isError()) &#123;</span><br><span class="line">                channel.addFailedHeartBeatTimes();</span><br><span class="line">                <span class="keyword">if</span> (channel.getFailedHeartBeatTimes() &gt;= channel.getMaxHeartBeatFailedTimes()) &#123;</span><br><span class="line">                    channel.reconnect();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel.clearHeartBeatFailedTimes();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造一个心跳包发送到服务端，接受响应结果</p><ul><li>响应成功，清除请求失败标记</li><li>响应失败，心跳失败标记+1，如果超过配置的失败次数，则重新连接<h2 id="空闲超时逻辑-服务端"><a href="#空闲超时逻辑-服务端" class="headerlink" title="空闲超时逻辑 - 服务端"></a>空闲超时逻辑 - 服务端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>服务端直接关闭连接。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在网络传输中，怎么确保通道连接的可用性是一个很重要的问题，简单的说，在网络通信中有客户端和服务端，一个负责发送请求，一个负责接收请求，在保证连接有效性的背景下，这两个物体扮演了什么角色，心跳机制能有效的保证连接的可用性，那它的机制是什么，下文中将会详细讲解。&lt;/p&gt;
    
    </summary>
    
      <category term="dubbo" scheme="https://github.com/spurstong/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="https://github.com/spurstong/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo-服务注册中心之AbstractRegistry</title>
    <link href="https://github.com/spurstong/2019/07/29/Dubbo-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8BAbstractRegistry/"/>
    <id>https://github.com/spurstong/2019/07/29/Dubbo-服务注册中心之AbstractRegistry/</id>
    <published>2019-07-29T14:34:00.000Z</published>
    <updated>2019-08-16T11:01:22.863Z</updated>
    
    <content type="html"><![CDATA[<p>在dubbo中，关于注册中心Registry的有关实现封装在了dubbo-registry模块中。提供者（Provider）个消费者（Consumer）都是通过注册中心进行资源的调度。当服务启动时，provider会调用注册中心的register方法将自己的服务通过url的方式发布到注册中心，而consumer订阅其他服务时,会将订阅的服务通过url发送给注册中心（URL中通常会包含各种配置）。当某个服务被关闭时，它则会从注册中心中移除，当某个服务被修改时，则会调用notify方法触发所有的监听器。</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/Dubbo-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8BAbstractRegistry/1.png" alt="1.png"><br>在dubbo中，关于注册中心Registry的有关实现封装在了dubbo-registry模块中。提供者（Provider）个消费者（Consumer）都是通过注册中心进行资源的调度。当服务启动时，provider会调用注册中心的register方法将自己的服务通过url的方式发布到注册中心，而consumer订阅其他服务时,会将订阅的服务通过url发送给注册中心（URL中通常会包含各种配置）。当某个服务被关闭时，它则会从注册中心中移除，当某个服务被修改时，则会调用notify方法触发所有的监听器。<br>首先简单介绍一下在dubbo的基本统一数据模型URL</p><h1 id="统一数据模型URL"><a href="#统一数据模型URL" class="headerlink" title="统一数据模型URL"></a>统一数据模型URL</h1><p>在dubbo中定义的url与传统的url有所不同，用于在扩展点之间传输数据，可以从url参数中获取配置信息等数据，这一点很重要。<br>描述一个dubbo协议的服务</p><blockquote><p>dubbo://192.168.1.6:20880/moe.cnkirito.sample.HelloService?timeout=3000</p></blockquote><p>描述一个消费者</p><blockquote><p>consumer://30.5.120.217/org.apache.dubbo.demo.DemoService?application=demo-consumer&amp;category=consumers&amp;check=false&amp;dubbo=2.0.2&amp;interface=org.apache.dubbo.demo.DemoService&amp;methods=sayHello&amp;pid=1209&amp;qos.port=33333&amp;side=consumer&amp;timestamp=1545721827784</p></blockquote><p>接下来将着重介绍几个重要的类。</p><h1 id="AbstractRegistry"><a href="#AbstractRegistry" class="headerlink" title="AbstractRegistry"></a>AbstractRegistry</h1><p>AbstractRegistry实现的是Registry接口，是Registry的抽象类。为了减轻注册中心的压力，在该类中实现了把本地url缓存到内存缓存property文件中，并且实现了注册中心的注册、订阅等方法。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/Dubbo-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%B9%8BAbstractRegistry/2.png" alt="2.png"><br>在该类中有介个关于url的变量。</p><ul><li><code>private final Set&lt;URL&gt; registered = new ConcurrentHashSet&lt;URL&gt;();</code><pre><code>-&gt; 记录已经注册服务的URL集合，注册的URL不仅仅可以是服务提供者的，也可以是服务消费者的。</code></pre></li><li><code>private final ConcurrentMap&lt;URL, Set&lt;NotifyListener&gt;&gt; subscribed = new ConcurrentHashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;();</code> <pre><code>-&gt; 消费者url订阅的监听器集合</code></pre></li><li><code>private final ConcurrentMap&lt;URL, Map&lt;String, List&lt;URL&gt;&gt;&gt; notified = new ConcurrentHashMap&lt;URL, Map&lt;String, List&lt;URL&gt;&gt;&gt;();</code><br> -&gt; 某个消费者被通知的服务URL集合，最外部URL的key是消费者的URL,value是一个map集合，里面的map中的key为分类名，value是该类下的服务url集合。</li><li><code>private URL registryUrl;</code><br>  -&gt; 注册中心URL</li><li><code>private File file;</code> <pre><code>-&gt; 本地磁盘缓存文件，缓存注册中心的数据</code></pre><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">AbstractRegistry</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 设置配置中心的地址</span></span><br><span class="line">    setUrl(url);</span><br><span class="line">    <span class="comment">//2. 配置中心的URL中是否配置了同步保存文件属性，否则默认为false</span></span><br><span class="line">    syncSaveFile = url.getParameter(Constants.REGISTRY_FILESAVE_SYNC_KEY, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//3. 配置信息本地缓存的文件名</span></span><br><span class="line">    String filename = url.getParameter(Constants.FILE_KEY, System.getProperty(<span class="string">"user.home"</span>) + <span class="string">"/.dubbo/dubbo-registry-"</span> + url.getParameter(Constants.APPLICATION_KEY) + <span class="string">"-"</span> + url.getAddress() + <span class="string">".cache"</span>);</span><br><span class="line">    <span class="comment">//逐层创建文件目录</span></span><br><span class="line">    File file = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (ConfigUtils.isNotEmpty(filename)) &#123;</span><br><span class="line">        file = <span class="keyword">new</span> File(filename);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists() &amp;&amp; file.getParentFile() != <span class="keyword">null</span> &amp;&amp; !file.getParentFile().exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!file.getParentFile().mkdirs()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid registry store file "</span> + file + <span class="string">", cause: Failed to create directory "</span> + file.getParentFile() + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.file = file;</span><br><span class="line">    <span class="comment">//如果现有配置缓存，则从缓存文件中加载属性</span></span><br><span class="line">    loadProperties();</span><br><span class="line">    notify(url.getBackupUrls());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>加载本地磁盘缓存文件到内存缓存中，也就是把文件中的数据写入到properties中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (file != <span class="keyword">null</span> &amp;&amp; file.exists()) &#123;</span><br><span class="line">           InputStream in = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               in = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">               <span class="comment">// 把数据写入到内存缓存中</span></span><br><span class="line">               properties.load(in);</span><br><span class="line">               <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                   logger.info(<span class="string">"Load registry store file "</span> + file + <span class="string">", data: "</span> + properties);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">               logger.warn(<span class="string">"Failed to load registry store file "</span> + file, e);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       in.close();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                       logger.warn(e.getMessage(), e);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="注册与取消注册"><a href="#注册与取消注册" class="headerlink" title="注册与取消注册"></a>注册与取消注册</h1><p>对registered变量执行add和remove操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"register url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Register: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        registered.add(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"unregister url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Unregister: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        registered.remove(url);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="订阅与取消订阅"><a href="#订阅与取消订阅" class="headerlink" title="订阅与取消订阅"></a>订阅与取消订阅</h1><p>通过消费者url从subscribed变量中获取该消费者的所有监听器集合，然后将该监听器放入到集合中，取消同理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"subscribe url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"subscribe listener == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Subscribe: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得该消费者url 已经订阅的服务 的监听器集合</span></span><br><span class="line">        Set&lt;NotifyListener&gt; listeners = subscribed.get(url);</span><br><span class="line">        <span class="keyword">if</span> (listeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">            subscribed.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashSet&lt;NotifyListener&gt;());</span><br><span class="line">            listeners = subscribed.get(url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加某个服务的监听器</span></span><br><span class="line">        listeners.add(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">(URL url, NotifyListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"unsubscribe url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"unsubscribe listener == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Unsubscribe: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;NotifyListener&gt; listeners = subscribed.get(url);</span><br><span class="line">        <span class="keyword">if</span> (listeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            listeners.remove(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="服务的恢复"><a href="#服务的恢复" class="headerlink" title="服务的恢复"></a>服务的恢复</h1><p>注册的恢复包括注册服务的恢复和订阅服务的恢复，因为在内存中表留了注册的服务和订阅的服务，因此在恢复的时候会重新拉取这些数据，分别调用发布和订阅的方法来重新将其录入到注册中心中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">recover</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// register</span></span><br><span class="line">        <span class="comment">//把内存缓存中的registered取出来遍历进行注册</span></span><br><span class="line">        Set&lt;URL&gt; recoverRegistered = <span class="keyword">new</span> HashSet&lt;URL&gt;(getRegistered());</span><br><span class="line">        <span class="keyword">if</span> (!recoverRegistered.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Recover register url "</span> + recoverRegistered);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (URL url : recoverRegistered) &#123;</span><br><span class="line">                register(url);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// subscribe</span></span><br><span class="line">        <span class="comment">//把内存缓存中的subscribed取出来遍历进行订阅</span></span><br><span class="line">        Map&lt;URL, Set&lt;NotifyListener&gt;&gt; recoverSubscribed = <span class="keyword">new</span> HashMap&lt;URL, Set&lt;NotifyListener&gt;&gt;(getSubscribed());</span><br><span class="line">        <span class="keyword">if</span> (!recoverSubscribed.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                logger.info(<span class="string">"Recover subscribe url "</span> + recoverSubscribed.keySet());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : recoverSubscribed.entrySet()) &#123;</span><br><span class="line">                URL url = entry.getKey();</span><br><span class="line">                <span class="keyword">for</span> (NotifyListener listener : entry.getValue()) &#123;</span><br><span class="line">                    subscribe(url, listener);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 遍历订阅URL的监听器集合，通知他们</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;URL, Set&lt;NotifyListener&gt;&gt; entry : getSubscribed().entrySet()) &#123;</span><br><span class="line">            URL url = entry.getKey();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 匹配</span></span><br><span class="line">            <span class="keyword">if</span> (!UrlUtils.isMatch(url, urls.get(<span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历监听器集合，通知他们</span></span><br><span class="line">            Set&lt;NotifyListener&gt; listeners = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (listeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (NotifyListener listener : listeners) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        notify(url, listener, filterEmpty(url, urls));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        logger.error(<span class="string">"Failed to notify registry event, urls: "</span> + urls + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知监听器，URL 变化结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> listener</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> urls</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(URL url, NotifyListener listener, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify url == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"notify listener == null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((urls == <span class="keyword">null</span> || urls.isEmpty())</span><br><span class="line">                &amp;&amp; !Constants.ANY_VALUE.equals(url.getServiceInterface())) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Ignore empty notify urls for subscribe url "</span> + url);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(<span class="string">"Notify urls for subscribe url "</span> + url + <span class="string">", urls: "</span> + urls);</span><br><span class="line">        &#125;</span><br><span class="line">        Map&lt;String, List&lt;URL&gt;&gt; result = <span class="keyword">new</span> HashMap&lt;String, List&lt;URL&gt;&gt;();</span><br><span class="line">        <span class="comment">// 将urls进行分类</span></span><br><span class="line">        <span class="keyword">for</span> (URL u : urls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UrlUtils.isMatch(url, u)) &#123;</span><br><span class="line">                <span class="comment">// 按照url中key为category对应的值进行分类，如果没有该值，就找key为providers的值进行分类</span></span><br><span class="line">                String category = u.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);</span><br><span class="line">                List&lt;URL&gt; categoryList = result.get(category);</span><br><span class="line">                <span class="keyword">if</span> (categoryList == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    categoryList = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">                    <span class="comment">// 分类结果放入result</span></span><br><span class="line">                    result.put(category, categoryList);</span><br><span class="line">                &#125;</span><br><span class="line">                categoryList.add(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得某一个消费者被通知的url集合（通知的 URL 变化结果）</span></span><br><span class="line">        Map&lt;String, List&lt;URL&gt;&gt; categoryNotified = notified.get(url);</span><br><span class="line">        <span class="keyword">if</span> (categoryNotified == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 添加该消费者对应的url</span></span><br><span class="line">            notified.putIfAbsent(url, <span class="keyword">new</span> ConcurrentHashMap&lt;String, List&lt;URL&gt;&gt;());</span><br><span class="line">            categoryNotified = notified.get(url);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理通知监听器URL 变化结果</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, List&lt;URL&gt;&gt; entry : result.entrySet()) &#123;</span><br><span class="line">            String category = entry.getKey();</span><br><span class="line">            List&lt;URL&gt; categoryList = entry.getValue();</span><br><span class="line">            <span class="comment">// 把分类标实和分类后的列表放入notified的value中</span></span><br><span class="line">            <span class="comment">// 覆盖到 `notified`</span></span><br><span class="line">            <span class="comment">// 当某个分类的数据为空时，会依然有 urls 。其中 `urls[0].protocol = empty` ，通过这样的方式，处理所有服务提供者为空的情况。</span></span><br><span class="line">            categoryNotified.put(category, categoryList);</span><br><span class="line">            <span class="comment">// 保存到文件</span></span><br><span class="line">            saveProperties(url);</span><br><span class="line">            <span class="comment">//通知监听器</span></span><br><span class="line">            listener.notify(categoryList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在构造函数的最后一句，调用<strong>notify(url.getBackupUrls());</strong> 来将注册中心url返回的urls来进行通知。从下面代码可以开出返回的urls是通过url的参数获得的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;URL&gt; <span class="title">getBackupUrls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;URL&gt; urls = <span class="keyword">new</span> ArrayList&lt;URL&gt;();</span><br><span class="line">        urls.add(<span class="keyword">this</span>);</span><br><span class="line">        String[] backups = getParameter(Constants.BACKUP_KEY, <span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (backups != <span class="keyword">null</span> &amp;&amp; backups.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String backup : backups) &#123;</span><br><span class="line">                urls.add(<span class="keyword">this</span>.setAddress(backup));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> urls;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后获取遍历<strong>所有订阅URL</strong>，类型<code>Map&lt;URL,Set&lt;NotifyListener&gt;&gt;</code> ，判断遍历中的当前url与传入的backupURL是否匹配，匹配了继续向下执行，否则则跳过这个url,再处理下一个url。当向下执行时，获取遍历当前url的监听器。对每个监听器执行<code>notify(url, listener, filterEmpty(url, urls))</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> List&lt;URL&gt; <span class="title">filterEmpty</span><span class="params">(URL url, List&lt;URL&gt; urls)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (urls == <span class="keyword">null</span> || urls.isEmpty()) &#123;</span><br><span class="line">          List&lt;URL&gt; result = <span class="keyword">new</span> ArrayList&lt;URL&gt;(<span class="number">1</span>);</span><br><span class="line">          result.add(url.setProtocol(Constants.EMPTY_PROTOCOL));</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> urls;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>如果urls为空，则将根据url的信息新建一个url,并设置协议为空协议，放入到urls中。<br>然后执行notify方法，将backupURLS进行分类，放入到result中。<br>在上述中遍历所有订阅的urls,然后在每个url中再执行nofity,所以接下来的步骤可以理解成遍历订阅的urls,在循环内部获取每个url的被通知的urls集合。<br>每个url获取一个被通知的urls集合，<strong>categoryNotified</strong><br>之后遍历backURLs,它会覆盖掉原来被通知的集合<strong>categoryNotified</strong><br>遍历结束后，会将结果保存到文件中，<br>最后通知监听器处理，最后的这个通知方法在之后的篇章解释。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在dubbo中，关于注册中心Registry的有关实现封装在了dubbo-registry模块中。提供者（Provider）个消费者（Consumer）都是通过注册中心进行资源的调度。当服务启动时，provider会调用注册中心的register方法将自己的服务通过url的方式发布到注册中心，而consumer订阅其他服务时,会将订阅的服务通过url发送给注册中心（URL中通常会包含各种配置）。当某个服务被关闭时，它则会从注册中心中移除，当某个服务被修改时，则会调用notify方法触发所有的监听器。&lt;/p&gt;
    
    </summary>
    
      <category term="dubbo" scheme="https://github.com/spurstong/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="https://github.com/spurstong/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo之@Adaptive适配器类实现解析</title>
    <link href="https://github.com/spurstong/2019/07/26/Dubbo%E4%B9%8B@Adaptive%E9%80%82%E9%85%8D%E5%99%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6/"/>
    <id>https://github.com/spurstong/2019/07/26/Dubbo之@Adaptive适配器类实现解析机制/</id>
    <published>2019-07-26T14:48:00.000Z</published>
    <updated>2019-08-16T11:01:07.529Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇中讲解了关于Dubbo的SPI机制，在其中有一个很重要的注解@Adaptive，这是一个装饰器，通过此类来获取实现扩展类的具体实现类的方法。因为用到了设计模式中的适配器模式，所以打算独立出来写一篇。</p><a id="more"></a><p>在上一篇中讲解了关于Dubbo的SPI机制，在其中有一个很重要的注解@Adaptive，这是一个装饰器，通过此类来获取实现扩展类的具体实现类的方法。因为用到了设计模式中的适配器模式，所以打算独立出来写一篇。</p><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>将一个类的转接口转换成客户希望的另一个接口，适配器模式使得原来由于接口不兼容的而不能的工作的哪些类可以工作，主要作用就是兼容。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/Dubbo%E4%B9%8B%40Adaptive%E9%80%82%E9%85%8D%E5%99%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90/1.png" alt="1.png"></p><h2 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h2><p>Adapter类继承了Adaptee(被适配类)，同时实现Target接口，在Client类中我们可以根据需要选择并创建任一种符合需求的子类，来实现具体功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已存在的、具有特殊功能、但不符合我们既有的标准接口的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"被适配类 具有特殊功能..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标接口，或称为标准接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体目标类，只提供普通功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteTarget</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通类 具有普通功能..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器类，继承了被适配类，同时实现标准接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用普通功能类</span></span><br><span class="line">        Target concreteTarget = <span class="keyword">new</span> ConcreteTarget();<span class="comment">//实例化一个普通类</span></span><br><span class="line">        concreteTarget.request();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用特殊功能类，即适配类</span></span><br><span class="line">        Target adapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">        adapter.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h2><p>不使用多继承或继承的方式，而是使用直接关联，或者称为委托的方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/ 适配器类，直接关联被适配类，同时实现标准接口</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="comment">// 直接关联被适配类</span></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过构造函数传入具体需要适配的被适配类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span> <span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里是使用委托的方式完成特殊功能</span></span><br><span class="line">        <span class="keyword">this</span>.adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用普通功能类</span></span><br><span class="line">        Target concreteTarget = <span class="keyword">new</span> ConcreteTarget();</span><br><span class="line">        concreteTarget.request();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用特殊功能类，即适配类，</span></span><br><span class="line">        <span class="comment">// 需要先创建一个被适配类的对象作为参数</span></span><br><span class="line">        Target adapter = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee());</span><br><span class="line">        adapter.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Dubbo中的适配器"><a href="#Dubbo中的适配器" class="headerlink" title="Dubbo中的适配器"></a>Dubbo中的适配器</h1><p>Dubbo通过注解@Adaptive作为标记实现了一个适配器类，并且这个类是动态生成的，因此在Dubbo的源码中是看不到代码的，但是我们还是可以看到其实现方式的。Dubbo提供一个动态的适配器类的原因就是可以通过配置文件来动态的使用想要的接口实现类，并且不用改变任何接口的代码，简单来说其也是通过代理来实现的。<br>在初始化ExtensionLoader时，有一个构造函数，创建对象工厂，获得扩展实现的实例。<br>获取的就是一个objectFactory 的值是<code>AdaptiveExtensionFactory</code>的实例化对象。</p><p>创建 AdaptiveExtensionFactory 实例时，首先获取 ExtensionLoader，此前已经初始化ok。然后依次实例化具体实现（放在ExtensionLoader类cachedClasses属性中，这个属性用于存放实现功能接口的类，即上面解析得到的extensionClasses），即依次实例化SpiExtensionFactory和SpringExtensionFactory，事实上AdaptiveExtensionFactory是通用扩展实现获取的入口，具体的获取方式分为两种，一种是通过Dubbo自己的SPI方式加载到的扩展，另一种是支持复用Spring的方式。以key为“spi”，value是 SpiExtensionFactory 为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">//该类是否实现扩展接口</span></span><br><span class="line">        <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Error when load extension class(interface: "</span> +</span><br><span class="line">                    type + <span class="string">", class line: "</span> + clazz.getName() + <span class="string">"), class "</span></span><br><span class="line">                    + clazz.getName() + <span class="string">"is not subtype of interface."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断该类是否为扩展接口的适配器</span></span><br><span class="line">        <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cachedAdaptiveClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cachedAdaptiveClass = clazz;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cachedAdaptiveClass.equals(clazz)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"More than 1 adaptive class found: "</span></span><br><span class="line">                        + cachedAdaptiveClass.getClass().getName()</span><br><span class="line">                        + <span class="string">", "</span> + clazz.getClass().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">            Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class="line">            <span class="keyword">if</span> (wrappers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cachedWrapperClasses = <span class="keyword">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">                wrappers = cachedWrapperClasses;</span><br><span class="line">            &#125;</span><br><span class="line">            wrappers.add(clazz);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//通过反射获得构造器对象</span></span><br><span class="line">            clazz.getConstructor();</span><br><span class="line">            <span class="comment">//未配置扩展名，自动生成，例如DemoFilter为 demo，主要用于兼容java SPI的配置。</span></span><br><span class="line">            <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                name = findAnnotationName(clazz);</span><br><span class="line">                <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such extension name for the class "</span> + clazz.getName() + <span class="string">" in the config "</span> + resourceURL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获得扩展名，可以是数组，有多个拓扩展名。</span></span><br><span class="line">            String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">            <span class="keyword">if</span> (names != <span class="keyword">null</span> &amp;&amp; names.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Activate activate = clazz.getAnnotation(Activate.class);</span><br><span class="line">                <span class="comment">//如果是自动激活的实现类，则加入到缓存</span></span><br><span class="line">                <span class="keyword">if</span> (activate != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cachedActivates.put(names[<span class="number">0</span>], activate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!cachedNames.containsKey(clazz)) &#123;</span><br><span class="line">                        cachedNames.put(clazz, n);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//缓存扩展实现类</span></span><br><span class="line">                    Class&lt;?&gt; c = extensionClasses.get(n);</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        extensionClasses.put(n, clazz);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != clazz) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate extension "</span> + type.getName() + <span class="string">" name "</span> + n + <span class="string">" on "</span> + c.getName() + <span class="string">" and "</span> + clazz.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上述代码中可以看出，从配置文件中加载类时，会根据判断注解的不同而存放到不同的变量值中。<br>如果当前类的注解有@Adaptive,则将它存放到<code>cachedAdaptiveClass</code>中，然后将扩展点的具体实现类存放到<code>extensionClasses</code>中。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/Dubbo%E4%B9%8B%40Adaptive%E9%80%82%E9%85%8D%E5%99%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90/2.png" alt="2.png"></p><p>在调用<strong>injectExtension</strong>向创建的扩展点注入依赖时，有这一句话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得属性，比如StubProxyFactoryWrapper类中有Protocol protocol属性，</span></span><br><span class="line">String property = method.getName().length() &gt; <span class="number">3</span> ? method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + method.getName().substring(<span class="number">4</span>) : <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得属性值，比如Protocol对象，也可能是Bean对象</span></span><br><span class="line">Object object = objectFactory.getExtension(pt, property);</span><br><span class="line"><span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//注入依赖属性</span></span><br><span class="line">    method.invoke(instance, object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<strong>objectFactory.getExtension(pt, property);</strong> 实际上就是<em>AdaptiveExtensionFactory</em>实例去调用cachedClass中的某一个具体类的getExtension方法，因为 AdaptiveExtensionFactory和cachedClass中的类都继承了<em>ExtensionFactory</em>接口，但<code>AdaptiveExtensionFactory</code>没有实现getExtension方法的具体实现，但cacheedClass中的SpringExtensionFactory和spiExtensionFactory都有getExtension方法的具体实现，<code>AdaptiveExtensionFactory</code>承担着一个适配器的角色。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上一篇中讲解了关于Dubbo的SPI机制，在其中有一个很重要的注解@Adaptive，这是一个装饰器，通过此类来获取实现扩展类的具体实现类的方法。因为用到了设计模式中的适配器模式，所以打算独立出来写一篇。&lt;/p&gt;
    
    </summary>
    
      <category term="dubbo" scheme="https://github.com/spurstong/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="https://github.com/spurstong/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo的SPI机制与JDK机制的不同及原理分析</title>
    <link href="https://github.com/spurstong/2019/07/26/Dubbo%E7%9A%84SPI%E6%9C%BA%E5%88%B6%E4%B8%8EJDK%E7%9A%84SPI%E6%9C%BA%E5%88%B6%E7%9A%84%E4%B8%8D%E5%90%8C%E5%8F%8A%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/spurstong/2019/07/26/Dubbo的SPI机制与JDK的SPI机制的不同及原理分析/</id>
    <published>2019-07-26T10:35:00.000Z</published>
    <updated>2019-08-16T15:31:04.253Z</updated>
    
    <content type="html"><![CDATA[<p>Dubbo是SOA(面向服务架构)服务治理方案的核心框架。用于分布式调用，其重点在于分布式的治理。<br>简单的来说，可以把它分为四个角色。服务提供方（Provider）、服务消费方（Consumer）、注册中心和监控中心。通过注册中心对服务进行注册和订阅，通过监控中心对服务进行监控。</p><a id="more"></a><p>从今天开始，将会逐步介绍关于DUbbo的有关知识。首先先简单介绍一下DUbbo的整体概述。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Dubbo是SOA(面向服务架构)服务治理方案的核心框架。用于分布式调用，其重点在于分布式的治理。<br>简单的来说，可以把它分为四个角色。服务提供方（Provider）、服务消费方（Consumer）、注册中心和监控中心。通过注册中心对服务进行注册和订阅，通过监控中心对服务进行监控。<br>*核心功能  *</p><ul><li>Remoting:远程通讯，提供对多种NIO框架抽象封装，包括“同步转异步”和“请求-响应”模式的信息交换方式。</li><li>Cluster: 服务框架,提供基于<strong>接口方法</strong>的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li><li>Registry: 服务注册，基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。</li></ul><p>*Dubbo组件角色 * </p><p>Provider: 暴露服务的服务提供方<br>Consumer: 调用远程服务的服务消费方<br>Registry: 服务注册与发现的注册中心<br>Monitor: 统计服务的调用次数和调用时间的监控中心<br>Container: 服务运行容器，常见的容器有Spring容器</p><p>调用关系：</p><ol><li><strong>服务容器</strong>负责启动，加载，运行<strong>服务提供者</strong></li><li>服务提供者在启动时，向<strong>注册中心注册</strong>自己提供的服务。</li><li>服务消费者在启动时，向<strong>注册中心订阅</strong>自己所需的服务。</li><li><strong>注册中心</strong>返回<strong>服务提供者地址列表</strong>给<strong>消费者</strong>，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心Monitor。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/Dubbo%E7%9A%84SPI%E6%9C%BA%E5%88%B6%E4%B8%8EJDKd%E7%9A%84SPI%E6%9C%BA%E5%88%B6/1.png" alt="1.png"></li></ol><h1 id="SPI-Service-Provider-Interfaces"><a href="#SPI-Service-Provider-Interfaces" class="headerlink" title="SPI(Service Provider Interfaces)"></a>SPI(Service Provider Interfaces)</h1><p>它是Java提供的一套用来被<strong>第三方实现或者扩展的API</strong>,它可以用来启用框架扩展和替换组件。在JDK文档中，它这样解释道:</p><blockquote><p>A service is a well-known set of interfaces and (usually abstract) classes. A service provider is a specific implementation of a service.</p></blockquote><p>在面向对象的设计里面，模块之间推荐是基于接口编程，而不是对实现类进行硬编码，这样做也是为了模块设计的可拔插原则。为了在模块装配的时候不再程序里指明是那个实现，就需要一种服务发现的机制，jDK的SPI就是为某个接口寻找服务实现。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/Dubbo%E7%9A%84SPI%E6%9C%BA%E5%88%B6%E4%B8%8EJDKd%E7%9A%84SPI%E6%9C%BA%E5%88%B6/2.png" alt="2.png"></p><p>Java SPI实际上就是<strong>基于接口的编程+策略模式+配置文件</strong>组合实现的动态加载机制。<br>它为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模式化设计中这个机制尤其重要，所以它的核心思想是<strong>解耦</strong></p><p><em>使用场景</em></p><ul><li>数据库驱动加载接口实现类的加载<br>JDBC加载不同类型数据库的驱动</li><li>日志门面接口实现类加载<br>SLF4J加载不同提供商的日志实现类</li><li>Spring</li><li>Dubbo</li></ul><p><em>使用说明</em></p><ol><li>当服务提供者提供了接口的一种具体实现后，在jar包的<strong>META-INF/service</strong>目录下创建一个以”接口全限定名”为命名的文件，内容为实现类的全限定名。</li><li>接口实现类所在的jar包放在主程序的classpath中</li><li>主程序通过java.util.ServiceLoader动态加载实现模板，它通过扫描META-INF/services目录下的配置文件找到实现类的全限定名，把类加载到JVM</li><li>SPI的实现类必须携带一个不带参数的构造方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceLoader</span>&lt;<span class="title">S</span>&gt; <span class="keyword">implements</span> <span class="title">Iterable</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"META-INF/services/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代表被加载的类或者接口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;S&gt; service;</span><br><span class="line">    <span class="comment">// 用于定位、加载和实例化providers的类加载器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line">    <span class="comment">// 创建ServiceLoader时采用的访问控制上下文</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AccessControlContext acc;</span><br><span class="line">    <span class="comment">// 缓存providers，按照实例化的顺序排序</span></span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 懒查找迭代器</span></span><br><span class="line">    <span class="keyword">private</span> LazyIterator lookupIterator;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新加载，就相当于重新创建ServiceLoader了，用于新的服务提供者安装到正在运行的Java虚拟机</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//清空缓存中所有已实例化的服务提供者</span></span><br><span class="line">        providers.clear();</span><br><span class="line">        <span class="comment">//新建一个迭代器，该迭代器会从头查找和实例化服务提供者。</span></span><br><span class="line">        lookupIterator = <span class="keyword">new</span> LazyIterator(service, loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    ** 私有构造器</span></span><br><span class="line"><span class="comment">    ** 使用指定的类加载器和服务创建服务加载器</span></span><br><span class="line"><span class="comment">    ** 如果没有指定类加载器，使用系统类加载器，就是应用类加载器</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> </span>&#123;</span><br><span class="line">        service = Objects.requireNonNull(svc, <span class="string">"Service interface cannot be null"</span>);</span><br><span class="line">        loader = (cl == <span class="keyword">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">        acc = (System.getSecurityManager() != <span class="keyword">null</span>) ? AccessController.getContext() : <span class="keyword">null</span>;</span><br><span class="line">        reload();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//解析失败处理的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(Class&lt;?&gt; service, String msg, Throwable cause)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServiceConfigurationError</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServiceConfigurationError(service.getName() + <span class="string">": "</span> + msg,</span><br><span class="line">                                            cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(Class&lt;?&gt; service, String msg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServiceConfigurationError</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServiceConfigurationError(service.getName() + <span class="string">": "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fail</span><span class="params">(Class&lt;?&gt; service, URL u, <span class="keyword">int</span> line, String msg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServiceConfigurationError</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        fail(service, u + <span class="string">":"</span> + line + <span class="string">": "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析服务提供者配置文件中的一行</span></span><br><span class="line">    <span class="comment">//首先去掉注释检验，然后保存</span></span><br><span class="line">    <span class="comment">//返回下一行行号</span></span><br><span class="line">    <span class="comment">//重复的配置项不会被保存</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">parseLine</span><span class="params">(Class&lt;?&gt; service, URL u, BufferedReader r, <span class="keyword">int</span> lc,</span></span></span><br><span class="line"><span class="function"><span class="params">                          List&lt;String&gt; names)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, ServiceConfigurationError</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String ln = r.readLine();</span><br><span class="line">        <span class="keyword">if</span> (ln == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ci = ln.indexOf(<span class="string">'#'</span>);</span><br><span class="line">        <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) ln = ln.substring(<span class="number">0</span>, ci);</span><br><span class="line">        ln = ln.trim();</span><br><span class="line">        <span class="keyword">int</span> n = ln.length();</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ln.indexOf(<span class="string">' '</span>) &gt;= <span class="number">0</span>) || (ln.indexOf(<span class="string">'\t'</span>) &gt;= <span class="number">0</span>))</span><br><span class="line">                fail(service, u, lc, <span class="string">"Illegal configuration-file syntax"</span>);</span><br><span class="line">            <span class="keyword">int</span> cp = ln.codePointAt(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (!Character.isJavaIdentifierStart(cp))</span><br><span class="line">                fail(service, u, lc, <span class="string">"Illegal provider-class name: "</span> + ln);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = Character.charCount(cp); i &lt; n; i += Character.charCount(cp)) &#123;</span><br><span class="line">                cp = ln.codePointAt(i);</span><br><span class="line">                <span class="keyword">if</span> (!Character.isJavaIdentifierPart(cp) &amp;&amp; (cp != <span class="string">'.'</span>))</span><br><span class="line">                    fail(service, u, lc, <span class="string">"Illegal provider-class name: "</span> + ln);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!providers.containsKey(ln) &amp;&amp; !names.contains(ln))</span><br><span class="line">                names.add(ln);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lc + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//解析配置文件，解析指定的url配置文件</span></span><br><span class="line">  <span class="comment">//使用parseLine方法进行解析，未被实例化的服务提供者会被保存到缓存中。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Iterator&lt;String&gt; <span class="title">parse</span><span class="params">(Class&lt;?&gt; service, URL u)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServiceConfigurationError</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        BufferedReader r = <span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = u.openStream();</span><br><span class="line">            r = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in, <span class="string">"utf-8"</span>));</span><br><span class="line">            <span class="keyword">int</span> lc = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((lc = parseLine(service, u, r, lc, names)) &gt;= <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">"Error reading configuration file"</span>, x);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span>) r.close();</span><br><span class="line">                <span class="keyword">if</span> (in != <span class="keyword">null</span>) in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException y) &#123;</span><br><span class="line">                fail(service, <span class="string">"Error closing configuration file"</span>, y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> names.iterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务提供者查找的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">S</span>&gt;</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="comment">//服务提供者接口</span></span><br><span class="line">        Class&lt;S&gt; service;</span><br><span class="line">        <span class="comment">//类加载器</span></span><br><span class="line">        ClassLoader loader;</span><br><span class="line">        <span class="comment">//保存实现类的url</span></span><br><span class="line">        Enumeration&lt;URL&gt; configs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//保存实现类的全名</span></span><br><span class="line">        Iterator&lt;String&gt; pending = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//迭代器中下一个实现类的全名</span></span><br><span class="line">        String nextName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">LazyIterator</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.service = service;</span><br><span class="line">            <span class="keyword">this</span>.loader = loader;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fullName = PREFIX + service.getName();</span><br><span class="line">                    <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                        configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        configs = loader.getResources(fullName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                    fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pending = parse(service, configs.nextElement());</span><br><span class="line">            &#125;</span><br><span class="line">            nextName = pending.next();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            String cn = nextName;</span><br><span class="line">            nextName = <span class="keyword">null</span>;</span><br><span class="line">            Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                S p = service.cast(c.newInstance());</span><br><span class="line">                providers.put(cn, p);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>,</span><br><span class="line">                     x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> hasNextService();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PrivilegedAction&lt;Boolean&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> hasNextService(); &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> nextService();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                PrivilegedAction&lt;S&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;S&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> S <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextService(); &#125;</span><br><span class="line">                &#125;;</span><br><span class="line">                <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取迭代器</span></span><br><span class="line">    <span class="comment">//返回遍历服务提供者的迭代器</span></span><br><span class="line">    <span class="comment">//以懒加载的方式加载可用的服务提供者</span></span><br><span class="line">    <span class="comment">//懒加载的实现是：解析配置文件和实例化服务提供者的工作由迭代器本身完成</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;S&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iterator&lt;S&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            Iterator&lt;Map.Entry&lt;String,S&gt;&gt; knownProviders</span><br><span class="line">                = providers.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> lookupIterator.hasNext();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (knownProviders.hasNext())</span><br><span class="line">                    <span class="keyword">return</span> knownProviders.next().getValue();</span><br><span class="line">                <span class="keyword">return</span> lookupIterator.next();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//为指定的服务使用指定的类加载器来创建一个ServiceLoader</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            ClassLoader loader)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//使用线程上下文的类加载器来创建一个ServiceLoader</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">        ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">        <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//使用扩展类加载器为指定的服务创建ServiceLoader</span></span><br><span class="line">   <span class="comment">//只能找到并加载已经安装到当前Java虚拟机中的服务提供者，应用程序类路径中的服务提供者将被忽略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">loadInstalled</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">        ClassLoader cl = ClassLoader.getSystemClassLoader();</span><br><span class="line">        ClassLoader prev = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            prev = cl;</span><br><span class="line">            cl = cl.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ServiceLoader.load(service, prev);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a string describing this service.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  A descriptive string</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"java.util.ServiceLoader["</span> + service.getName() + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServiceLoader不是实例化以后，就去读取文件的具体实现。而是等到使用迭代器去遍历的时候，才会加载对应的配置文件去解析，调用hasNext方法时就去加载配置文件进行解析，调用Next方法的时候进行实例化并缓存。</p><p><em>优点</em><br>使用Java SPI机制的优势是实现解耦，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，而不是耦合在一起。应用程序可以根据实际业务情况启用框架扩展或替代框架组件。</p><p><em>缺点</em><br>虽然ServiceLoader也算是使用的延迟加载，但是基本只能通过遍历全部获取，也就是接口的实现类全部加载并实例化一遍。如果你并不想用某些实现类，它也被加载并实例化了，这就造成了浪费。获取某个实现类的方式不够灵活，只能通过Iterator形式获取，不能根据某个参数来获取对应的实现类。<br>多个并发多线程使用ServiceLoader类的实例是不安全的。</p><h1 id="Dubbo的SPI机制"><a href="#Dubbo的SPI机制" class="headerlink" title="Dubbo的SPI机制"></a>Dubbo的SPI机制</h1><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/Dubbo%E7%9A%84SPI%E6%9C%BA%E5%88%B6%E4%B8%8EJDKd%E7%9A%84SPI%E6%9C%BA%E5%88%B6/3.png" alt="3.png"><br>从图中可以看出，Dubbo进行各个模块的扩展时，是通过ExtensionLoader与扩展点进行关联的。<br>在Dubbo中的扩展点需要满足以下几个特点：</p><ol><li>扩展点必须是Interface类型，必须被@SPI注释</li><li>配置文件存储在<strong>META-INF/services/</strong> 和<strong>META-INF/dubbo/</strong> 和<strong>META-INF/dubbo/internal</strong>，这些路径下定义的文件名为扩展点接口的全类名，文件中以键值对的形式配置扩展点的扩展实现，这与JDk SPI的存储形式有很大不同,所以在Dubbo中无法直接使用ServiceLoader, 而是使用ExtensionLoader，可用于载入Dubbo中的各种可配置组件，比如动态代理方式（ProxyFactory）、负载均衡策略（LoadBalance）、RCP协议（Protocol）、拦截器（Filter）、容器类型（Container）、集群方式（Cluster）和注册中心类型等。<br>在<strong>META-INF/dubbo/internal/com.alibaba.dubbo.common.extension.ExtensionFactory 中定义的扩展 ：</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adaptive = com.alibaba.dubbo.common.extension.factory.AdaptiveExtensionFactory </span><br><span class="line">spi = com.alibaba.dubbo.common.extension.factory.SpiExtensionFactory </span><br><span class="line">spring = com.alibaba.dubbo.config.spring.extension.SpringExtensionFactor</span><br></pre></td></tr></table></figure></li></ol><p>在标识扩展点时会用到这几个标识，@SPI 、 @Adaptive、 @Activate</p><p>@SPI (注解在类上)：该注解标识了接口是一个扩展点，属性value用来指定默认适配扩展点的名称。<br>@Activate(注解在类型和方法上)：@Activate注解在扩展点的实现类上，表示了一个扩展类被获取到的条件，符合条件就被获取，不符合条件就不获取，根据@Activate中的group、value属性来过滤。<br>@Adaptive(注解在类型和方法上)：如果注解在类上，这个类就是缺省的适配扩展。注解在扩展点Interface的方法上时，dubbo会动态的生成一个这个扩展点的适配扩展类（生成代码，动态编译实例化Class）,名称为扩展点Interface的简单类名+$Adaptive,这样做的目的是为了在运行时去适配不同的扩展实例，在运行时通过<strong>传入的URL类型的参数或者内部含有获取URL方法的参数</strong>，从URL中获取到要使用的扩展类的名称，再去根据名称加载对应的扩展实例，用这个扩展实例对象调用相同的方法。如果运行时没有适配到运行的扩展实例，那么就使用@SPI注解缺省指定的扩展。通过这种方式就实现了运行时去适配到对应的扩展。<br>我们随机找一个源码中定义的接口： Transporter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"netty"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transporter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 绑定一个服务器</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    <span class="function">Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接一个服务器，即创建一个客户端</span></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;)</span><br><span class="line">    <span class="function">Client <span class="title">connect</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ExtensionLoader会通过createAdaptiveExtensionClassCode方法动态生成一个<strong>Transporter$Adaptive类</strong>，生成的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.remoting;</span><br><span class="line"><span class="keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transporter</span>$<span class="title">Adaptive</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">alibaba</span>.<span class="title">dubbo</span>.<span class="title">remoting</span>.<span class="title">Transporter</span></span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> com.alibaba.dubbo.remoting.<span class="function">Client <span class="title">connect</span><span class="params">(com.alibaba.dubbo.common.URL arg0, com.alibaba.dubbo.remoting.ChannelHandler arg1)</span> <span class="keyword">throws</span> com.alibaba.dubbo.remoting.RemotingException </span>&#123;</span><br><span class="line">        <span class="comment">//URL参数为空则抛出异常。</span></span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        </span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg0;</span><br><span class="line">        String extName = url.getParameter(<span class="string">"client"</span>, url.getParameter(<span class="string">"transporter"</span>, <span class="string">"netty"</span>));</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get extension(com.alibaba.dubbo.remoting.Transporter) name from url("</span> + url.toString() + <span class="string">") use keys([client, transporter])"</span>);</span><br><span class="line">        com.alibaba.dubbo.remoting.Transporter extension = (com.alibaba.dubbo.remoting.Transporter)ExtensionLoader.getExtensionLoader</span><br><span class="line">        </span><br><span class="line">        (com.alibaba.dubbo.remoting.Transporter.class).getExtension(extName);</span><br><span class="line">        <span class="keyword">return</span> extension.connect(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> com.alibaba.dubbo.remoting.<span class="function">Server <span class="title">bind</span><span class="params">(com.alibaba.dubbo.common.URL arg0, com.alibaba.dubbo.remoting.ChannelHandler arg1)</span> <span class="keyword">throws</span> com.alibaba.dubbo.remoting.RemotingException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arg0 == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">        com.alibaba.dubbo.common.URL url = arg0;</span><br><span class="line">        String extName = url.getParameter(<span class="string">"server"</span>, url.getParameter(<span class="string">"transporter"</span>, <span class="string">"netty"</span>));</span><br><span class="line">        <span class="keyword">if</span>(extName == <span class="keyword">null</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Fail to get extension(com.alibaba.dubbo.remoting.Transporter) name from url("</span> + url.toString() + <span class="string">") use keys([server, transporter])"</span>);</span><br><span class="line">        com.alibaba.dubbo.remoting.Transporter extension = (com.alibaba.dubbo.remoting.Transporter)ExtensionLoader.getExtensionLoader</span><br><span class="line">        (com.alibaba.dubbo.remoting.Transporter.class).getExtension(extName);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> extension.bind(arg0, arg1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些代码都是模板代码，最核心的代码只有一行，是为了去获取指定名称的扩展实例对象。<br> com.alibaba.dubbo.remoting.Transporter extension = (com.alibaba.dubbo.remoting.Transporter)ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.remoting.Transporter.class).getExtension(extName);</p><h1 id="扩展加载器-ExtensionLoader"><a href="#扩展加载器-ExtensionLoader" class="headerlink" title="扩展加载器 ExtensionLoader"></a>扩展加载器 ExtensionLoader</h1><p>它控制着所有扩展点的初始化、加载扩展的过程。<br>ExtensionLoader中会存储两个静态属性，EXTENSION_LOADERS保存内核开放的扩展点对应的ExtensionLoader实例对象；EXTENSION_INSTANCES保存了扩展类型（Class）和扩展类型的实例对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ExtensionLoader.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是jdk的SPI扩展机制中配置文件路径，dubbo为了兼容jdk的SPI</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SERVICES_DIRECTORY = <span class="string">"META-INF/services/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于用户自定义的扩展实现配置文件存放路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUBBO_DIRECTORY = <span class="string">"META-INF/dubbo/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于dubbo内部提供的扩展实现配置文件存放路径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DUBBO_INTERNAL_DIRECTORY = DUBBO_DIRECTORY + <span class="string">"internal/"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern NAME_SEPARATOR = Pattern.compile(<span class="string">"\\s*[,]+\\s*"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩展加载器集合，key为扩展接口，例如Protocol等</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩展实现集合，key为扩展实现类，value为扩展对象</span></span><br><span class="line">    <span class="comment">//例如key为Class&lt;DubboProtocol&gt;，value为DubboProtocol对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Object&gt; EXTENSION_INSTANCES = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line">    <span class="comment">//扩展接口，例如Protocol等</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象工厂，获得扩展实现的实例，用于injectExtension方法中将扩展实现类的实例注入到相关的依赖属性。</span></span><br><span class="line">    <span class="comment">//比如StubProxyFactoryWrapper类中有Protocol protocol属性，就是通过set方法把Protocol的实现类实例赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExtensionFactory objectFactory;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下提到的扩展名就是在配置文件中的key值，类似于“dubbo”等</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存的扩展名与扩展类映射，和cachedClasses的key和value对换。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, String&gt; cachedNames = <span class="keyword">new</span> ConcurrentHashMap&lt;Class&lt;?&gt;, String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存的扩展实现类集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt; cachedClasses = <span class="keyword">new</span> Holder&lt;Map&lt;String, Class&lt;?&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩展名与加有@Activate的自动激活类的映射</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Activate&gt; cachedActivates = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Activate&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存的扩展对象集合，key为扩展名，value为扩展对象</span></span><br><span class="line">    <span class="comment">//例如Protocol扩展，key为dubbo，value为DubboProcotol</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Holder&lt;Object&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存的自适应( Adaptive )扩展对象，例如例如AdaptiveExtensionFactory类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Holder&lt;Object&gt; cachedAdaptiveInstance = <span class="keyword">new</span> Holder&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存的自适应扩展对象的类，例如AdaptiveExtensionFactory类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Class&lt;?&gt; cachedAdaptiveClass = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//缓存的默认扩展名，就是@SPI中设置的值</span></span><br><span class="line">    <span class="keyword">private</span> String cachedDefaultName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建cachedAdaptiveInstance异常</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Throwable createAdaptiveInstanceError;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拓展Wrapper实现类集合</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Class&lt;?&gt;&gt; cachedWrapperClasses;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拓展名与加载对应拓展类发生的异常的映射</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, IllegalStateException&gt; exceptions = <span class="keyword">new</span> ConcurrentHashMap&lt;String, IllegalStateException&gt;();</span><br></pre></td></tr></table></figure><p>ExtensionLoader没有提供public的构造方法，有一个私有的构造方法，获取ExtensionLoader实例的工厂方法，但是提供了一个public static的getExtensionLoader。其public成员方法中有三个比较重要的方法：<br>getActiveExtension: 根据条件获取当前扩展可自动激活的实现<br>getExtension: 根据名称获取当前扩展的指定实现<br>getAdaptiveExtension: 获取当前扩展的自适应实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ExtensionLoader</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.type = type;</span><br><span class="line">       objectFactory = (type == ExtensionFactory.class ? <span class="keyword">null</span> : ExtensionLoader.getExtensionLoader(ExtensionFactory.class).getAdaptiveExtension());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上可以看出ExtensionFactory也是一个扩展点，有两个实现类：<code>SpiExtensionFactory</code>和<code>AdaptiveExtensionFactory</code>，实际上还有一个<code>SpringExtensionFactory</code>,不同的实现类可以用不同的方式来完成扩展点实现的加载。如果要加载的扩展点类型是<code>ExtensionFactory</code>,那么object设置为null。<br>默认的<code>ExtensionFactory</code>实现中，<code>AdaptiveExtensionFactory</code>被@Adaptive注解注释，也就是说它是<code>ExtensionFactory</code>对应的自适应扩展实现（每个扩展点最多只能有一个自适应实现，如果所有实现中没有被@Adaptive注释的，那么dubbo会动态生成一个自适应实现类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdaptiveExtensionFactory</span> <span class="keyword">implements</span> <span class="title">ExtensionFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//扩展对象的集合，默认的可以分为dubbo 的SPI中接口实现类对象或者Spring bean对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ExtensionFactory&gt; factories;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdaptiveExtensionFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExtensionLoader&lt;ExtensionFactory&gt; loader = ExtensionLoader.getExtensionLoader(ExtensionFactory.class);</span><br><span class="line">        List&lt;ExtensionFactory&gt; list = <span class="keyword">new</span> ArrayList&lt;ExtensionFactory&gt;();</span><br><span class="line">        <span class="comment">//遍历所有支持的扩展名</span></span><br><span class="line">        <span class="keyword">for</span> (String name : loader.getSupportedExtensions()) &#123;</span><br><span class="line">            <span class="comment">//扩展对象加入到集合中</span></span><br><span class="line">            list.add(loader.getExtension(name));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回一个不可修改的集合</span></span><br><span class="line">        factories = Collections.unmodifiableList(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ExtensionFactory factory : factories) &#123;</span><br><span class="line">            <span class="comment">//通过扩展接口和扩展名获得扩展对象</span></span><br><span class="line">            T extension = factory.getExtension(type, name);</span><br><span class="line">            <span class="keyword">if</span> (extension != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> extension;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中调用到了ExtensionLoader类中的getSupportedExtensions方法，所以接下来再分析ExtensionLoader类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">ExtensionLoader&lt;T&gt; <span class="title">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//扩展点接口为空，抛出异常</span></span><br><span class="line">       <span class="keyword">if</span> (type == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type == null"</span>);</span><br><span class="line">       <span class="comment">//判断type是否是一个接口类</span></span><br><span class="line">       <span class="keyword">if</span> (!type.isInterface()) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type("</span> + type + <span class="string">") is not interface!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//判断是否为可扩展的接口</span></span><br><span class="line">       <span class="keyword">if</span> (!withExtensionAnnotation(type)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Extension type("</span> + type +</span><br><span class="line">                   <span class="string">") is not extension, because WITHOUT @"</span> + SPI.class.getSimpleName() + <span class="string">" Annotation!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//从扩展加载器集合中取出扩展接口对应的扩展加载器</span></span><br><span class="line">       ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//如果为空，则创建该扩展接口的扩展加载器，并且添加到EXTENSION_LOADERS</span></span><br><span class="line">       <span class="keyword">if</span> (loader == <span class="keyword">null</span>) &#123;</span><br><span class="line">           EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> ExtensionLoader&lt;T&gt;(type));</span><br><span class="line">           loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> loader;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object instance = cachedAdaptiveInstance.get();</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (createAdaptiveInstanceError == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">                    instance = cachedAdaptiveInstance.get();</span><br><span class="line">                    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//创建适配器对象</span></span><br><span class="line">                            instance = createAdaptiveExtension();</span><br><span class="line">                            cachedAdaptiveInstance.set(instance);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                            createAdaptiveInstanceError = t;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"fail to create adaptive instance: "</span> + t.toString(), t);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"fail to create adaptive instance: "</span> + createAdaptiveInstanceError.toString(), createAdaptiveInstanceError);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (T) instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在ExtensionLoader的私有构造方法中可以看出，在选择ExtensionFactory的时候，并不是用getExtension(name)来获取某个具体的实现类，而是调用getAdaptiveExtension来获取一个自适应的实现。<br>首先检查缓存的adaptiveInstance是否存在，如果存在则直接使用，否则的话调用<strong>createAdaptiveExtension</strong>方法来创建新的adaptiveInstance并且缓存起来，也就是说对于某个扩展点，每次调用<code>ExtensionLoader.getAdaptiveExtension</code>获取到的都是同一个实例。<br>在调用getAdaptiveExtensionClass中首先调用getExtensionClasses()<br>在getAdaptiveExtensionClass()中，调用getExtensionClasses()获取扩展实现类数组，并存放在cachedClasses属性中。<br>再从getExtensionClasses()看，当cachedClasses为空时，调用loadExtensionClasses()<br>getExtensionClasses()会加载当前Extension的所有实现，如果有@Adaptive类型，则会赋值给cachedAdaptiveClass属性缓存起来，如果没有找到@Adaptive类型实现，则动态创建一个AdaptiveExtensionClass。</p><p>首先会获取到该扩展点类的注解中的值，获取默认值，然后从特定目录下读取配置文件中的信息，<br>最后通过<strong>loadClass</strong>，将有关类放到extensionClasses变量中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> T <span class="title">createAdaptiveExtension</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not create adaptive extension "</span> + type + <span class="string">", cause: "</span> + e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">        getExtensionClasses();</span><br><span class="line">        <span class="comment">//缓存的自适应扩展对象</span></span><br><span class="line">        <span class="keyword">if</span> (cachedAdaptiveClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">        <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">                classes = cachedClasses.get();</span><br><span class="line">                <span class="keyword">if</span> (classes == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    classes = loadExtensionClasses();</span><br><span class="line">                    cachedClasses.set(classes);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> classes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">        <span class="keyword">final</span> SPI defaultAnnotation = type.getAnnotation(SPI.class);</span><br><span class="line">        <span class="keyword">if</span> (defaultAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//@SPI内的默认值</span></span><br><span class="line">            String value = defaultAnnotation.value();</span><br><span class="line">            <span class="keyword">if</span> ((value = value.trim()).length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                String[] names = NAME_SEPARATOR.split(value);</span><br><span class="line">                <span class="comment">//只允许有一个默认值</span></span><br><span class="line">                <span class="keyword">if</span> (names.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"more than 1 default extension name on extension "</span> + type.getName()</span><br><span class="line">                            + <span class="string">": "</span> + Arrays.toString(names));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (names.length == <span class="number">1</span>) cachedDefaultName = names[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从配置文件中加载实现类数组</span></span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> HashMap&lt;String, Class&lt;?&gt;&gt;();</span><br><span class="line">        loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);</span><br><span class="line">        loadDirectory(extensionClasses, DUBBO_DIRECTORY);</span><br><span class="line">        loadDirectory(extensionClasses, SERVICES_DIRECTORY);</span><br><span class="line">        <span class="keyword">return</span> extensionClasses;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadDirectory</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//拼接接口全限定名，得到完整的文件名</span></span><br><span class="line">        String fileName = dir + type.getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Enumeration&lt;java.net.URL&gt; urls;</span><br><span class="line">            <span class="comment">//获取ExtensionLoader类信息</span></span><br><span class="line">            ClassLoader classLoader = findClassLoader();</span><br><span class="line">            <span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                urls = classLoader.getResources(fileName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                urls = ClassLoader.getSystemResources(fileName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (urls != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//遍历文件</span></span><br><span class="line">                <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                    java.net.URL resourceURL = urls.nextElement();</span><br><span class="line">                    loadResource(extensionClasses, classLoader, resourceURL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(<span class="string">"Exception when load extension class(interface: "</span> +</span><br><span class="line">                    type + <span class="string">", description file: "</span> + fileName + <span class="string">")."</span>, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadResource</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader, java.net.URL resourceURL)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(resourceURL.openStream(), <span class="string">"utf-8"</span>));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String line;</span><br><span class="line">                <span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//跳过被#注释的内容</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> ci = line.indexOf(<span class="string">'#'</span>);</span><br><span class="line">                    <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) line = line.substring(<span class="number">0</span>, ci);</span><br><span class="line">                    line = line.trim();</span><br><span class="line">                    <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            String name = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">int</span> i = line.indexOf(<span class="string">'='</span>);</span><br><span class="line">                            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//根据"="拆分key跟value</span></span><br><span class="line">                                name = line.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                                line = line.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//加载扩展类</span></span><br><span class="line">                                loadClass(extensionClasses, resourceURL, Class.forName(line, <span class="keyword">true</span>, classLoader), name);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to load extension class(interface: "</span> + type + <span class="string">", class line: "</span> + line + <span class="string">") in "</span> + resourceURL + <span class="string">", cause: "</span> + t.getMessage(), t);</span><br><span class="line">                            exceptions.put(line, e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                reader.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.error(<span class="string">"Exception when load extension class(interface: "</span> +</span><br><span class="line">                    type + <span class="string">", class file: "</span> + resourceURL + <span class="string">") in "</span> + resourceURL, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">//该类是否实现扩展接口</span></span><br><span class="line">        <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Error when load extension class(interface: "</span> +</span><br><span class="line">                    type + <span class="string">", class line: "</span> + clazz.getName() + <span class="string">"), class "</span></span><br><span class="line">                    + clazz.getName() + <span class="string">"is not subtype of interface."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断该类是否为扩展接口的适配器</span></span><br><span class="line">        <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cachedAdaptiveClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cachedAdaptiveClass = clazz;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cachedAdaptiveClass.equals(clazz)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"More than 1 adaptive class found: "</span></span><br><span class="line">                        + cachedAdaptiveClass.getClass().getName()</span><br><span class="line">                        + <span class="string">", "</span> + clazz.getClass().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">            Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class="line">            <span class="keyword">if</span> (wrappers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cachedWrapperClasses = <span class="keyword">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">                wrappers = cachedWrapperClasses;</span><br><span class="line">            &#125;</span><br><span class="line">            wrappers.add(clazz);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//通过反射获得构造器对象</span></span><br><span class="line">            clazz.getConstructor();</span><br><span class="line">            <span class="comment">//未配置扩展名，自动生成，例如DemoFilter为 demo，主要用于兼容java SPI的配置。</span></span><br><span class="line">            <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                name = findAnnotationName(clazz);</span><br><span class="line">                <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such extension name for the class "</span> + clazz.getName() + <span class="string">" in the config "</span> + resourceURL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获得扩展名，可以是数组，有多个拓扩展名。</span></span><br><span class="line">            String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">            <span class="keyword">if</span> (names != <span class="keyword">null</span> &amp;&amp; names.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Activate activate = clazz.getAnnotation(Activate.class);</span><br><span class="line">                <span class="comment">//如果是自动激活的实现类，则加入到缓存</span></span><br><span class="line">                <span class="keyword">if</span> (activate != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cachedActivates.put(names[<span class="number">0</span>], activate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!cachedNames.containsKey(clazz)) &#123;</span><br><span class="line">                        cachedNames.put(clazz, n);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//缓存扩展实现类</span></span><br><span class="line">                    Class&lt;?&gt; c = extensionClasses.get(n);</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        extensionClasses.put(n, clazz);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != clazz) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate extension "</span> + type.getName() + <span class="string">" name "</span> + n + <span class="string">" on "</span> + c.getName() + <span class="string">" and "</span> + clazz.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述代码完成了自适应扩展点类型的实现和实例化，下面方法是扩展点自动注入的实现，它会获取处理当前实例的所有set方法对应的参数类型和property名称，根据这两个条件从ExtensionFactory中查询，如果有返回扩展点实例，那么就进行注入操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">injectExtension</span><span class="params">(T instance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (objectFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//反射获得该类中所有的方法</span></span><br><span class="line">                <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">                    <span class="comment">//如果是set方法</span></span><br><span class="line">                    <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"set"</span>)</span><br><span class="line">                            &amp;&amp; method.getParameterTypes().length == <span class="number">1</span></span><br><span class="line">                            &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">                        <span class="comment">/**</span></span><br><span class="line"><span class="comment">                         * Check &#123;<span class="doctag">@link</span> DisableInject&#125; to see if we need auto injection for this property</span></span><br><span class="line"><span class="comment">                         */</span></span><br><span class="line">                        <span class="keyword">if</span> (method.getAnnotation(DisableInject.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//获得属性，比如StubProxyFactoryWrapper类中有Protocol protocol属性，</span></span><br><span class="line">                            String property = method.getName().length() &gt; <span class="number">3</span> ? method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + method.getName().substring(<span class="number">4</span>) : <span class="string">""</span>;</span><br><span class="line">                            <span class="comment">//获得属性值，比如Protocol对象，也可能是Bean对象</span></span><br><span class="line">                            Object object = objectFactory.getExtension(pt, property);</span><br><span class="line">                            <span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                <span class="comment">//注入依赖属性</span></span><br><span class="line">                                method.invoke(instance, object);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            logger.error(<span class="string">"fail to inject via method "</span> + method.getName()</span><br><span class="line">                                    + <span class="string">" of interface "</span> + type.getName() + <span class="string">": "</span> + e.getMessage(), e);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>文章参考：<br><a href="https://blog.csdn.net/zhuqiuhui/article/details/83820876" target="_blank" rel="noopener">dubbo源码一：ExtensionLoader及获取适配类过程解析</a><br><a href="https://yq.aliyun.com/articles/135645" target="_blank" rel="noopener">Dubbo扩展点加载机制 - ExtensionLoader</a><br><a href="https://www.jianshu.com/p/0905fc2511c2" target="_blank" rel="noopener">【Dubbo】Adaptive</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dubbo是SOA(面向服务架构)服务治理方案的核心框架。用于分布式调用，其重点在于分布式的治理。&lt;br&gt;简单的来说，可以把它分为四个角色。服务提供方（Provider）、服务消费方（Consumer）、注册中心和监控中心。通过注册中心对服务进行注册和订阅，通过监控中心对服务进行监控。&lt;/p&gt;
    
    </summary>
    
      <category term="dubbo" scheme="https://github.com/spurstong/categories/dubbo/"/>
    
    
      <category term="dubbo" scheme="https://github.com/spurstong/tags/dubbo/"/>
    
  </entry>
  
  <entry>
    <title>jvm jstack分析线程状态及类加载机制</title>
    <link href="https://github.com/spurstong/2019/07/20/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://github.com/spurstong/2019/07/20/jvm类加载机制/</id>
    <published>2019-07-20T09:16:20.000Z</published>
    <updated>2019-08-17T05:53:43.130Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机把描述类的数据结构从Class文件中加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p><a id="more"></a><h1 id="jstack分析线程状态"><a href="#jstack分析线程状态" class="headerlink" title="jstack分析线程状态"></a>jstack分析线程状态</h1><p>如何查看cpu中占用率较高的线程并分析原因</p><ol><li>在linux终端，执行<strong>top</strong>,它默认是按照使用率排序的，所以查看第一行，获取进程id,假设id为123</li><li>执行<strong>top -Hp 123</strong>,查看该进程下各个线程的执行情况</li><li>执行<strong>jstack 123</strong>查看该线程下的堆栈使用情况，</li><li>执行<strong>jmap -dump:live 123</strong>，下载该进程下存活的对象</li><li>使用MAT工具 加载该文件，分析问题<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1>虚拟机把描述类的数据结构从Class文件中加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/1.png" alt="1.png"><br>类的生命周期主要包括加载、验证、准备、解析、初始化、使用和卸载。其中，加载、验证、准备和初始化的顺序是确定的，但这种顺序不是按部就班的进行，通常这些阶段通常都是相互交叉的混合进行，通常会在一个阶段执行的过程中调用、激活另一个阶段。<h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h1>在此阶段主要做下面三件事情：</li><li>通过一个类的全限定名来获取定义此类的<strong>二进制字节流</strong>。</li><li>将这个字节流所代表的<strong>静态存储结构</strong>转化为方法区的<strong>运行时数据结构</strong>。</li><li>在内存中生成一个代表这个类的<strong>java.lang.Class对象</strong>，作为方法区这个类的各种数据的访问入口。<br>在此阶段的操作有很高的灵活性，比如上述的第一件事，开发人员可以从不同方面进行操作，</li></ol><ul><li>从zip包中读取，最终成为日后的JAR、EAR、WAR格式的基础。</li><li>从网络中获取</li><li>运行时计算生成</li><li>从数据库中读取 等<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1>目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求。</li><li>文件格式验证，验证字节流是否符合Class文件格式的规范。</li><li>元数据验证，对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言规范的要求</li><li>字节码验证，通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1>该阶段是正式为<strong>类变量</strong>分配内存并设置类变量<strong>初始值</strong>的阶段，这些变量所使用的内存都将在方法区中进行分配。<br>该阶段不包括实例变量，实例对象将会在对象实例化时随着对象一起分配在Java堆中。<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1>该阶段是将常量池中的符号引用替换成直接引用。<br>常量池中主要存放两大类常量：字面量和符号引用。<br>字面量类似于Java语言层面的常量概念，如文本字符串、声明为final的常量。<br>符号引用则属于编译原理方面的概念，主要包括下面三类常量：<br>1) 类和接口的全限定名<br>2) 字段的名称和描述符<br>3) 方法的名称和描述符<br>在Class文件中不会保存各个方法、字段的最终布局信息，需要从常量池中获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址中。<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1>初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1>把类加载阶段的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作交给虚拟机之外的类加载器来完成。这样的好处在于，我们可以自行实现类加载器来加载其他格式的类，只要是二进制字节流就行，这就大大增强了加载器灵活性。系统自带的类加载器分为三种：</li><li>启动类加载器。</li><li>扩展类加载器</li><li>应用程序类加载器。<h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1>如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是，依次向上递归请求，访问到最顶端时，然后最顶端类判断能否完成这个加载请求，如果该类能执行的话，就执行然后跳出程序，下面的类无需执行；不能执行的话，则再跳转到相邻的下一个子类，依次类推。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虚拟机把描述类的数据结构从Class文件中加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。&lt;/p&gt;
    
    </summary>
    
      <category term="jvm" scheme="https://github.com/spurstong/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://github.com/spurstong/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>G1垃圾收集器详解</title>
    <link href="https://github.com/spurstong/2019/07/18/G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <id>https://github.com/spurstong/2019/07/18/G1垃圾收集器详解/</id>
    <published>2019-07-18T09:24:20.000Z</published>
    <updated>2019-08-16T11:02:16.987Z</updated>
    
    <content type="html"><![CDATA[<p>G1是一款面向服务器应用的垃圾收集器，目标是用在多核、大内存的机器上。<br>它在满足高吞吐量的同时满足GC停顿的时间尽可能地短。<br>应用场景：</p><ul><li>可以像CMS收集器一样可以和应用并发运行</li><li>压缩空闲的内存碎片，却不需要冗长的GC停顿。</li><li>对GC停顿可以做更好的预测</li></ul><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>G1是一款面向服务器应用的垃圾收集器，目标是用在多核、大内存的机器上。<br>它在满足高吞吐量的同时满足GC停顿的时间尽可能地短。<br>应用场景：</p><ul><li>可以像CMS收集器一样可以和应用并发运行</li><li>压缩空闲的内存碎片，却不需要冗长的GC停顿。</li><li>对GC停顿可以做更好的预测</li><li>不想牺牲大量的吞吐量性能</li><li>不需要更大的Java Heap<h1 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h1>在传统的GC收集器（serial, parallel, CMS）都是把heap分成固定大小连续的三个空间： 年轻代，老年代和永久代。<br>在jdk8中，取消了永久代，改用了元空间。</li></ul><p><strong>永久代与元空间的区别</strong><br>在JDK8之前的HotSpot JVM，存放这些”永久的”的区域叫做“永久代(permanent generation)”。永久代是一片连续的堆空间，在JVM启动之前通过在命令行设置参数-XX:MaxPermSize来设定永久代最大可分配的内存空间，默认大小是64M（64位JVM由于指针膨胀，默认是85M）。永久代的垃圾收集是和老年代(old generation)捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。不过，一个明显的问题是，当JVM加载的类信息容量超过了参数-XX：MaxPermSize设定的值时，应用将会报OOM的错误。<br>而元空间是直接存在内存中，不在java虚拟机中的，因此元空间依赖于内存大小。当然你也可以自定义元空间大小。</p><ul><li><strong>元空间并不在虚拟机中</strong>，而是使用<strong>本地内存</strong>。</li><li>因此，默认情况下，元空间的大小仅受本地内存限制，</li><li>但可以通过以下参数来指定元空间的大小：- -XX:MetaspaceSize，初始空间大小，<ul><li>-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。</li><li>-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比</li><li>-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比<br>取代的原因：</li></ul></li></ul><ol><li>字符串存在永久代中，容易出现性能问题和内存溢出。</li><li>类及方法的信息等比较难确定其大小，</li></ol><ul><li>因此对于永久代的大小指定比较困难，- 太小容易出现永久代溢出，<ul><li>太大则容易导致老年代溢出。</li></ul></li></ul><ol start="3"><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3/1.png" alt="1.png"><br>G1将整个堆分成相同大小的分区。每个分区都可能是年轻代可也能是老年代，但在同一时刻只能属于某一个代。年轻代、幸存区和老年代等概念还存在，成为<strong>逻辑上的概念</strong>。在物理上不需要<strong>连续</strong>，堆内存中一个区域(Region)的大小可以通过-XX:G1HeapRegionSize参数指定，大小区间最小1M、最大32M，总之是2的幂次方。<br>G1是一种带压缩的收集器，在回收老年代的分区时，是将存活的对象从一个分区中拷贝到另一个可用分区，这个拷贝的过程就实现了局部的压缩。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3/2.png" alt="2.png"><br>每个Region被标记为E、S、O和H,这些区域在逻辑上被映射为Eden,Survivor和老年代。除此之外，还添加了另外一种类型，被称为（Humongous Region）。它是为了存储超过50%religon大小对象而设计的，而这些对象被称为巨型对象。如果一个H区装不下一个巨型对象，那么G1会寻找连续的H分区来存储。为了能找到连续的H区，有时候不得不启动Full GC。</li></ol><p><strong>收集集合（Cset)</strong><br>一组可被回收的分区的集合。在Cset中存活的数据会在GC过程中被移动到另一个可用分区，Cset中的分区可以来自Eden空间、survivor空间或者老年代。Cset会占用不到整个堆空间的1%大小。<br><strong>Remembered Set(已记忆集合)</strong><br>RSet记录了其他Region中的对象引用本Region中对象的关系，属于points-into结构，而在CMS中使用了Card Table的结构，里面记录了老年代对象到新生代的引用。Card Table的结构是一个连续的byte[]数组，扫描Card Table的时间比扫描整个老年代的代价要小很多。Card Table属于points-out(我引用了谁的对象)的结构。每个Region都会记录下别的Region有指向自己的指针，并标记这些指针分别在哪些Card的范围内。这个RSet其实是一个Hash Table,key是别的Region的起始地址，Value是一个集合，里面的元素是Card Table的Index。每个Region都有一个对应的Rset。<br>RSet究竟是怎么辅助GC的呢？在做YGC的时候，只需要选定young generation region的RSet作为根集，这些RSet记录了old-&gt;young的跨代引用，避免了扫描整个old generation。 而mixed gc的时候，old generation中记录了old-&gt;old的RSet，young-&gt;old的引用由扫描全部young generation region得到，这样也不用扫描全部old generation region。所以RSet的引入大大减少了GC的工作量。</p><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3/3.png" alt="3.png"></p><h1 id="Snapshot-At-The-Begining"><a href="#Snapshot-At-The-Begining" class="headerlink" title="Snapshot-At-The-Begining"></a>Snapshot-At-The-Begining</h1><p>它是GC开始时活着的对象的一个快照。他是通过Root Tracing得到的，作用是<strong>维持并发GC的正确性</strong>。<br>它是根据三色标记算法，把对象设置为了三种状态：</p><ul><li>白：对象没有被标记到，标记阶段结束后，会被当做垃圾回收掉。</li><li>灰： 对象被标记了，但是它的field还没有被标记或标记完</li><li>黑： 对象被标记了，并且它的所有field也被标记完了。<br>垃圾收集器的工作过程，就是通过灰色对象的指针扫描它指向的白色对象，如果找到一个白色对象，就将它设置为灰色，如果某个灰色对象的可达对象已经全部找完，就将它设置为黑色对象。当在当前集合中找不到灰色的对象时，就说明该集合的回收动作完成，然后所有白色的对象的都会被回收。</li></ul><p>由于并发阶段的存在，Mutator和Garbage Collector线程同时对对象进行修改，就会出现白对象漏标的情况，这种情况发生的前提是：</p><ul><li>Mutator赋予一个黑对象该白对象的引用。</li><li>Mutator删除了所有从灰对象到该白对象的直接或者间接引用。</li></ul><p>对于第一个条件，在并发标记阶段，如果该白对象是new出来的，并没有被灰对象持有，那么它会不会被漏标呢？Region中有两个top-at-mark-start（TAMS）指针，分别为prevTAMS和nextTAMS。在TAMS以上的对象是新分配的，这是一种隐式的标记。对于在GC时已经存在的白对象，如果它是活着的，它必然会被另一个对象引用，即条件二中的灰对象。如果灰对象到白对象的直接引用或者间接引用被替换了，或者删除了，白对象就会被漏标，从而导致被回收掉，这是非常严重的错误，所以SATB破坏了第二个条件。也就是说，一个对象的引用被替换时，可以通过write barrier 将旧引用记录下来。<br>SATB也是有副作用的，如果被替换的白对象就是要被收集的垃圾，这次的标记会让它躲过GC，这就是float garbage。因为SATB的做法精度比较低，所以造成的float garbage也会比较多。</p><h1 id="G1的GC模式"><a href="#G1的GC模式" class="headerlink" title="G1的GC模式"></a>G1的GC模式</h1><p> <strong>1.YoungGC年轻代收集</strong><br>在分配一般对象（非巨型对象）时，当所有eden region使用达到最大阀值并且无法申请足够内存时，会触发一次YoungGC。每次younggc会回收所有Eden以及Survivor区，并且将存活对象复制到Old区以及另一部分的Survivor区。</p><p><strong>YoungGC的回收过程如下：</strong></p><ul><li>根扫描,跟CMS类似，Stop the world，扫描GC Roots对象。</li><li>处理Dirty card,更新RSet.</li><li>扫描RSet,扫描RSet中所有old区对扫描到的young区或者survivor去的引用。</li><li>拷贝扫描出的存活的对象到survivor2/old区</li><li>处理引用队列，软引用，弱引用，虚引用</li></ul><p><strong>2. mixed gc</strong></p><p>当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc，该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region，这里需要注意：是一部分老年代，而不是全部老年代，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制。</p><p>G1没有fullGC概念，需要fullGC时，调用serialOldGC进行全堆扫描（包括eden、survivor、o、perm）。</p><h1 id="G1与CMS的区别"><a href="#G1与CMS的区别" class="headerlink" title="G1与CMS的区别"></a>G1与CMS的区别</h1><ol><li><p>CMS中，堆被分为PermGen，YoungGen，OldGen；而YoungGen又分了两个survivo区域。在G1中，堆被平均分成几个区域(region)，在每个区域中，虽然也保留了新老代的概念，但是收集器是以整个区域为单位收集的。</p></li><li><p>CMS是一款“标记–清除”算法实现的收集器，容易出现大量空间碎片。当空间碎片过多，将会给大对象分配带来很大的麻烦,而G1则不会容易产生大量空间碎片。</p></li><li><p>G1会在Young GC和Mixed GC中使用、而CMS只能在O区使用。(有待商榷，上文中讲CMS也会在年轻代中处理)</p></li><li><p>G1能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒</p></li><li><p>在空间整理方面，与CMS的“标记–清理”算法不同，G1从整体上来看是基于“标记-整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;G1是一款面向服务器应用的垃圾收集器，目标是用在多核、大内存的机器上。&lt;br&gt;它在满足高吞吐量的同时满足GC停顿的时间尽可能地短。&lt;br&gt;应用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以像CMS收集器一样可以和应用并发运行&lt;/li&gt;
&lt;li&gt;压缩空闲的内存碎片，却不需要冗长的GC停顿。&lt;/li&gt;
&lt;li&gt;对GC停顿可以做更好的预测&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="jvm" scheme="https://github.com/spurstong/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://github.com/spurstong/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm垃圾收集器</title>
    <link href="https://github.com/spurstong/2019/07/17/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://github.com/spurstong/2019/07/17/jvm垃圾收集器/</id>
    <published>2019-07-17T01:08:27.000Z</published>
    <updated>2019-08-16T11:03:51.528Z</updated>
    
    <content type="html"><![CDATA[<p>收集算法是内存回收的方法论，而垃圾收集器就是内存回收的具体实现。主要垃圾收集器分为下面几种，而G1收集器将在另一篇文章中介绍。</p><a id="more"></a><p>收集算法是内存回收的方法论，而垃圾收集器就是内存回收的具体实现。主要垃圾收集器分为下面几种，而G1收集器将在另一篇文章中介绍。</p><h1 id="serial收集器"><a href="#serial收集器" class="headerlink" title="serial收集器"></a>serial收集器</h1><p>是一个单线程的收集器，在它进行垃圾回收时，必须暂停其他所有的工作线程，直到它收集结束。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/1.png" alt="1.png"><br>但它依然是虚拟机运行在Client模式下的默认新生代收集器。它 有着优于其他收集器的地方：简单而高效（与其他收集器的单线程相比）。在单个CPU的环境下，serial收集器由于没有线程交互的开销</p><h1 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h1><p>ParNew收集器其实是Serial收集器的多线程版本<br>它是运行在Server模式下的虚拟机中首选的新生代收集器，除了Serial收集器外，目前只有它能与CMS收集器配合工作。<br>ParNew收集器在单CPU的环境下绝对不会有比Serial收集器更好的效果，但是随着使用的CPU数量的增加，它对于GC时环境资源的有效利用还是很有好处的。<br>tips：<br>并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待线程<br>并发：用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续执行，而垃圾收集程序运行于另一个CPU上</p><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/3.png" alt="3.png"></p><h1 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h1><ol><li>它是一个新生代收集器，它也是使用复制算法的收集器</li><li>它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时<strong>用户线程的停顿时间</strong>，而Parallel Scavenge收集器的目标是达到一个可控制的<strong>吞吐量</strong></li><li>-XX:MaxGCPauseMillis 控制最大垃圾收集停顿时间， -XX：GCTimeRatio 设置吞吐量的大小<br>GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的<br>GCTimeRatio的参数的值应当是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。默认值为99，就是允许最大1%（即1/(1+99)）的垃圾收集时间</li><li>它也被称为“吞吐量优先”收集器。它还有一个参数-XX: +UseAdaptiveSizePolicy,这是一个开关参数，虚拟机会根据当前系统的运行情况收集性能控制信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式成为GC自适应的调节策略，自适用调节策略也是Parallel Scavenge收集器与parNew收集器的一个重要区别。<h1 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h1>注释：下面的内容是引用的阿里云云栖社区的一篇文章，感谢分享<br>大多数文章中写到它是针对老年代的收集器，但实际上它也管理新生代，它管理新生代的方式与Parallel收集器和Serial收集器相同，而在老年代则是尽可能地并发执行，每个垃圾收集器周期只有两次短停顿。</li></ol><ul><li>它设计的初衷是为了消除Throught收集器和Serial收集器在<strong>Full GC周期中的长时间停顿</strong>。</li><li>使用场景： 更快的响应，不希望有长时间的停顿，同时你的CPU资源也比较丰富<br>它有四个步骤： <strong>初始标记</strong>、<strong>并发标记</strong>、<strong>再次标记</strong>和<strong>并发清除</strong></li></ul><ol><li>初始标记： 标记从GC Root直接可达的老年代对象、新声代引用的老年代对象，就是下图中灰色的点，这个过程是单线程的（JDK7之前是单线程，JDK8之后是并行，可以通过<em>CMSParallelInitialMarkEnabled</em>调整）<br>通过-XX:+CMSParallelInitialMarkEnabled参数可以开启该阶段的并行标记，使用多个线程进行标记，减少暂停时间。</li></ol><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/2.png" alt="2.png"></p><ol start="2"><li>并发标记：由上一个阶段标记过的对象，开始tracing过程，标记所有可达的对象，这个阶段垃圾回收线程和应用线程同时运行，在并发标记过程中，应用线程还在跑，因此会导致有些对象从新生代晋升到老年代，有些老年代的对象引用会被改变、有些对象会直接分配到老年代，这些受影响的老年代对象所在的card会被标记为dirty，用于重新标记阶段扫描。在这个阶段中，老年代对象的card被标记为dirty的可能原因，就是下图中绿色的线：<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/jvm%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/4.png" alt="4.png"></li><li>预清理： 也是用于标记老年代存活的对象，目的是为了让重新标记阶段的STW尽可能短。这个阶段的目标是在并发标记阶段被应用线程影响到的老年代对象，包括：老年代中card为dirty的对象 ，幸存区（from和to）中引用的老年代对象，因此，这个阶段也需要扫描新生代+老年代</li><li>可中断的预清理：这个阶段的目标跟“预清理”阶段相同，也是为了减轻重新标记阶段的工作。<br>在预清理步骤后，如果满足下面两个条件，就不会开启可中断的预清理，直接进入重复标记阶段。</li></ol><ul><li>Eden的使用空间大于“CMSScheduleRemarkEdenSizeThreshold”,这个参数的默认值是2M</li><li>Eden的使用率大于等于“CMSScheduleRemarkEdenPenetration”,这个参数的默认值是50%<br>如果不满足上面两个条件，则进入可中断的预处理，可中断预处理可能会执行多次。</li></ul><ol start="5"><li>重新标记：重新扫描堆中的对象，进行可达性分析，标记活着的对象。这个阶段扫描的目标是：新生代的对象 + GC Roots + 前面被标记为dirty的card对应的老年代对象。这个过程是多线程的</li><li>并发清除：用户线程被重新激活，同时将那些未被标记为存活的对象标记为不可达</li><li>并发重置： CMS内部重置回收器状态，准备进入下一个并发回收周期</li></ol><h1 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h1><ul><li>并发模式失败（Concurrent mode failure）：CMS的目标就是在回收老年代对象的时候不要停止全部应用线程，在并发周期执行期间，用户的线程依然在运行，如果这时候如果应用线程向老年代请求分配的空间超过预留的空间（担保失败），就回触发concurrent mode failure，然后CMS的并发周期就会被一次Full GC代替——停止全部应用进行垃圾收集，并进行空间压缩。如果我们设置了<strong>UseCMSInitiatingOccupancyOnly</strong>和<strong>CMSInitiatingOccupancyFraction</strong>参数，其中<strong>CMSInitiatingOccupancyFraction</strong>的值是70，那预留空间就是老年代的30%。</li><li>CMS是基于‘’标记–清除‘’算法实现的收集器，在收集结束后可能会产生大量空间碎片。空间碎片过多，将会给大对象分配带来很大麻烦，当无法找到足够大的连续空间来分配当前对象，不得不提前触发一次full gc。为了解决这个问题，CMS收集器提供了一个参数-xx + UseCMSCompactAtFullCollection(默认是开启的)，在进行Full GC时开启<strong>内存碎片的合并整理过程</strong>，内存整理的过程是<strong>无法并发</strong>的，空间碎片问题没有了，但停顿时间不得不变长。<br>还提供了另外一个参数 <em>-XX: CMSFullGcsBeforeCompaction</em>,这个参数用于设置执行了多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进入Full GC时都进行碎片整理）<br>由于并发收集器不对内存空间进行压缩,整理,所以运行一段时间以后会产生”碎片”,使得运行效率降低.此值设置运行多少次GC以后对内存空间进行压缩,整理。<ul><li>永久代空间（或Java8的元空间）耗尽，默认情况下,CMS不会对永久代进行收集，一旦永久代空间耗尽，就回触发Full GC。 <h1 id="CMS的调优"><a href="#CMS的调优" class="headerlink" title="CMS的调优"></a>CMS的调优</h1></li></ul></li></ul><ol><li>针对并发模式失败的调优</li></ol><ul><li>尽可能地增大老年代的空间，增加整个堆的大小，或者减少年轻代的大小</li><li>以更高的频率执行后台的回收线程，即提高CMS并发周期发生的概率。设置<em>seCMSInitiatingOccupancyOnly</em>和<em>CMSInitiatingOccupancyFraction</em>参数，</li></ul><p><em>seCMSInitiatingOccupancyOnly</em> –&gt; 使用手动定义初始化定义开始CMS收集，系统是禁止hostspot自行出发CMS GC的<br><em>XX:CMSInitiatingOccupancyFraction=70</em> –&gt; 使用cms作为垃圾回收使用70%后开始CMS收集，但是这个值也不能调的太低，太低了会导致过多的无效的并发周期，会导致消耗CpU时间和更多的无效的停顿。</p><ul><li>增多回收线程的个数<br>CMS默认的垃圾收集线程数是 <em>（CPU个数 + 3）/4</em>，这个公式的含义是：当CPU个数大于4个的时候，垃圾回收后台线程至少占用25%的CPU资源。举个例子：如果CPU核数是1-4个，那么会有1个CPU用于垃圾收集，如果CPU核数是5-8个，那么久会有2个CPU用于垃圾收集。</li><li>针对永久代的调优<br>如果永久代需要垃圾回收（或元空间扩容），就会触发Full GC。默认情况下，CMS不会处理永久代中的垃圾，可以通过开启<em>CMSPermGenSweepingEnabled</em>配置来开启永久代中的垃圾回收，开启后会有一组后台线程针对永久代做收集，需要注意的是，触发永久代进行垃圾收集的指标跟触发老年代进行垃圾收集的指标是独立的，老年代的阈值可以通过<em>CMSInitiatingPermOccupancyFraction</em>参数设置，这个参数的默认值是80%。开启对永久代的垃圾收集只是其中的一步，还需要开启另一个参数——<em>CMSClassUnloadingEnabled</em>，使得在垃圾收集的时候可以卸载不用的类</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集算法是内存回收的方法论，而垃圾收集器就是内存回收的具体实现。主要垃圾收集器分为下面几种，而G1收集器将在另一篇文章中介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="jvm" scheme="https://github.com/spurstong/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://github.com/spurstong/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>java虚拟机内存模型及垃圾</title>
    <link href="https://github.com/spurstong/2019/07/15/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://github.com/spurstong/2019/07/15/java虚拟机内存模型/</id>
    <published>2019-07-15T13:04:20.000Z</published>
    <updated>2019-08-16T11:03:30.803Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p><a id="more"></a><p>jvm是什么，百度百科这样写道：<br>虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。<br>简单通俗的说，jvm类似一个中间件，为程序和各个操作系统之间架起了一个桥梁，不需要为特定的系统编写特定的代码。</p><h1 id="jvm内存模型"><a href="#jvm内存模型" class="headerlink" title="jvm内存模型"></a>jvm内存模型</h1><p>jvm主要包括五大模块，类装载器子系统、运行时数据区、执行引擎、本地方法接口和垃圾收集模块。<br>在本节中主要讲解运行时数据区的数据结构。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1.png" alt="1.png"></p><ul><li>程序计数器</li></ul><ol><li>是线程私有的，各个线程之间计数器互不影响，独立存储</li><li>如果线程执行的是java方法，则记录的是正在执行的虚拟机字节码指令的地址；如果执行的是Native方法，这个计数器值为空。</li><li>是唯一一个在jvm规范中没有规定任何OutOfMemoryError情况的区域</li></ol><ul><li>虚拟机栈</li></ul><ol><li>线程私有的，生命周期与线程相同</li><li>当执行一个方法时，都会创建一个栈帧</li><li>可以存储局部变量表、操作数栈、动态链接和方法出口等<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/2.png" alt="2.png"></li></ol><ul><li>本地方法栈</li></ul><ol><li>线程私有的</li><li>与虚拟机栈的作用类似，当执行Native方法时会用到</li></ol><ul><li>java堆</li></ul><ol><li>是内存管理中最大的一块</li><li>存放的是对象的实例和数组对象</li><li>java堆按照生命周期的不同，划分为新生代和老年代。当新生代中经过多次垃圾回收仍然存活的对象九华转化成老年代 。</li><li>年轻代又分为Eden和Survivor区。Survivor区由FromSpace和ToSpace组成。Eden区占大容量，Survivor两个区占小容量，默认比例是8:1:1</li><li>新生成的对象首先放到年轻代Eden区，当Eden空间满了，触发Minor GC，存活下来的对象移动到Survivor0区，Survivor0区满后触发执行Minor GC，Survivor0区存活对象移动到Suvivor1区，这样保证了一段时间内总有一个survivor区为空。经过多次Minor GC仍然存活的对象移动到老年代。</li><li>老年代存储长期存活的对象，占满时会触发Major GC = Full GC，GC期间会停止所有线程等待GC完成，</li><li>将对象根据存活概率进行分类，对存活时间长的对象，放在固定区，从而减少扫描垃圾时间及GC频率，针对分类进行不同的垃圾回收算法。</li><li>在新生代中，每次垃圾收集中都会发现大批对象死去，只有少量存活，所有采用了复制算法</li><li>而老年代中因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记–清理”或者“标记–整理“算法进行回收。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/3.png" alt="3.png"></li></ol><ul><li>方法区</li></ul><ol><li>是各个线程共享的内存区域</li><li>非堆内存，用于存储已被虚拟机加载的类信息、常量、静态变量等。</li><li>在jdk1.8中废除了方法区，替代是元空间，它的本质和方法区类似，但它并不在虚拟机中，而是在本地内存中，默认情况下，元空间的大小仅受本地内存的限制。</li></ol><h1 id="HotSpot虚拟机对象"><a href="#HotSpot虚拟机对象" class="headerlink" title="HotSpot虚拟机对象"></a>HotSpot虚拟机对象</h1><ol><li>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在<strong>常量池</strong>中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被<strong>加载、解析和初始化</strong>过，如果没有，那必须先执行相应的类加载过程。</li><li>在为新生对象分配空间时，主要有两种方式。<strong>指针碰撞</strong>和<strong>空闲列表</strong></li><li>并发情况下的对象创建问题。为了保证操作的正确性，一种采取对分配内存空间的动作进行同步处理-实际上虚拟机采用CAS配上失败重试的方法保证更新操作的原子性；另一种是把内存分配的动作按照<strong>线程</strong>划分到不同的空间之中进行，即每个线程在java堆中预先分配一小块内存，称为本地线程分配缓冲（TLAB）。哪个线程要分配内存，就在哪个线程的TLAb上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/4.png" alt="4.png"></li></ol><ul><li>对象的内存布局<br>在hotspot虚拟机中，主要分为3块区域：对象头、实例数据和对齐填充<br>对象头主要分为两部分信息，一部分是存储对象自身的运行时数据，另一部分是类型指针。</li></ul><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/5.png" alt="5.png"></p><ul><li>对象的访问定位<br>java程序通过栈上的reference数据来操作堆上的具体对象。它是一个指向对象的引用，但如何通过这个引用去定位、访问堆中的具体对象，这是不确定的，取决于虚拟机的类型。当前主要有两种方式：<strong>使用句柄</strong>和<strong>直接指针</strong></li></ul><ol><li>使用句柄，会在java堆中划分出一块内存来作为<strong>句柄池</strong>，在句柄中包含了对象实例数据和对象类型数据的地址信息。</li></ol><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/6.png" alt="6.png"></p><ol start="2"><li>使用直接指针访问，在reference中存储的是<strong>对象地址</strong>,在对象实例数据中存储了到对象类型数据的指针。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/7.png" alt="7.png"><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1>利用垃圾收集器对堆进行回收前，首先要确定的是哪些对象还存活着，哪些对象已经“死去”。<br>起初典型的算法是<strong>引用计数算法</strong> ，它为每个对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1，当计数器为0时就是不可能再被使用了。但在某些情况下会出现一些错误，当对象间有相互循环引用时，会相互引用着对方，导致它们的引用计数都不为0。</li></ol><p><strong>可达性分析算法</strong><br>该算法通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/8.png" alt="8.png"><br>在java语言中，可作为GC Roots的对象有下面几种：</p><ul><li><strong>虚拟机栈</strong>（栈帧中的本地变量表）中的引用对象</li><li>方法区中<strong>类静态属性</strong>引用的对象</li><li>方法区中<strong>常量</strong>引用的对象</li><li>本地方法栈JNI(即一般说的Native方法)引用的对象</li></ul><p><strong>一个对象真正死亡，至少要经历两次标记记录</strong><br>第一次： 在进行可达性分析后发现没有与GC Roots相连接的引用链，那它会被第一次标记并进行筛选，筛选的条件是此对象是否有必要执行的finalize()方法。当对象没有覆盖finalize()方法或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。<br>第二次： 当这个对象被判定为有必要执行finalize()方法 ，那么这个对象将会放置在一个F-Queue的队列中，如果该对象重新与<strong>引用链</strong>上的任意一个对象建立关联时，它就可以从“即将回收”的集合中移除。</p><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><ol><li>标记-清除算法<br>首先标记出所有需要回收的对象，在标记完成后统一回收所有所标记的对象</li></ol><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/9.png" alt="9.png"></p><ol start="2"><li>复制算法<br>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完时，就将还存活的对象复制到另外一块上，然后再把已使用过的内存空间一次清理掉。</li></ol><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/10.png" alt="10.png"></p><ol start="3"><li>标记-整理算法<br>当标记完待回收对象后，让所有存活的对象都向一端移动，然后直接清理掉端边界意外的内存，</li></ol><p><strong>不是直接对可回收对象进行清理。</strong><br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/11.png" alt="11.png"></p><ol start="4"><li>分代收集算法<br>新生代采用复制算法，在老年代采用“标记－清除”或者“标记－整理”算法。新生代分为Eden区和两个相同大小的Survivor区，</li></ol><p><strong>所有新创建的对象都分配在Eden区域中</strong>。当Eden区域满后会触发minor GC，将Eden区仍然存活的对象复制到其中一个Survivor区域中，另外一个Survivor区中的存活对象也复制到这个Survivor区域中，并始终保持一个Survivor区是空的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虚拟机是一种抽象化的计算机，通过在实际的计算机上仿真模拟各种计算机功能来实现的。Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。Java虚拟机屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。&lt;/p&gt;
    
    </summary>
    
      <category term="jvm" scheme="https://github.com/spurstong/categories/jvm/"/>
    
    
      <category term="jvm" scheme="https://github.com/spurstong/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>线程间通信之wait、notify</title>
    <link href="https://github.com/spurstong/2019/07/02/%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E4%B9%8Bwait%E3%80%81notify/"/>
    <id>https://github.com/spurstong/2019/07/02/线程间通信之wait、notify/</id>
    <published>2019-07-02T07:17:44.000Z</published>
    <updated>2019-08-16T11:07:26.569Z</updated>
    
    <content type="html"><![CDATA[<p>wait方法和notify方法并不是Thread特有的方法，而是Object中的方法。<br><strong>wait方法介绍</strong></p><ul><li>wait方法必须拥有该对象的monitor,也就是wait方法必须在同步方法中使用。</li><li>当前线程执行了该对对象的wait方法之后，就会放弃对该monitor的所有权并进入与该对象关联的wait set中。<a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1></li><li>Object.wait() – 暂停一个线程</li><li>Object.notify() – 唤醒一个线程<br>wait方法和notify方法并不是Thread特有的方法，而是Object中的方法。</li></ul><p><strong>wait方法介绍</strong></p><ul><li>wait方法必须拥有该对象的monitor,也就是wait方法必须在同步方法中使用。</li><li>当前线程执行了该对对象的wait方法之后，就会放弃对该monitor的所有权并进入与该对象关联的wait set中。</li><li>它会使当前执行wait()方法的线程等待，在wait()所在的代码行处暂停执行，并释放锁，直到接到通知或被中断为止。</li></ul><p><strong>notify方法介绍</strong></p><ul><li>唤醒单个正在执行该对象wait方法的线程</li><li>在调用前，线程必须获得锁</li><li>在执行notify()方法后，当前线程不会马上释放该锁，呈wait状态的线程也不会马上获取该对象锁，要等到执行notify()方法的线程将程序执行完，当前线程才会释放锁，而呈wait状态的线程才可以获取该对象锁</li></ul><p><strong>wait/notify机制简单实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">            Test test = <span class="keyword">new</span> Test();</span><br><span class="line">            Test.MyThread1 t1 = test.new MyThread1(lock);</span><br><span class="line">            t1.start();</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            Test.MyThread2 t2 = test.new MyThread2(lock);</span><br><span class="line">            t2.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyThread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object lock;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyThread1</span><span class="params">(Object lock)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"开始 wait"</span>);</span><br><span class="line">                    lock.wait();</span><br><span class="line">                    System.out.println(<span class="string">"结束 wait"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object lock;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyThread2</span><span class="params">(Object lock)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"开始 notify"</span>);</span><br><span class="line">                lock.notify();</span><br><span class="line">                System.out.println(<span class="string">"结束 notify"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>输出结果：<br>开始 wait<br>开始 notify<br>结束 notify<br>结束 wait</p><hr><h1 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h1><p>wait/notify模式最经典的案例就是生产者/消费者模式，</p><ol><li>一生产与一消费：操作值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String value = <span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            Test test = <span class="keyword">new</span> Test();</span><br><span class="line">            String lock1 = <span class="string">""</span>;</span><br><span class="line">            P p = test.new P(lock1);</span><br><span class="line">            C c = test.new C(lock1);</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">                        p.setValue();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">                        c.getValue();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t1.start();</span><br><span class="line">            t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String lock;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">P</span><span class="params">(String lock)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!value.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    String value1 = System.currentTimeMillis() + <span class="string">"_"</span> + System.nanoTime();</span><br><span class="line">                    System.out.println(<span class="string">"set的值是"</span> + value1);</span><br><span class="line">                    value = value1;</span><br><span class="line">                    lock.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String lock;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">C</span><span class="params">(String lock)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.lock = lock;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(value.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"get的值是： "</span> + value);</span><br><span class="line">                    value = <span class="string">""</span>;</span><br><span class="line">                    lock.notify();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><p>运行结果：<br>set的值是1561896621397_10607393925500<br>get的值是： 1561896621397_10607393925500<br>set的值是1561896621397_10607394242800<br>get的值是： 1561896621397_10607394242800<br>set的值是1561896621397_10607394359900<br>get的值是： 1561896621397_10607394359900<br>set的值是1561896621397_10607394414900<br>get的值是： 1561896621397_10607394414900<br>set的值是1561896621397_10607394486700<br>get的值是： 1561896621397_10607394486700</p><hr><p>当在多个生产者与多个消费者的情况下,操作值可能出现假死状态，即所有的线程都是waiting状态<br>在代码中进行wait/notify通信时，但不能保证notify唤醒的是异类，也许是同类，如“生产者”唤醒“生产者”，“消费者”唤醒“消费者”，慢慢的，大家都在等待，都呈waiting状态，程序最后就呈“假死”状态。</p><ol start="2"><li>一生产与多消费（解决wait条件改变与假死）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.SQLOutput;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String value = <span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            Test test = <span class="keyword">new</span> Test();</span><br><span class="line">            MyStack myStack = test.new MyStack();</span><br><span class="line">            P p = test.new P(myStack);</span><br><span class="line">            C c1 = test.new C(myStack);</span><br><span class="line">            C c2 = test.new C(myStack);</span><br><span class="line">            C c3 = test.new C(myStack);</span><br><span class="line">            C c4 = test.new C(myStack);</span><br><span class="line">            C c5 = test.new C(myStack);</span><br><span class="line">            Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        p.pushService();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread ct1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        c1.popService();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        Thread ct2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    c2.popService();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread ct3 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    c3.popService();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread ct4 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    c4.popService();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread ct5 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    c5.popService();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">            t1.start();</span><br><span class="line">            ct1.start();</span><br><span class="line">            ct2.start();</span><br><span class="line">            ct3.start();</span><br><span class="line">            ct4.start();</span><br><span class="line">            ct5.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> MyStack myStack;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">P</span><span class="params">(MyStack myStack)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.myStack = myStack;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            myStack.push();</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> MyStack myStack;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">C</span><span class="params">(MyStack myStack)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            <span class="keyword">this</span>.myStack = myStack;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"pop="</span> + myStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyStack</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (list.size() == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                list.add(<span class="string">"anyString="</span> + Math.random());</span><br><span class="line">                <span class="keyword">this</span>.notify();</span><br><span class="line">                System.out.println(<span class="string">"push="</span> + list.size());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            String returnValue = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (list.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"pop操作中的"</span> + Thread.currentThread().getName() + <span class="string">"线程呈wait状态"</span>);</span><br><span class="line">                    <span class="keyword">this</span>.wait();</span><br><span class="line">                &#125;</span><br><span class="line">                returnValue = <span class="string">""</span> + list.get(<span class="number">0</span>);</span><br><span class="line">                list.remove(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">this</span>.notify();</span><br><span class="line">                System.out.println(<span class="string">"pop="</span> + list.size());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> returnValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><p>运行结果：<br>push=1<br>pop=0<br>pop=anyString=0.22470100376922753<br>pop操作中的Thread-5线程呈wait状态<br>pop操作中的Thread-4线程呈wait状态<br>pop操作中的Thread-3线程呈wait状态<br>pop操作中的Thread-2线程呈wait状态<br>pop操作中的Thread-1线程呈wait状态<br>push=1<br>pop=0<br>pop=anyString=0.9533790755608161<br>pop操作中的Thread-5线程呈wait状态<br>Exception in thread “Thread-4” java.lang.IndexOutOfBoundsException: Index: 0, Size: 0<br>    at java.util.ArrayList.rangeCheck(ArrayList.java:657)<br>    at java.util.ArrayList.get(ArrayList.java:433)<br>    at Test$MyStack.pop(Test.java:119)<br>    at Test$C.popService(Test.java:93)<br>    at Test$5.run(Test.java:54)<br>    at java.lang.Thread.run(Thread.java:748)</p><hr><p>主要是pop()方法的if判断条件，因为刚一开始只往数组里放进了一个元素，然后相继执行了5个消费者线程，第一个成功删除，数组大小又重新变成了0，剩余的消费者线程变成了wait(),然后生产者又放入了一个元素，消费者再执行删除操作，并调用了notify方法，因为前面有消费者呈wait状态，所以被唤醒，执行删除操作，但此时的数组为空，所以会报错。<br>只需将pop()方法中的<strong>if变成while</strong>即可。</p><h1 id="join方法的使用"><a href="#join方法的使用" class="headerlink" title="join方法的使用"></a>join方法的使用</h1><p>join()方法的作用是使所属的线程对象x正常执行run()方法中的任务，而使当前线程z进行无限期的阻塞，等待线程x销毁后再继续执行线程Z后面的代码。<br>join方法具有使线程排队运行的效果，有些类似同步的运行效果，但是join()方法与synchronized的区别是join()方法在内部使用wait()方法进行等待，而synchronized关键字使用锁作为同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object oo = <span class="keyword">new</span> Object();</span><br><span class="line">        MyThread t1 = <span class="keyword">new</span> MyThread(<span class="string">"线程t1--"</span>, oo);</span><br><span class="line">        MyThread t2 = <span class="keyword">new</span> MyThread(<span class="string">"线程t2--"</span>, oo);</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Object oo;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name,Object oo)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.oo = oo;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (oo) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                System.out.println(name + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>运行结果：<br>线程t2–0<br>线程t2–1<br>线程t2–2<br>线程t2–3<br>线程t2–4<br>线程t2–5<br>线程t2–6<br>线程t2–7<br>线程t2–8<br>线程t2–9<br>线程t1–0<br>线程t1–1<br>线程t1–2<br>线程t1–3<br>线程t1–4<br>线程t1–5<br>线程t1–6<br>线程t1–7<br>线程t1–8<br>线程t1–9<br>结束</p><hr><p>主线程main执行了t2.start()和t1.start()两行代码之后，创建了t2线程和t1线程，它们竞争oo这把锁，谁拿锁谁执行。首先，t2获得了该锁，t2执行完之后t1再开始执行，再从上一层次考虑的话，主线程main获得了t1这把锁。main线程继续执行了t1.join()方法，join()方法会使<strong>当前执行的线程等待</strong> ， 即让主线程main等待，主线程等到t1线程执行完成后，再继续执行。<br>通俗的讲就是：若线程A(main线程)调用线程B(t1线程)的join方法，那么线程A(main调用了t1.wait()被阻塞)的运行会被暂停，直到线程B(t1线程)运行结束。<br>实际上，调用join方法实际上调用了wait()方法。<br>x.join(long)中的参数用于设定等待的时间，不管x线程是否执行完毕，时间到了重新获得了锁，则当前线程会继续向后运行。如果没有重新获得锁，则一直在尝试，直到获得锁为止。</p><figure class="highlight java"><figcaption><span>join方法源代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">      <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">              wait(<span class="number">0</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">              <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">              <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              wait(delay);</span><br><span class="line">              now = System.currentTimeMillis() - base;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="join-long-方法与sleep-long-方法的区别"><a href="#join-long-方法与sleep-long-方法的区别" class="headerlink" title="join(long)方法与sleep(long)方法的区别"></a>join(long)方法与sleep(long)方法的区别</h1><p>两种方法都可以使当前线程进入阻塞状态<br>当执行wait(long)方法时，会使当前执行的线程被释放，等其他线程执行完成后，该线程则会被唤醒<br>而Thread.sleep(long)方法却不释放锁，等休眠时间过后，会自动退出阻塞状态而重新恢复运行。</p><p><strong>一道面试题</strong><br>利用java的wait、notify机制实现启动两个线程, 一个输出 1,3,5,7…99, 另一个输出 2,4,6,8…100 最后 STDOUT 中按序输出 1,2,3,4,5…100</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object flag = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadTest threadTest = <span class="keyword">new</span> ThreadTest();</span><br><span class="line">        ThreadA threadA = threadTest.new ThreadA();</span><br><span class="line">        threadA.start();</span><br><span class="line">        ThreadB threadB = threadTest.new ThreadB();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">                    flag.notify();</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        flag.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"error A"</span>);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">                    flag.notify();</span><br><span class="line">                    System.out.println(i);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        flag.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"error B"</span>);</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                flag.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;wait方法和notify方法并不是Thread特有的方法，而是Object中的方法。&lt;br&gt;&lt;strong&gt;wait方法介绍&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;wait方法必须拥有该对象的monitor,也就是wait方法必须在同步方法中使用。&lt;/li&gt;
&lt;li&gt;当前线程执行了该对对象的wait方法之后，就会放弃对该monitor的所有权并进入与该对象关联的wait set中。
    
    </summary>
    
      <category term="并发" scheme="https://github.com/spurstong/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://github.com/spurstong/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入理解volatile</title>
    <link href="https://github.com/spurstong/2019/06/29/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile/"/>
    <id>https://github.com/spurstong/2019/06/29/深入理解volatile/</id>
    <published>2019-06-29T08:55:58.000Z</published>
    <updated>2019-08-16T11:07:47.943Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机中，所有的运算操作都是由CpU的寄存器来完成的，在CPU Cache模型没出来之前，CPU所访问的数据只能是计算机的主存，但CPU本身的计算速度与主内存的读写速度远远不一致，所以在中间添加了Cache模型，在程序运行的时候，程序会把从内存中读取的数据*</p><a id="more"></a><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><p>在计算机中，所有的运算操作都是由CpU的寄存器来完成的，在CPU Cache模型没出来之前，CPU所访问的数据只能是计算机的主存，但CPU本身的计算速度与主内存的读写速度远远不一致，所以在中间添加了Cache模型，在程序运行的时候，程序会把从内存中读取的数据<strong>复制</strong>一份到Cache中，然后直接对CPU cache中的数据进行读取和写入，当运算结束后，再将CPU cache中的<strong>最新数据刷新</strong>到主内存中。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile/1.png" alt="cpu通过Cache与主内存进行交互.png"></p><p>但在多线程情况下，利用该机制，可能会出现缓存不一致的现象。<br>典型的解决办法有：</p><ul><li><p>通过总线加锁，只允许一个CPU抢到总线锁，来访问这个变量的内存。</p></li><li><p>通过缓存一致性协议<br>例如：在读取操作时，不做任何处理，只是将Cache中的数据读取到寄存器中<br>在写入操作时，通知其他CPU将该变量的Cache line置为无效状态，其他CPU在进行该变量读取时不得不到主内存中再次获取。</p></li></ul><ul><li><p>共享变量存储在主内存当中，每个线程都可以访问。</p></li><li><p>每个线程都有私有得到工作内存。</p></li><li><p>工作内存只存储该线程对共享变量的副本。</p></li><li><p>线程不能直接操作主内存，只有先操作了工作内存才能写入到主内存。</p></li></ul><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3volatile/2.png" alt="java内存模型.png"></p><h1 id="并发编程的三个重要特性"><a href="#并发编程的三个重要特性" class="headerlink" title="并发编程的三个重要特性"></a>并发编程的三个重要特性</h1><ul><li>原子性<br>指在一次的操作或多次的操作中，要么所有的操作都执行并不会受到任何元素的干扰而中断，要么所有的操作都不执行<br>note: 两个原子性的操作结合在一起未必还是原子性的， 例如i++</li><li>可见性<br>当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值</li><li>有序性<br>是指程序代码在执行过程中的先后顺序，<br>有时，处理器为了提高程序的运行效率，可能会对输入的指令做一定的优化，它不会完全按照代码的执行顺序进行，但是它会保证程序的最终运算结果是编码时所期望的那样，即指令的重排序<br>在单线程情况下，无论怎样的重排序最终都会保证程序的执行效果和代码顺序执行的结果是完全一致的，但是在多线程情况下，如果有序性得不到保证，那么很有可能会出现很大的问题</li></ul><h1 id="JMM与原子性"><a href="#JMM与原子性" class="headerlink" title="JMM与原子性"></a>JMM与原子性</h1><p>在Java中，对基本数据类型的变量读取赋值操作都是原子性的，对引用类型的变量读取和赋值的操作也是原子性的。</p><ul><li>x = 10 是原子性的<br>首先将x=10写入到工作内存中，然后再将其写入到主内存中</li><li>y = x 是非原子性的<ol><li>从主内存中读取x的值（如果x已经在执行线程的工作内存中，则直接获取）然后将其存入当前线程的工作内存中</li><li>在执行线程的工作内存中修改y的值为x,然后将y的值写入到主内存中</li></ol></li><li>y++ 是非原子性的<ol><li>执行线程从主内存中读取y的值（如果y已经存在了执行线程的工作内存中，则直接获取），然后将其内存当前线程的工作内存之中。</li><li>在执行线程工作内存中为y执行加1操作</li><li>将y的值写入到主内存中</li></ol></li><li>z = z + 1 是非原子性的<br>同上</li></ul><h1 id="jMM与可见性"><a href="#jMM与可见性" class="headerlink" title="jMM与可见性"></a>jMM与可见性</h1><p>java中提供了以下三种方式来保证可见性</p><ul><li>使用关键字volatile,对数据的读操作直接在主内存中读取（当然也会缓存到工作内存中，当其他线程对该共享线程进行了修改，则会导致当前线程在工作内存中的共享资源失效，所以必须从主内存中再次获取），对于共享资源的写操作当然是先要修改工作内存，但是修改结束后会立即将其刷新到主内存中</li><li>通过synchronized关键字能够保证可见性，同一时刻只有一个线程获得锁</li><li>通过JUC提供的显式锁Lock也能保证可见性</li></ul><h1 id="volatile关键字解析"><a href="#volatile关键字解析" class="headerlink" title="volatile关键字解析"></a>volatile关键字解析</h1><p>该类变量具备下面两层语义：</p><ol><li>保证了不同线程之间对共享变量操作时的可见性，也就是说当一个线程修改volatile修饰的变量，另一个线程会立即看到最新的值。</li><li>禁止对指令进行重排序操作。<br>但volatile<strong>不具备原子性</strong><br>有一个经典的例子 i++操作<br>如果有两个线程执行该操作时，当一个线程读取到i的当前值后，停止，然后跳转到另一个线程读取i的值，然后执行+1操作，并将值返回到主内存中，有的读者可能会产生这样的疑惑：<br>volatile具有可见性，当一个线程修改后，另一个线程会立即看到最新的值，所以当第一个线程暂停回来后会从主内存中读取到最新的值，并执行+1操作，但实际情况是两个线程的结果是一样的，比如i=10，两个线程执行 volatile i++操作，都得到了11，理想的结果是一个11，一个12，为什么呢？<br>volatile的可见性保证你每次访问到该变量时，都会读取到最新的值，但是并不会更新你已经读的值，它也无法更新你已经读了的值。上文中第一个线程是读取后再停止的，此时i值还没有被修改，当另一个线程修改完成后，该线程继续执行接下来的i+1操作，此时的i已经是已被读的值了，不会到主内存中获取最新的值，保留的是最初的值，所以产生了错误。</li></ol><h1 id="volatile的使用场景"><a href="#volatile的使用场景" class="headerlink" title="volatile的使用场景"></a>volatile的使用场景</h1><ol><li><p>开关控制利用可见性的特点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    public class MyThread extends Thread &#123;</span><br><span class="line">    private volatile boolean started = true;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        while(started) &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void shutdown()&#123;</span><br><span class="line">        this.started = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>状态标记利用了顺序性特点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private volatile boolean init = false;</span><br><span class="line">private Context context;</span><br><span class="line">public Context load() &#123;</span><br><span class="line">    if (!init) &#123;</span><br><span class="line">        context = loadContext();</span><br><span class="line">        init = true; //防止重排序</span><br><span class="line">    &#125;</span><br><span class="line">    return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>Singleton设计模式的double-check也是利用了顺序性特点</li></ol><h1 id="volatile和synchronized"><a href="#volatile和synchronized" class="headerlink" title="volatile和synchronized"></a>volatile和synchronized</h1><ol><li>使用上的区别</li></ol><ul><li>volatile关键字只能用于修饰实例变量或者类变量，不能用于修饰方法以及方法参数和局部变量、常量。</li><li>synchronized关键字不能用于对变量的修饰，只能用于修饰方法或者语句块</li><li>volatile修饰的变量可以为null,synchronized关键字同步语句块的monitor对象不能为null</li></ul><ol start="2"><li>对原子性的保证</li></ol><ul><li>volatile无法保证原子性，但后者可以保证</li></ul><ol start="3"><li>对可见性的保证<br>都能保证多线程间的可见性，但是实现机制不同。</li></ol><ul><li>synchronized借助JVM指令monitor enter和monitor exit</li><li>volatile使用机器指令lock</li></ul><ol start="4"><li>对有序性的保证</li></ol><ul><li>volatile禁止重排序，但后者可能会发生指令重排序的情况</li></ul><ol start="5"><li>线程是否阻塞</li></ol><ul><li>volatile不会使线程陷入阻塞，而后者会发生这种情况</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在计算机中，所有的运算操作都是由CpU的寄存器来完成的，在CPU Cache模型没出来之前，CPU所访问的数据只能是计算机的主存，但CPU本身的计算速度与主内存的读写速度远远不一致，所以在中间添加了Cache模型，在程序运行的时候，程序会把从内存中读取的数据*&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="https://github.com/spurstong/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://github.com/spurstong/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>数据同步与对synchonized的深入理解</title>
    <link href="https://github.com/spurstong/2019/06/25/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%AF%B9synchonized%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>https://github.com/spurstong/2019/06/25/数据同步与对synchonized的深入理解/</id>
    <published>2019-06-25T15:31:34.000Z</published>
    <updated>2019-08-16T11:08:03.294Z</updated>
    
    <content type="html"><![CDATA[<p>在上文中，我写了ReentrantLock有关的代码分析，它是基于Lock基础类的。在Java中一般有两种实现锁的方式，一种是基于Lock的，一种是基于JVM的synchonized锁的，在本文中将要介绍后面一种方式。jDK官网中对它进行了这样的解释：它可以实现一个简单的策略来防止线程干扰和内存一致性错误，如果一个对象对多个线程是可见的，那么对该对象的所有读或者写都将通过同步的方式来继续来进行。</p><a id="more"></a><blockquote><p>前言</p></blockquote><p>在上文中，我写了ReentrantLock有关的代码分析，它是基于Lock基础类的。在Java中一般有两种实现锁的方式，一种是基于Lock的，一种是基于JVM的synchonized锁的，在本文中将要介绍后面一种方式。jDK官网中对它进行了这样的解释：它可以实现一个简单的策略来防止线程干扰和内存一致性错误，如果一个对象对多个线程是可见的，那么对该对象的所有读或者写都将通过同步的方式来继续来进行。<br>它具备下面几个特点</p><ol><li>线程在<strong>解锁前</strong>必须把共享变量的<strong>最新值</strong>刷新到主内存中。</li><li>线程在<strong>加锁时</strong>将清空工作内存中共享变量的值，从而在使用共享变量时需要从主内存中重新获取最新的值</li><li>线程<strong>解锁前</strong>对共享变量的修改在下次<strong>加锁时</strong>对<strong>其他线程</strong>可见</li><li>严格遵守Java happens-before规则，一个monitor exit指令之前必定有一个monitor enter。</li></ol><h1 id="数据不一致问题"><a href="#数据不一致问题" class="headerlink" title="数据不一致问题"></a>数据不一致问题</h1><p>举一个经典的例子，创建两个线程,index=0,执行index++,并打印输出，当大于300时退出程序。<br>理想的状态是index从0逐一变到300，<br>但实际的状况会出现下面几种情况：</p><ul><li>两个线程中的index数据一致，比如都是10</li><li>数据输出出现了跳跃，比如，上一个数据是30，但接下来的一个却是32，丢失了31</li><li>数据超过了300，出现了301<br>对上面情况进行解析：</li><li>线程1执行index+1， 然后被暂停，执行线程2操作，由于线程1并没有对index进行赋值操作，index仍然为原值，并没有增加为10，线程2执行index+1并赋值，变成了10，之后线程执行原来停留的index+1,也为10，出现了数据的重复。</li><li>当线程1和线程2都执行到了index=30的位置，其中线程2将index修改为31后执行输出之前切换到了线程1，执行index+1,index变成了32，并输出，而中间的31却没有被输出</li><li>当index=299的时候，线程1和线程2都看到了条件满足，线程2暂时停顿，线程1中index+1变成了300，之后线程2继续执行，因为它此时已经在条件判断代码块里面，不受条件的控制，执行index+1,就变成了301</li></ul><h1 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h1><p>monitor机制需要几个元素来配合，分别是：</p><ol><li>临界区</li><li>monitor对象及锁</li><li>条件变量以及定义在monitor对象上的wait和signal操作。<br>使用monitor机制主要是为了互斥进入临界区，每个对象都与一个monitor相关联，一个monitor的lock的锁只能被一个线程在同一时间获得。sychronized关键字包含monitor enter和monitor exit两个JVM指令。<br>monitor存在计数器，如果为0，则说明该monitor的lock还没有被获得。某个线程获得后，该计数器会加1，当计数器为0，那就意味着该线程不再拥有该monitor的所有权。</li></ol><h1 id="synchonized出现的锁"><a href="#synchonized出现的锁" class="headerlink" title="synchonized出现的锁"></a>synchonized出现的锁</h1><p>在synchonized中会出现3类锁，偏向锁、轻量级锁和重量级锁。</p><ul><li>偏向锁是指在一段同步代码一直被一个线程访问，那么该线程就会自动获取锁，降低获取锁的代价。</li><li>轻量级锁是指当锁为偏向锁的时候，被另一个线程访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的方法尝试获取锁，不会阻塞，提高性能。</li><li>重量级锁是指当锁为轻量级锁时，另一个线程在自旋，当尝试一定次数之后，还是没有获取到锁，就会进入阻塞，该锁就会变成重量级锁，重量级锁会让其他申请的线程进入阻塞，性能降低。</li></ul><h1 id="synchonized锁的实现"><a href="#synchonized锁的实现" class="headerlink" title="synchonized锁的实现"></a>synchonized锁的实现</h1><p>主要有三种形式：</p><ol><li>修饰实例对象，作用于当前实例加锁，进入同步代码前要获得当前实例的锁</li><li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</li><li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码前获得给定对象的锁</li></ol><p><strong>对象锁(synchonized method{})和类锁(static synchonized method{})的区别</strong><br>对象锁也叫实例锁，当多个线程访问多个实例时，它们互不干扰，每个对象都拥有自己的锁<br>对象锁能防止在同一时刻多个线程访问同一个对象的synchonized块<br>类锁是一个全局锁，无论多少个对象共享一个锁，当一个线程访问时，其他线程等待。<br>将synchronized关键字加static方法和不加static方法有时可能效果是一样的，但两者有着本质的不同<br>synchronized关键字加static静态方法是将Class类对象作为锁，而synchronized关键字加到非static静态方法是将方法所在类的对象作为锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程名称为:"</span> + Thread.currentThread().getName() + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"进入printA"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">"线程名称为:"</span> + Thread.currentThread().getName() + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"离开printA"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程名称为:"</span> + Thread.currentThread().getName() + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"进入printB"</span>);</span><br><span class="line">        System.out.println(<span class="string">"线程名称为:"</span> + Thread.currentThread().getName() + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"离开printB"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程名称为:"</span> + Thread.currentThread().getName() + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"进入printC"</span>);</span><br><span class="line">        System.out.println(<span class="string">"线程名称为:"</span> + Thread.currentThread().getName() + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"离开printC"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      service.printA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadB</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        service.printB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadC</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadC</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.printC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Service service = <span class="keyword">new</span> Service();</span><br><span class="line">        ThreadA a = <span class="keyword">new</span> ThreadA(service);</span><br><span class="line">        a.setName(<span class="string">"A"</span>);</span><br><span class="line">        a.start();</span><br><span class="line"></span><br><span class="line">        ThreadB b = <span class="keyword">new</span> ThreadB(service);</span><br><span class="line">        b.setName(<span class="string">"B"</span>);</span><br><span class="line">        b.start();</span><br><span class="line"></span><br><span class="line">        ThreadC c = <span class="keyword">new</span> ThreadC(service);</span><br><span class="line">        c.setName(<span class="string">"C"</span>);</span><br><span class="line">        c.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>运行结果：<br>线程名称为:A在1561702771777进入printA<br>线程名称为:C在1561702771778进入printC<br>线程名称为:C在1561702771778离开printC<br>线程名称为:A在1561702774777离开printA<br>线程名称为:B在1561702774777进入printB<br>线程名称为:B在1561702774777离开printB</p><p>从中可以看出加上static和不加static是有区别的，主要是产生了不同的锁，一个是将类Service的对象作为锁，另一个是将Service类对应的Class类的对象作为锁，A、B线程和C线程是异步的关系，而A线程和B线程是同步的关系。</p><h1 id="synchronized锁重入"><a href="#synchronized锁重入" class="headerlink" title="synchronized锁重入"></a>synchronized锁重入</h1><p>该关键字拥有重入锁的功能，即在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时也可以得到该对象锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mysyn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syn1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"syn1"</span>);</span><br><span class="line">      syn2();  </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syn2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"syn2"</span>);</span><br><span class="line">      syn3();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syn3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"syn3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Mysyn syn = <span class="keyword">new</span> Mysyn();</span><br><span class="line">       syn.syn1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">       t.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>结果输出：<br><strong>syn1</strong><br><strong>syn2</strong><br><strong>syn3</strong></p><p>上述代码中的锁是对象锁，当这个对象锁还没有被释放时，还可以重新进入获取该对象锁，如果不是可重入锁的话，是不能调用sync2()方法的。</p><hr><h1 id="不同锁形式调用"><a href="#不同锁形式调用" class="headerlink" title="不同锁形式调用"></a>不同锁形式调用</h1><p>当在一个类中定义了不同形式的synchronized()方法时，混合调用可能会产生不同的效果。</p><ul><li>锁重入支持继承的环境，当父类中定义了一个synchronized()方法时，子类继承并重新定义了该方法，并在方法内部调用了父类的方法，在实际执行中会先调用子类的方法，然后调用父类的方法。</li><li>重写方法如果<strong>不使用</strong>synchronized关键字，会变成<strong>非同步</strong>方法，<strong>使用</strong>后会变成<strong>同步</strong>方法</li><li>如果只是在方法的部分区域定义synchronized代码块，在区域内部的代码会同步，在区域外部的代码会异步</li><li>当先后调用synchronized(this)方法和synchronized public void func1()方法时，都会将当前类的对象作为锁，都是一把锁，运行的结果是同步的效果。</li><li>使用同步代码块锁非this对象，即synchronized(非this)代码块中的程序与同步方法是<strong>异步</strong>的，因为有两把锁，不与其他锁this同步方法争抢this锁，可以大大提高运行效率。</li><li>多个锁就是异步执行</li><li>同步syn static方法可以对类的所有对象实例起作用</li><li>同步syn(class)代码块可以对类的所有对象实例起作用</li><li>在大多数情况下，同步synchronized代码块不使用String作为锁对象，这是String常量池所带来的问题</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在上文中，我写了ReentrantLock有关的代码分析，它是基于Lock基础类的。在Java中一般有两种实现锁的方式，一种是基于Lock的，一种是基于JVM的synchonized锁的，在本文中将要介绍后面一种方式。jDK官网中对它进行了这样的解释：它可以实现一个简单的策略来防止线程干扰和内存一致性错误，如果一个对象对多个线程是可见的，那么对该对象的所有读或者写都将通过同步的方式来继续来进行。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="https://github.com/spurstong/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://github.com/spurstong/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock 可重入锁 源代码解析</title>
    <link href="https://github.com/spurstong/2019/06/24/ReentrantLock%20%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%20%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/spurstong/2019/06/24/ReentrantLock 可重入锁 源代码解析/</id>
    <published>2019-06-24T13:08:23.000Z</published>
    <updated>2019-08-16T11:08:19.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ReentrantLock类"><a href="#ReentrantLock类" class="headerlink" title="ReentrantLock类"></a>ReentrantLock类</h1><ul><li>可重入性<br>即当该子程序正在运行时，可以再次进入并执行它。如果进入同一个线程，该线程的锁的计数器就是增加1，只有等到锁的计数器降为0时才会被释放。<a id="more"></a><h1 id="ReentrantLock类-1"><a href="#ReentrantLock类-1" class="headerlink" title="ReentrantLock类"></a>ReentrantLock类</h1></li><li>可重入性<br>即当该子程序正在运行时，可以再次进入并执行它。如果进入同一个线程，该线程的锁的计数器就是增加1，只有等到锁的计数器降为0时才会被释放。</li><li>独占锁<br>java在并发模式下提供两种加锁模型，共享锁和独占锁。在独占模式下，只有一个线程可以拥有该锁，其他线程只有在该线程释放这个锁后才能申请拥有该锁。而共享锁是允许多个锁同时拥有该锁，并发访问共享资源，<strong>ReentrantLock是独占锁</strong>。</li><li>悲观锁<br>悲观锁总是假设是最坏的情况，每次去拿数据的时候都会认为会被修改，所以每次在拿数据的时候都会上锁，别人想拿这个锁的时候就会发生阻塞现象。乐观锁总是假设最好的情况，每次去拿数据的时候都会认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法去实现。<strong>ReentrantLock是悲观锁</strong>。独占锁是一种悲观锁，它避免了读、读冲突，共享锁是一种乐观锁。</li><li>公平锁与非公平锁<br>是指线程在请求获取锁的过程中，是否允许插队。在公平锁中，线程会按照它们发出的请求来获得锁，而非公平锁则允许在线程发出请求后立即尝试获取锁，尝试失败才进行排队等待。<strong>ReentrantLock默认采用非公平模式</strong></li></ul><h1 id="锁的类Node"><a href="#锁的类Node" class="headerlink" title="锁的类Node"></a>锁的类Node</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">        <span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">        #因超时或中断，该线程被取消</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread has cancelled */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line">        #该线程的后继线程已阻塞，当该线程release或cancel要重启这个后继线程</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">        #表明该线程被处于条件队列，就是因为调用了Condition.await而被阻塞</span><br><span class="line">        <span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * waitStatus value to indicate the next acquireShared should</span></span><br><span class="line"><span class="comment">         * unconditionally propagate</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        #传播共享锁</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">        <span class="keyword">volatile</span> Node prev;</span><br><span class="line">        <span class="keyword">volatile</span> Node next;</span><br><span class="line">        <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">        Node nextWaiter;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><p>在上面代码中，有一个参数state,初始化为0，表示未锁定状态。A线程Lock时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其他线程才有机会获取该锁。再A线程释放该锁之前，A线程可以重复获取该锁,并执行state+1，即为可重入。但要注意的是，获取多少次就要释放多少次，这样才能保证state是能回到零态的。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/ReentrantLock%E6%BA%90%E7%A0%81/1.png" alt="同步队列.png"></p><h2 id="公平锁FairSync类"><a href="#公平锁FairSync类" class="headerlink" title="公平锁FairSync类"></a>公平锁FairSync类</h2><p>FairSync主要有两个方法 lock()和tryAcquire(),<br>lock方法中会调用AbstractQueuedSynchronizer类中的acquire()方法。<br>AbstractQueuedSynchronizer是一个抽象类，tryAcquire()的具体方法过程在FairSync类和NonfairSync类中实现。<br>与下文的非公平锁相比较，tryAcquire（）多了一个判断条件<strong>hasQueuedPredecessors()</strong><br>如果hasQueuedPredecessors返回true，表示有其他线程先于当前线程等待获取锁，此时为了实现公平，保证等待时间最长的线程先获取到锁，不能执行CAS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//尝试获取锁</span></span><br><span class="line">       <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           <span class="comment">//获取不到，则放到等待队列中去，返回是否中断</span></span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           <span class="comment">//返回中断，调用该方法</span></span><br><span class="line">           selfInterrupt();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">3000897897090466540L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Fair version of tryAcquire.  Don't grant access unless</span></span><br><span class="line"><span class="comment">         * recursive call or no waiters or is first.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//获取当前线程</span></span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="comment">//获取同步状态</span></span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="comment">//没有线程获取锁</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                    compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断当前线程是否是获取锁的线程</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">        <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">        <span class="comment">// thread is first in queue.</span></span><br><span class="line">        Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        Node s;</span><br><span class="line">        <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">            ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面用到了compareAndSetState(0, acquires)方法，是一种CAS(compare and swap),即比较和替换<br><strong>CAS(compare and Swap)</strong></p><table><tr><td bgcolor="#f6f6f6">该部分内容引用了简书大神占小狼的内容[https://www.jianshu.com/p/fb6e91b013cc](<https: www.jianshu.com p fb6e91b013cc>)</https:></td></tr></table>它有三个参数，一个为当前内存值V,旧的预期值A和即将更新的值B,当且仅当旧的预期值A和内存值V相等时，才能将内存值修改为B并返回true,其他情况不执行任何操作并返回false.Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>,</span><br><span class="line">         #变量stateOffset表示该变量值在内存中的偏移地址，以为Unsafe就是根据内存偏移地址获取数据的</span><br><span class="line">         stateOffset, expect, update);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>使用场景<br>使用于简单的对象的操作，比如布尔值，整型值<br>适合冲突较少的情况，比如太多线程在同时自旋，那么长时间自旋会导致CPU开销很大</li><li>CAS的ABA问题<br>ABA问题就是如下所示：</li></ul><ol><li>线程1获取该位置的数值为A,之后执行CAS操作，期望值为A,只有当前的值为A才能被修改</li><li>线程2将数据修改为B</li><li>线程3将数据改为A</li><li>线程1检测当前的值为A,与预期值相同，则执行操作。<br>在上述并发条件下，线程1最后执行了修改操作，但此时的A与初始的A不一样了，中间经历了其他修改，CAS就是防止在执行操作时预防有别的线程在操作。</li></ol><ul><li>CAS的ABA问题的解决办法<br>新增了AtomicStampedReference类来解决该问题，为值增加了修改版本号，每次修改时，都会修改其版本号。首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">//对象引用</span></span><br><span class="line">        <span class="keyword">final</span> T reference;</span><br><span class="line">        <span class="comment">//标志版本</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Pair</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.reference = reference;</span><br><span class="line">            <span class="keyword">this</span>.stamp = stamp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">of</span><span class="params">(T reference, <span class="keyword">int</span> stamp)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;T&gt;(reference, stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    # expectedReference:更新之前的期望值</span><br><span class="line">    # newReference 要更新的新值</span><br><span class="line">    # expectedStamp 期待更新的标志版本 newStamp: 将要更新的标志版本   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 V   newReference,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp;</span><br><span class="line">            expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="非公平锁NonfairSync类"><a href="#非公平锁NonfairSync类" class="headerlink" title="非公平锁NonfairSync类"></a>非公平锁NonfairSync类</h2><p>非安全锁在上锁时会先通过<strong>compareAndSetState(0, 1)</strong> 判断如果没有线程拥有该锁时就直接添加到该线程中<br>如果有线程拥有该锁的话，就调用acquire()方法，同上面的acquire()方法一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7316153563782823691L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class="line"><span class="comment">         * acquire on failure.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">                <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                setState(nextc);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h1 id="同步队列添加元素"><a href="#同步队列添加元素" class="headerlink" title="同步队列添加元素"></a>同步队列添加元素</h1><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/ReentrantLock%E6%BA%90%E7%A0%81/2.png" alt="同步队列添加元素.png"><br>先获取同步队列的尾结点，然后将插入的结点的前驱结点连接到原尾结点，之后通过CAS方式设置同步结点的尾结点的地址为插入的结点位置。当尾结点为空或者设置tail指向新插入的结点失败时执行enq方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//自旋操作</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="comment">//如果尾结点为空</span></span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="comment">//通过CAS添加到尾部</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="锁的释放"><a href="#锁的释放" class="headerlink" title="锁的释放"></a>锁的释放</h1><p>首先调用unlock方法，然后调用AbstractQueuedSynchronizer类中的<strong>release()方法</strong><br>调用tryRelese()方法释放当前线程并唤醒启动等待队列里的头结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       #尝试释放当前线程</span><br><span class="line">       <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">           #启动等待线程队列里的头结点，h为当前执行的线程，在unparkSuccessor方法中会唤醒当前线程的后继结点</span><br><span class="line">           Node h = head;</span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">               unparkSuccessor(h);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在tryRelease()方法中只有当线程的state为0时才会释放该线程，<strong>否则说明是重入锁，需要多次释放将state改为0才能该线程释放掉</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">           #线程计数器减1</span><br><span class="line">           <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">           #只有锁的拥有者是当前线程时才能继续执行，否则会抛出异常</span><br><span class="line">           <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">           <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">               free = <span class="keyword">true</span>;</span><br><span class="line">               setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           setState(c);</span><br><span class="line">           <span class="keyword">return</span> free;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Wakes up node's successor, if one exists.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> node the node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            #唤醒该进程</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ReentrantLock类&quot;&gt;&lt;a href=&quot;#ReentrantLock类&quot; class=&quot;headerlink&quot; title=&quot;ReentrantLock类&quot;&gt;&lt;/a&gt;ReentrantLock类&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;可重入性&lt;br&gt;即当该子程序正在运行时，可以再次进入并执行它。如果进入同一个线程，该线程的锁的计数器就是增加1，只有等到锁的计数器降为0时才会被释放。
    
    </summary>
    
      <category term="并发" scheme="https://github.com/spurstong/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://github.com/spurstong/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源代码解析</title>
    <link href="https://github.com/spurstong/2019/06/22/HashMap%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://github.com/spurstong/2019/06/22/HashMap源代码解析/</id>
    <published>2019-06-22T15:40:20.000Z</published>
    <updated>2019-08-16T11:02:45.542Z</updated>
    
    <content type="html"><![CDATA[<p>hashMap是一个常用的集合类，用来存放多组键值对，内部的数据结构在jdk1.6时是数组加链表，但到了jdk1.8时额外添加了红黑树，当某一链表长度超过某个值时会转化为红黑树。</p><a id="more"></a><h1 id="HashMap1-6与1-8的区别"><a href="#HashMap1-6与1-8的区别" class="headerlink" title="HashMap1.6与1.8的区别"></a>HashMap1.6与1.8的区别</h1><p>hashMap是一个常用的集合类，用来存放多组键值对，内部的数据结构在jdk1.6时是数组加链表，但到了jdk1.8时额外添加了红黑树，当某一链表长度超过某个值时会转化为红黑树。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/HashMap%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/1.png" alt="jdk1.6数据结构.png"></p><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/HashMap%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/2.png" alt="jdk1.8HashMap数据结构"></p><h2 id="HashMap-属性变量解释"><a href="#HashMap-属性变量解释" class="headerlink" title="HashMap 属性变量解释"></a>HashMap 属性变量解释</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#数组的初始化容量-数值必须时2的幂</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">#最大容量，可以使用一个带参数的构造函数来隐式的改变容量大小，但必须时2的幂且小于等于1&lt;&lt;30</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">#负载因子初始值</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">#使用树(而不是列表)来设置bin计数阈值。当向至少具有这么多节点的bin添加元素时，bin将转换为树。该值必须大于#2，并且应该至少为8，以便与删除树时关于转换回普通桶的假设相匹配收缩。</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">#当桶（bucket）上的结点数小于该值是应当树转链表</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">#桶中结构转化为红黑树时对应的table的最小值</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">#tables数组，在必要时会重新调整大小，但长度总是2的幂</span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">#保存缓存的entrySet()。注意，使用了AbstractMap字段用于keySet()和values()。</span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">#在该map中映射的key-value对数量</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">#这个HashMap在结构上被修改的次数结构修改是指改变HashMap中映射的数量或修改其内部结构的次数(例如，#rehash)。此字段用于使HashMap集合视图上的迭代器快速失效。(见ConcurrentModificationException)。</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">#要下一次调整大小的临界值（capacity * load factor）</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">#哈希表的加载因子</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><ul><li><p>上面提到了负载因子，这是一个很重要的变量，它表示一个散列表的使用程度，有这样一个公式：initailCapacity*loadFactor=HashMap的容量。所以负载因子越大则散列表的装填程度越高，也就是能容纳更多的元素，元素多了，链表大了，所以此时索引效率就会降低。反之，负载因子越小则链表中的数据量就越稀疏，此时会对空间造成烂费，但是此时索引效率高。</p><ul><li>上面也提到了transient变量类型，在 Java中，serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。当一个对象被序列化的时候，transient型变量的值不包括在序列化的表示中，然而非transient型的变量是被包括进去的，这样做可以节省磁盘空间，减少不必要的浪费。</li></ul></li></ul><hr><p>源码中定义了四个构造函数，可以自定义容量和负载因子，也支持将定义好的Map作为参数，进行转化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span></span><br></pre></td></tr></table></figure><p>HashMap中每个节点元素都是以node的类型，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        #连接的下一个节点</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        #计算hash值，会判断key是否为空，</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap添加数据-putval"><a href="#HashMap添加数据-putval" class="headerlink" title="HashMap添加数据 putval"></a>HashMap添加数据 putval</h2><p>在hashMap中添加新数据时会调用putVal（）方法，它会根据key计算出hash值，然后通过计算 tab[i = (n - 1) &amp; hash]<br>来得出该结点应该放在最外面table数组的位置数值，如果该位置为null,即还没有存放链表，那就创建一个node,存放在该位置，不是首结点的话，通过判断p.hash == hash &amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))来判断插入位置，如果到了链表尾部，就直接插入，并判断是否超出阈值，否则转化为红黑树，如果该位置已存在值，则对值进行覆盖。同时，对modCount加1，在最后会判断当前数量是否超出阈值，否则就进行扩容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    #如果表为空，则对表进行初始化</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">    #如果计算的位置为空，没有结点，就直接插入,否则就进入该位置的链表逐个查询    </span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        #通过hash值和key值进行判断，得出插入位置</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                #当插入的位置为该链表的尾结点时，则直接插入，当超出阈值时，则转化为红黑树</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        #当该位置存在旧值时，修改赋值，并返回旧址</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    #增加修改次数</span><br><span class="line">        ++modCount;</span><br><span class="line">    #当大小超过阈值时，进行扩展</span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/HashMap%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/3.png" alt="红黑树案例.png"></p><p>为了更好的理解红黑树在HashMap中的运用，我先简单的介绍红黑树的定义及特点。<br>引用百度百科的定义，红黑树是一种自平衡二叉查找树，与平衡二叉树相似，都是在进行插入或删除操作中通过特定的操作来保持二叉树的平衡，以尽可能的减少树的高度，提高查询速度。<br><strong>红黑树特性</strong></p><ul><li>结点是红色或黑色</li><li>根节点永远是黑色</li><li>叶子结点（NIL结点）都是黑色</li><li>红色结点的两个直接孩子结点都是黑色</li><li>任一结点到其每个叶子的所有路径都包含相同数目的黑色结点</li></ul><p><strong>红黑树结构</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        #父结点</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  // red-black tree links</span><br><span class="line">        #左结点</span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        #右结点</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        #上结点</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span><br><span class="line">        #标注该结点是否为红色</span><br><span class="line">        boolean red;</span><br><span class="line">        TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            super(hash, key, val, next);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>-将链表转化为红黑树时会调用treeifyBin方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">        #当长度小于阈值时会进行扩容处理</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            resize();</span><br><span class="line">        #确定要转化为红黑树的链表的位置    </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                #将Node类型转化为TreeNode类型</span><br><span class="line">                TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">                #记录头结点</span><br><span class="line">                <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                    hd = p;</span><br><span class="line">                #双向链表    </span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    p.prev = tl;</span><br><span class="line">                    tl.next = p;</span><br><span class="line">                &#125;</span><br><span class="line">                #记录上一个结点，以方便记录prev</span><br><span class="line">                tl = p;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">                #将树形链表转化为红黑树</span><br><span class="line">                hd.treeify(tab);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>从该结点转化为红黑树   treeify</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeify</span><span class="params">(Node&lt;K,V&gt;[] tab)</span> </span>&#123;</span><br><span class="line">                    TreeNode&lt;K,V&gt; root = <span class="keyword">null</span>;</span><br><span class="line">                    #从该结点进行遍历</span><br><span class="line">                    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = <span class="keyword">this</span>, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">                        #记录当前结点的下一个结点</span><br><span class="line">                        next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">                        x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            x.parent = <span class="keyword">null</span>;</span><br><span class="line">                            #当为根节点时，为黑色</span><br><span class="line">                            x.red = <span class="keyword">false</span>;</span><br><span class="line">                            root = x;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            K k = x.key;</span><br><span class="line">                            <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                                <span class="keyword">int</span> dir, ph;</span><br><span class="line">                                K pk = p.key;</span><br><span class="line">                                #当前的结点比红黑树一结点小时，向左转</span><br><span class="line">                                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                                    dir = -<span class="number">1</span>;</span><br><span class="line">                                #大于时，向右转</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                                    dir = <span class="number">1</span>;</span><br><span class="line">                                #当hash值相等时</span><br><span class="line">                                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                                #保留当前结点</span><br><span class="line">                                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                                #如果dir 小于等于0 ： 当前链表节点一定放置在当前树节点的左侧，但不一定是该树节点的左孩子，也可能是左孩子的右孩子 或者 更深层次的节点。</span><br><span class="line">                  如果dir 大于<span class="number">0</span> ： 当前链表节点一定放置在当前树节点的右侧，但不一定是该树节点的右孩子，也可能是右孩子的左孩子 或者 更深层次的节点。</span><br><span class="line">                  如果当前树节点不是叶子节点，那么最终会以当前树节点的左孩子或者右孩子 为 起始节点  再从上处开始 重新寻找自己（当前链表节点）的位置</span><br><span class="line">                  如果当前树节点就是叶子节点，那么根据dir的值，就可以把当前链表节点挂载到当前树节点的左或者右侧了。</span><br><span class="line">                  挂载之后，还需要重新把树进行平衡。平衡之后，就可以针对下一个链表节点进行处理了。</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    x.parent = xp;</span><br><span class="line">                                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                                        xp.left = x;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        xp.right = x;</span><br><span class="line">                                    root = balanceInsertion(root, x);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    #Ensures that the given root is the first node of its bin.</span><br><span class="line">                    moveRootToFront(tab, root);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p><strong>HashMap的缺点</strong><br>jdk1.8版本之前，在高并发下执行resize()可能会引起死循环，在resize()过程中，采用了头插法进行链表的重新构建，颠倒了原来的链表的相对依次顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        #创建新的数组</span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">        transfer(newTable);</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">        Entry[] src = table;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;src.length; j++) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                src[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    #采用头插法进行链表的重新构建连接</span><br><span class="line">                    Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                    e.next = newTable[i];</span><br><span class="line">                    newTable[i] = e;</span><br><span class="line">                    e = next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>假设初始化一个数组，长度为3，有3个数，为4，10， 7，根据mod操作，都在tab[1]上，发生冲突，构建链表。</p><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/HashMap%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/4.png" alt="HashMap初始化.png"></p><p>[^1]然后进行扩容resize()操作，tab数组大小扩展为原来的两倍，在单线程下操作会变成下面的结构，没有发生异常，因为采用头插法，所有链表中数据的相对顺序会发生颠倒，但在高并发情况下可能会发生异常。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/HashMap%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/5.png" alt="扩容后的HashMap.png"></p><p>现在假设有两个线程在执行resize()操作，线程1执行到<strong>Entry&lt;K,V&gt; next = e.next  e.next = newTable[i];</strong>位置时被挂起，此时，线程1记录的<strong>e</strong>为4，<strong>next</strong>为10，然后执行线程2的操作，顺利完成，结果和上图一致。此时，再继续执行线程1剩余的操作<br><strong>newTable[i] = e;  e = next ;</strong> 此时e变成了10，而线程2已修改10的next是4,就形成了死循环。</p><ul><li>jdk1.8 reszie()方法改进</li></ul><p>note: &amp;操作</p><ul><li>在下方 代码中有一步是<strong>e.hash &amp; (newCap - 1)</strong>， 该方法相当与取余操作，但有限制，只有当b为2的n次方时才有效， a % b = a &amp; (b -1) (b =[2^n])<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                # 修改新的临界值为原来的两倍，进行移位操作速度会更快些，算是个小技巧    </span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            </span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        #创建新的数组</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    #该位置下只有一个元素</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    #如果该节点是树结构    </span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        #定义了两个链表，low和high</span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            #判断该元素是放到原索引处还是新索引处</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                #放到原索引处建立新链表</span><br><span class="line">                                #jdk1.8之前是头插法，现在改为了尾插法</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            #放到新索引处建立建立新链表</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>但在jdk1.8中HashMap中会存在了数据丢失问题，在多线程情况下建议使用ConcurrentHashMap</p><p>##HashMap为什么选择桶中个数超过8个时才会转化为红黑树<br>在源码中有这么一段注释，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Because TreeNodes are about twice the size of regular nodes, we</span><br><span class="line">use them only when bins contain enough nodes to warrant use</span><br><span class="line">(see TREEIFY_THRESHOLD). And when they become too small (due to</span><br><span class="line">removal or resizing) they are converted back to plain bins.  In</span><br><span class="line">usages with well-distributed user hashCodes, tree bins are</span><br><span class="line">rarely used.  Ideally, under random hashCodes, the frequency of</span><br><span class="line">nodes in bins follows a Poisson distribution</span><br></pre></td></tr></table></figure><p>在理想状态下，通过hashmap算法所有的节点几乎都遵循泊松分布，一个bin中的链表长度超过8的概率为0.00000006，几率很小，而转化为红黑树也在很少情况下，在该长度下也能更好的发挥树的优势。</p><hr><p>才疏学浅，有不足地方希望能够及时提出，互相学习<br>该文章也发布在了我的简书上<a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" rel="noopener">https://www.jianshu.com/u/a8d49bf62c45</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hashMap是一个常用的集合类，用来存放多组键值对，内部的数据结构在jdk1.6时是数组加链表，但到了jdk1.8时额外添加了红黑树，当某一链表长度超过某个值时会转化为红黑树。&lt;/p&gt;
    
    </summary>
    
      <category term="java集合" scheme="https://github.com/spurstong/categories/java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="java集合" scheme="https://github.com/spurstong/tags/java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>java所有参数-对象类型及基本类型值--都是值传递</title>
    <link href="https://github.com/spurstong/2019/06/20/Java%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0-%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%E5%8F%8A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%80%BC--%E9%83%BD%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92/"/>
    <id>https://github.com/spurstong/2019/06/20/Java所有参数-对象引用及基本类型值--都是值传递/</id>
    <published>2019-06-20T08:16:00.000Z</published>
    <updated>2019-08-16T11:03:11.272Z</updated>
    
    <content type="html"><![CDATA[<p>值传递（pass by value）是指在调用函数时将实际参数复制一份到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。<br>引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数进行的修改，将影响到实际参数</p><a id="more"></a><blockquote><p>前言</p></blockquote><p>当前主要存在两种传递方式，<strong>值传递</strong>和<strong>引用传递</strong>,先简单介绍值传递和引用传递<br>值传递（pass by value）是指在调用函数时将实际参数复制一份到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。<br>引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数进行的修改，将影响到实际参数<br>或许存在这种误解，认为普通值类型就是值传递，引用类型就是引用传递<br>这种理解是错误的，《java编程思想》中提到过：”java程序设计语言总是采用值调用。也就是说，方法得到的是所有参数值的一个拷贝，特别是，方法不能修改传递给它的任何参数变量的内容。“</p><blockquote><p>正文</p></blockquote><p>在本节中我编写了几个程序来验证java的传递方式，实验中的参数类型也基本包括了经常出现的几种类型，有基本数据类型int,字符串str，int数组和自定义类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String str, <span class="keyword">int</span> [] data, <span class="keyword">int</span> count, Tag tag)</span> </span>&#123;</span><br><span class="line">        str = <span class="string">"new str"</span>;</span><br><span class="line">        data[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        count = <span class="number">10</span>;</span><br><span class="line">        tag.setAttr(<span class="number">88</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Tag</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> attr;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Tag</span><span class="params">(<span class="keyword">int</span> attr)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attr = attr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAttr</span><span class="params">(<span class="keyword">int</span> attr)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attr = attr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAttr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.attr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"str"</span>;</span><br><span class="line">        <span class="keyword">int</span>[] data = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">2</span>;</span><br><span class="line">        Tag tag = <span class="keyword">new</span> Tag(<span class="number">8</span>);</span><br><span class="line">        change(str, data, count, tag);</span><br><span class="line">        System.out.println(str); <span class="comment">//没有变成new str</span></span><br><span class="line">        System.out.println(data[<span class="number">0</span>] + <span class="string">" "</span> + data[<span class="number">1</span>] + <span class="string">" "</span> + data[<span class="number">2</span>]); <span class="comment">// 数组改变，&#123;1，1，2，3&#125;</span></span><br><span class="line">        System.out.println(count);<span class="comment">//没有改变</span></span><br><span class="line">        System.out.println(tag.getAttr()); <span class="comment">//值改变，变成88</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>解析</p></blockquote><p>java在方法传参时会将原参数的一个拷贝传递到方法内部，并不是原参数，比如，count传递到方法中时是count的一个副本，在方法中修改count为10，是将count的副本修改成10，而count并没有被改变，还是原值<br>字符串比较特殊，它的存储方式是这种方式<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/java%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%80%BC--%E9%83%BD%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92/3130295-4e5d916d93f322a2.png" alt="字符串变量str赋值Data1"><br>当变量Str又赋值为New Data时，里面存储的就是0X2这个地址了<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/java%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%80%BC--%E9%83%BD%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92/3130295-0c579ab2660623f1.png" alt="img"><br>当方法参数是字符串时，它会将字符串地址的拷贝传递到方法内部，<br>在方法内部，将字符串拷贝的地址重新指向了新的地址，修改的只是拷贝的存储的地址，但原字符串的地址并未改变，所以输出的值还是原来的值<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/java%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0-%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%80%BC--%E9%83%BD%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92/3130295-6de721382d768e7e.png" alt="image.png"><br>int[] data是一个对象，同字符串类似，它会复制一个地址传到方法内部，在方法中，它修改了存储地址中的某个位置的值，而原参数也是指向了该地址，所以输出的数组值变了</p><blockquote><p>总结</p></blockquote><p>总结起来，java中参数传递情况如下：<br>· 一个方法不能修改一个基本数据类型的参数<br>· 一个方法可以修改一个对象参数的状态<br>· 一个方法不能实现让对象参数引用一个新对象</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;值传递（pass by value）是指在调用函数时将实际参数复制一份到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。&lt;br&gt;引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数进行的修改，将影响到实际参数&lt;/p&gt;
    
    </summary>
    
      <category term="java基础" scheme="https://github.com/spurstong/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="java基础" scheme="https://github.com/spurstong/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Python函数参数作为引用时</title>
    <link href="https://github.com/spurstong/2018/05/19/Python%20%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%BC%95%E7%94%A8%E6%97%B6/"/>
    <id>https://github.com/spurstong/2018/05/19/Python 函数参数作为引用时/</id>
    <published>2018-05-19T02:45:30.000Z</published>
    <updated>2019-07-15T13:03:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python唯一支持的参数传递模式是 <strong>共享传参</strong>, 即函数的各个参数获得实参中的各个引用的副本，也就是说，函数内部的形参是实参的别名。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%BC%95%E7%94%A8%E6%97%B6/1.png" alt="函数可能修改接收的对象"><br>   从程序中可以看出对于不变类型的int或元组，变量没有改变，而作为可变类型的列表，变量发生了变化。<br>   而很多时候我们不不想修改外部的数据，只想对传进来的数据进行修改。那么使用可变类型进行传参时也可能对外部数据进行修改，达不到预期的结果。下面是一个很难发现的问题。<br>  <img src="https://raw.githubusercontent.com/spurstong/img_data/master/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%BC%95%E7%94%A8%E6%97%B6/2.png" alt="不要使用可变类型作为参数的默认值"><br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%BC%95%E7%94%A8%E6%97%B6/3.png" alt="运行结果"><br>   从上面的程序和运行结果可知，bask1的运行结果正常，bask2没有传递参数，就赋值为默认的空列表，结果正常，而bask3一开始也是空的，应该是输出空列表，但结果不是，并且改变bask3的内容时，bask2的内容也发生了变化，问题在于bask2.teams和bask3.teams都指向了同一列表。出现这种情况的原因是因为self.teams变成了teams参数默认值的别名，默认值在定义函数时计算，因此默认值也变成了函数对象的属性。<br>可变默认值导致的这个问题说明了为什么通常使用None作为接收可变值的参数的默认值,解决方案可以是这样<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%BC%95%E7%94%A8%E6%97%B6/4.png" alt="解决方案"><br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/Python%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%BC%95%E7%94%A8%E6%97%B6/5.png" alt="运行结果"><br>  从中可以看到bask2与bask3的结果不同，在引用外部数据时可加上list()，产生副本，对实例变量teams修改时就不会对basketball_team产生影响，如果不加list()函数，那么basketball_team内容也随之发生变化</p><p>提示：内容参考&lt;&lt;流畅的python&gt;&gt;这本书，写的很好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python唯一支持的参数传递模式是 &lt;strong&gt;共享传参&lt;/strong&gt;, 即函数的各个参数获得实参中的各个引用的副本，也就是说，函数内部的形参是实参的别名。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/spurst
      
    
    </summary>
    
      <category term="python" scheme="https://github.com/spurstong/categories/python/"/>
    
    
      <category term="python" scheme="https://github.com/spurstong/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot下利用wangEditor3将图片上传到七牛云</title>
    <link href="https://github.com/spurstong/2018/04/23/SpringBoot%E4%B8%8B%E5%88%A9%E7%94%A8wangEditor3%E5%B0%86%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0%E4%B8%83%E7%89%9B%E4%BA%91/"/>
    <id>https://github.com/spurstong/2018/04/23/SpringBoot下利用wangEditor3将图片上传到七牛云/</id>
    <published>2018-04-23T09:59:10.000Z</published>
    <updated>2019-06-27T15:12:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>wangEditor3一般将图片上传到服务器很便捷，网上也有很多方法，但官方文档中给出的上传到七牛云的方法没领悟到什么意思，尝试了几次，没有成功，我就采取了一种折中的方法，即利用图片上传服务器的方法上传到七牛云。</p><blockquote><p>首先在网页中配置wangEditor图片上传</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> E = window.wangEditor;</span><br><span class="line">    <span class="keyword">var</span> editor = <span class="keyword">new</span> E(<span class="string">'#div1'</span>, <span class="string">'#div2'</span>);  <span class="comment">// 两个参数也可以传入 elem 对象，class 选择器</span></span><br><span class="line">    editor.customConfig.debug = <span class="keyword">true</span>;</span><br><span class="line">    editor.customConfig.uploadImgServer = <span class="string">'/post/upload'</span>;</span><br><span class="line">    editor.customConfig.uploadFileName = <span class="string">'multiple'</span>;  &lt;-   与后台获取文件名相同</span><br><span class="line">    editor.create();</span><br></pre></td></tr></table></figure><blockquote><p>创建结果返回类，wangEditor要求返回json信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer errno;</span><br><span class="line">    <span class="keyword">private</span> String[] data;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getErrno</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrno</span><span class="params">(Integer errno)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errno = errno;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] getData() &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(String[] data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//wangEditor图片上传返回数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultUtil</span> </span>&#123;</span><br><span class="line"> <span class="comment">//上传成功</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">success</span><span class="params">(String[] object)</span> </span>&#123;</span><br><span class="line">        Result result = <span class="keyword">new</span> Result();</span><br><span class="line">        result.setErrno(<span class="number">0</span>);</span><br><span class="line">        result.setData(object);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//上传失败</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">success</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>七牛云上传工具类 </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Qiniu</span> </span>&#123;</span><br><span class="line">    Logger logger = LogManager.getLogger(LogManager.ROOT_LOGGER_NAME);</span><br><span class="line">  <span class="comment">//从springboot的application.properties文件获取你注册的七牛云有关信息  </span></span><br><span class="line">  <span class="meta">@Value</span>(<span class="string">"$&#123;qiniu.accessKey&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;qiniu.secretKey&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;qiniu.bucket&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String bucket;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;qiniu.path&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadToken</span><span class="params">(FileInputStream file, String key)</span> </span>&#123;</span><br><span class="line">        Configuration cfg = <span class="keyword">new</span> Configuration(Zone.zone1());</span><br><span class="line">        UploadManager uploadManager = <span class="keyword">new</span> UploadManager(cfg);</span><br><span class="line">        logger.info(<span class="string">"path="</span> + path);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Auth auth = Auth.create(accessKey, secretKey);</span><br><span class="line">            String upToken = auth.uploadToken(bucket);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Response response = uploadManager.put(file, key, upToken, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">              <span class="comment">//  DefaultPutRet putRet = JSON.parseObject(response.bodyString(), DefaultPutRet.class);</span></span><br><span class="line">                DefaultPutRet putRet = <span class="keyword">new</span> Gson().fromJson(response.bodyString(), DefaultPutRet.class);</span><br><span class="line">                logger.info(<span class="string">"key:"</span> + putRet.key);</span><br><span class="line">                String encodedFileName = URLEncoder.encode(putRet.key, <span class="string">"utf-8"</span>);</span><br><span class="line">                <span class="comment">//获取下载地址,前天可以通过img访问</span></span><br><span class="line">                String finalUrl = String.format(<span class="string">"%s/%s"</span>, path, encodedFileName);</span><br><span class="line">                logger.info(<span class="string">"访问地址:"</span> + finalUrl);</span><br><span class="line">                <span class="keyword">return</span> finalUrl;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (QiniuException ex) &#123;</span><br><span class="line">                Response r = ex.response;</span><br><span class="line">                System.err.println(r.toString());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.err.println(r.bodyString());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (QiniuException ex2) &#123;</span><br><span class="line">                    <span class="comment">//ignore</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在springmvc进行文件处理</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/post"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PostController</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Resource</span></span><br><span class="line">     <span class="keyword">private</span> Qiniu qiniu;</span><br><span class="line">     <span class="comment">//帖子上传图片到服务器 MultipartFile   multiple,与网页设置的名字相同</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/upload"</span>, method = RequestMethod.POST)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">Result <span class="title">uploadImageHtml</span><span class="params">(MultipartFile multiple, HttpSession session, HttpServletRequest request)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (multiple != <span class="keyword">null</span>) &#123;</span><br><span class="line">            FileInputStream inputStream = (FileInputStream) multiple.getInputStream();</span><br><span class="line">            String fileName = multiple.getOriginalFilename();</span><br><span class="line">           <span class="comment">//下一句主要是创建文件名，我程序中还用到了springsecurity,你可以根据需要命名</span></span><br><span class="line">            User user = (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();</span><br><span class="line">            String fileNameExtension = fileName.substring(fileName.lastIndexOf(<span class="string">"."</span>), fileName.length());</span><br><span class="line">            String realName = String.valueOf(System.currentTimeMillis()) + user.getUsername()  + fileNameExtension;</span><br><span class="line">            String path = qiniu.uploadToken(inputStream, realName);</span><br><span class="line">            String [] str = &#123;path&#125;;</span><br><span class="line">            <span class="keyword">return</span> ResultUtil.success(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ResultUtil.success();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;wangEditor3一般将图片上传到服务器很便捷，网上也有很多方法，但官方文档中给出的上传到七牛云的方法没领悟到什么意思，尝试了几次，没有成功，我就采取了一种折中的方法，即利用图片上传服务器的方法上传到七牛云。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先在网页中配置wa
      
    
    </summary>
    
      <category term="spring" scheme="https://github.com/spurstong/categories/spring/"/>
    
    
      <category term="spring" scheme="https://github.com/spurstong/tags/spring/"/>
    
  </entry>
  
</feed>
