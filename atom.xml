<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>房东的小黑</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/spurstong/"/>
  <updated>2020-01-27T11:20:59.179Z</updated>
  <id>https://github.com/spurstong/</id>
  
  <author>
    <name>Mara Tong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://github.com/spurstong/2020/01/27/%E8%BD%BB%E9%87%8F%E7%BA%A7RPC%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%BA%8C%E7%89%88/"/>
    <id>https://github.com/spurstong/2020/01/27/轻量级RPC设计与实现第二版/</id>
    <published>2020-01-27T07:52:30.625Z</published>
    <updated>2020-01-27T11:20:59.179Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title: 轻量级RPC设计与实现第二版</span><br></pre></td></tr></table></figure><p>在上一个版本中利用netty实现了简单的一对一的RPC，需要手动设置服务地址，限制性较大。<br>在本文中，利用zookeeper作为服务注册中心，在服务端启动时将本地的服务信息注册到zookeeper中，当客户端发起远程服务调用时，先从zookeeper中获取该服务的地址，然后根据获得的这个地址来利用netty进行网络传送。<br>在服务端和注册中心之间需要建立监听，当服务信息发生变化或网络连接等问题时需要对注册中心的服务信息进行修改。在本文中创建了服务注册监控中心，利用<strong>心跳机制</strong>来判断与服务端是否有较稳定的连接，当出现网络不稳定时，则从注册中心中删除属于该服务端的服务信息。在本项目中设定在5分钟内3次以上没有发送心跳包为不稳定状态。</p><h1 id="zookeeper注册中心"><a href="#zookeeper注册中心" class="headerlink" title="zookeeper注册中心"></a>zookeeper注册中心</h1><p>zookeeper是hadoop中的一个重要组件，其主要是作为<strong>分布式协调服务</strong><br>zookeeper采用节点树的数据模型，类似linux文件系统。<br>每个节点称做一个ZNode,每个ZNode都可以通过路径唯一标识，同时每个节点还可以存储少量数据。<br>本项目借鉴dubbo的注册中心模型来设计本文的注册中心。<br>总体上设计了四级节点，在一个节点是一个持久节点<code>/register</code>，表示是记录注册服务的区域。二级节点是服务接口名，三级节点是远程服务ip地址，该节点是临时节点，节点存储的数据是具体的实现类名。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/%E8%BD%BB%E9%87%8F%E7%BA%A7RPC%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%BA%8C%E7%89%88/1.png" alt="整体流程"><br>在客户端会根据服务接口名进行查找，得到远程服务ip地址，并根据节点中存储的具体实现类名进行反射。</p><p>注册中心与服务端进行连接时需要判断是否维持了稳定的连接，如果服务端出现宕机等情况时需要从注册中心中删除这些服务。<br>以前的一些处理机制，有<strong>session</strong>机制和<strong>wacher</strong>机制。<br><strong>session机制</strong><br>每个zookeeper注册中心与服务端进行连接时会创建一个session,在设置的sessionTimeout内，服务端会与注册中心进行心跳包的定时发送，从而感知每个客户端是否宕机，如果创建某个临时Znode节点对应的session销毁时，相应的临时节点也会被注册中心删除。<br><strong>watcher机制</strong><br>针对每个节点的操作，都有要给监督者进行watcher,当监控的某个节点发生了变化，则会触发watcher事件。注册中心的watcher是一次性的，触发后会被销毁。父节点，子节点增删改都能够触发watcher。触发销毁后，下次需要监听时还需要再注册一次。<br><strong>本文心跳机制</strong><br>服务端定时向注册中心发送本机地址，看作心跳数据包，而注册中心监控则维持一个channelId和具体地址的map,并且通过IdleHandler监听空闲事件，到达一定的空闲次数则认为不活跃，当不活跃时，zookeeper删除对应的url节点。该版本实现了上面的内容，后续的步骤在以后的版本实现。<br>如果10s内没有触发读，就会执行<code>userEventTriggered</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">           IdleStateEvent state = (IdleStateEvent)evt;</span><br><span class="line">           <span class="keyword">if</span> (state.state().equals(IdleState.READER_IDLE)) &#123;</span><br><span class="line">               log.info(<span class="string">"读空闲"</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.state().equals(IdleState.WRITER_IDLE)) &#123;</span><br><span class="line">               log.info(<span class="string">"写空闲"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//在一定时间内读写空闲才会关闭链接</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (state.state().equals(IdleState.ALL_IDLE)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (++inActiveCount == <span class="number">1</span>) &#123;</span><br><span class="line">                   start = System.currentTimeMillis();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">int</span> minute = (<span class="keyword">int</span>)((System.currentTimeMillis() - start) / (<span class="number">60</span> * <span class="number">1000</span>)) + <span class="number">1</span>;</span><br><span class="line">               log.info(<span class="string">"第&#123;&#125;次读写都空闲，计时分钟数&#123;&#125;"</span>, inActiveCount, minute);</span><br><span class="line">               <span class="keyword">if</span> (inActiveCount &gt; <span class="number">2</span> &amp;&amp; minute &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                   log.info(<span class="string">"移除不活跃ip"</span>);</span><br><span class="line">                   removeAndClose(ctx);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (minute &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">                       log.info(<span class="string">"新周期开始"</span>);</span><br><span class="line">                       start = <span class="number">0</span>;</span><br><span class="line">                       inActiveCount = <span class="number">0</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>具体实现代码：<a href="https://github.com/spurstong/lightWeightRpc/tree/lightweightrpcv2">RPC第二版</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>轻量级RPC设计与实现第一版</title>
    <link href="https://github.com/spurstong/2020/01/24/%E8%BD%BB%E9%87%8F%E7%BA%A7RPC%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%B8%80%E7%89%88/"/>
    <id>https://github.com/spurstong/2020/01/24/轻量级RPC设计与实现第一版/</id>
    <published>2020-01-24T13:17:42.717Z</published>
    <updated>2020-01-27T07:37:57.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h1><p>RPC (Remote Procedure Call Protocol), 远程过程调用，通俗的解释就是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样，不需要了解底层网络技术的协议。</p><p><strong>简单的整体工作流程</strong><br>请求端发送一个调用的数据包，该包中包含有调用标识，参数等协议要求的参数。当响应端接收到这个数据包，对应的程序被调起，然后返回结果数据包，返回的数据包含了和请求的数据包中同样的请求标识，结果等。</p><h1 id="性能影响因素"><a href="#性能影响因素" class="headerlink" title="性能影响因素"></a>性能影响因素</h1><ol><li><strong>利用的网络协议</strong>。可以使用应用层协议，例如HTTP或者HTTP/2协议；也可以利用传输层协议，例如TCP协议，但是主流的RPC还没有采用UDP传输协议。</li><li><strong>消息封装格式</strong>。选择或设计一种协议来封装信息进行组装发送。比如，dubbo中消息体数据包含dubbo版本号、接口名称、接口版本、方法名称、参数类型列表、参数、附加信息等。</li><li><strong>序列化</strong>。信息在网络传输中要以二进制格式进行传输。序列化和反序列化，是对象到而二进制数据的转换。常见的序列化方法有JSON、Hessian、Protostuff等。</li><li><strong>网络IO模型</strong>。可以采用非阻塞式同步IO,也可以在服务器上实现对多路IO模型的支持。</li><li><strong>线程管理方式</strong>。在高并发请求下，可以使用单个线程运行服务的具体实现，但是会出现请求阻塞等待现象。也可以为每一个RPC具体服务的实现开启一个独立的线程运行，最大线程数有限制，可以使用线程池来管理多个线程的分配和调度。</li></ol><h1 id="第一版RPC"><a href="#第一版RPC" class="headerlink" title="第一版RPC"></a>第一版RPC</h1><p>第一个版本简单实现了RPC的最基本功能，即<strong>服务信息的发送与接收</strong>、<strong>序列化方式</strong>和<strong>动态代理</strong>等。<br>项目利用Springboot来实现依赖注入与参数配置，使用netty实现NIO方式的数据传输，使用Hessian来实现对象序列化。<br><strong>动态代理</strong><br>这里要提到代理模式，它的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系。<br>根据创建代理类的时间点，又可以分为静态代理和动态代理。<br>在以往的静态代理中需要手动为每一个目标编写对应的代理类。如果系统已经有了成百上千个类，工作量太大了。<br>静态代理由程序员创建或特定工具自动生成源代码，也就是在编译时就已经将接口与被代理类，代理类等确定下来。在程序运行之前，代理类的.class文件就已经生成。<br>代理类在程序运行时创建的代理方式被称为代理模式。在静态代理中，代理类是自己定义好的，在运行之前就已经编译完成了。而在动态代理中，可以很方便地对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。可以通过<code>InvocationHandler</code>接口来实现。</p><p><strong>客户端的动态代理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; interfaceClass)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;interfaceClass&#125;, <span class="keyword">new</span> LwRpcClientDynamicProxy&lt;T&gt;(interfaceClass));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LwRpcClientDynamicProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; clazz;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LwRpcClientDynamicProxy</span><span class="params">(Class&lt;T&gt; clazz)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        LwRequest lwRequest = <span class="keyword">new</span> LwRequest();</span><br><span class="line">        String requestId = UUID.randomUUID().toString();</span><br><span class="line">        String className = method.getDeclaringClass().getName();</span><br><span class="line">        String methodName = method.getName();</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">        lwRequest.setRequestId(requestId);</span><br><span class="line">        lwRequest.setClassName(className);</span><br><span class="line">        lwRequest.setMethodName(methodName);</span><br><span class="line">        lwRequest.setParameterTypes(parameterTypes);</span><br><span class="line">        lwRequest.setParameters(args);</span><br><span class="line">        NettyClient nettyClient = <span class="keyword">new</span> NettyClient(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        log.info(<span class="string">"开始连接服务器端:&#123;&#125;"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">        LwResponse send = nettyClient.send(lwRequest);</span><br><span class="line">        log.info(<span class="string">"请求后返回的结果:&#123;&#125;"</span>, send.getResult());</span><br><span class="line">        <span class="keyword">return</span> send.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务端会利用在客户端获取到的类名。参数等信息利用反射机制进行调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt;[] parameterTypes = request.getParameterTypes();</span><br><span class="line">        Object[] paramethers = request.getParameters();</span><br><span class="line">        <span class="comment">// 使用CGLIB 反射</span></span><br><span class="line">        FastClass fastClass = FastClass.create(serviceClass);</span><br><span class="line">        FastMethod fastMethod = fastClass.getMethod(methodName, parameterTypes);</span><br><span class="line">        <span class="keyword">return</span> fastMethod.invoke(serviceBean, paramethers);</span><br></pre></td></tr></table></figure><p><strong>Netty客户端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> Integer port;</span><br><span class="line">    <span class="keyword">private</span> LwResponse response;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup group;</span><br><span class="line">    <span class="keyword">private</span> ChannelFuture future = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> NettyClientHandler nettyClientHandler;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(String host, Integer port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LwResponse <span class="title">send</span><span class="params">(LwRequest request)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        nettyClientHandler = <span class="keyword">new</span> NettyClientHandler(request);</span><br><span class="line">        group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">5000</span>)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">65535</span>, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> LwRpcEncoder(LwRequest.class, <span class="keyword">new</span> HessianSerializer()));</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> LwRpcDecoder(LwResponse.class, <span class="keyword">new</span> HessianSerializer()));</span><br><span class="line">                        pipeline.addLast(nettyClientHandler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        System.out.println(<span class="string">"host:"</span> + host);</span><br><span class="line">        future = bootstrap.connect(host, port).sync();</span><br><span class="line">        nettyClientHandler.getCountDownLatch().await();</span><br><span class="line">        <span class="keyword">this</span>.response = nettyClientHandler.getLwResponse();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.response;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        group.shutdownGracefully();</span><br><span class="line">        future.channel().closeFuture().syncUninterruptibly();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">private</span> LwResponse response = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> LwRequest request;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClientHandler</span><span class="params">(LwRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.request = request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CountDownLatch <span class="title">getCountDownLatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> countDownLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LwResponse <span class="title">getLwResponse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.response;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"客户端向客户端发送消息"</span>);</span><br><span class="line">        ctx.writeAndFlush(request);</span><br><span class="line">        log.info(<span class="string">"客户端请求成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LwResponse lwResponse = (LwResponse) msg;</span><br><span class="line">        log.info(<span class="string">"收到服务端的信息:&#123;&#125;"</span>, lwResponse.getResult());</span><br><span class="line">        <span class="keyword">this</span>.response = lwResponse;</span><br><span class="line">        <span class="keyword">this</span>.countDownLatch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Throwable cause)</span> </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户端发送服务信息时，用LwQuest类进行封装，返回的结果用LwResponse进行封装，当客户端读取到服务器端返回的响应时，在<code>NettyClientHandler</code>中进行处理，并利用<code>CountDownLatch</code>进行线程的阻塞和运行。<br><strong>Netty服务端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup boss = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup worker = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ServerHandler serverHandler;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;server.address&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(<span class="string">"成功"</span>);</span><br><span class="line">        boss = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        worker = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(boss, worker)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">1024</span>)</span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">65535</span>, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> LwRpcEncoder(LwResponse.class, <span class="keyword">new</span> HessianSerializer()));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> LwRpcDecoder(LwRequest.class, <span class="keyword">new</span> HessianSerializer()));</span><br><span class="line">                            pipeline.addLast(serverHandler);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            String[] strs = address.split(<span class="string">":"</span>);</span><br><span class="line">            String addr = strs[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> port = Integer.valueOf(strs[<span class="number">1</span>]);</span><br><span class="line">            ChannelFuture future = serverBootstrap.bind(addr, port).sync();</span><br><span class="line">            future.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destory</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        boss.shutdownGracefully().sync();</span><br><span class="line">        worker.shutdownGracefully().sync();</span><br><span class="line">        log.info(<span class="string">"关闭netty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">LwRequest</span>&gt; <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, LwRequest msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LwResponse lwResponse = <span class="keyword">new</span> LwResponse();</span><br><span class="line">        lwResponse.setRequestId(msg.getRequestId());</span><br><span class="line">        log.info(<span class="string">"从客户端接收到请求信息:&#123;&#125;"</span>, msg);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object result = handler(msg);</span><br><span class="line">            lwResponse.setResult(result);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            lwResponse.setCause(throwable);</span><br><span class="line">            throwable.printStackTrace();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        channelHandlerContext.writeAndFlush(lwResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">handler</span><span class="params">(LwRequest request)</span> <span class="keyword">throws</span> ClassNotFoundException, InvocationTargetException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(request.getClassName());</span><br><span class="line">        Object serviceBean = applicationContext.getBean(clazz);</span><br><span class="line">        Class&lt;?&gt; serviceClass = serviceBean.getClass();</span><br><span class="line">        String methodName = request.getMethodName();</span><br><span class="line">        log.info(<span class="string">"获取到的服务类:&#123;&#125;"</span>, serviceBean);</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = request.getParameterTypes();</span><br><span class="line">        Object[] paramethers = request.getParameters();</span><br><span class="line">        <span class="comment">// 使用CGLIB 反射</span></span><br><span class="line">        FastClass fastClass = FastClass.create(serviceClass);</span><br><span class="line">        FastMethod fastMethod = fastClass.getMethod(methodName, parameterTypes);</span><br><span class="line">        <span class="keyword">return</span> fastMethod.invoke(serviceBean, paramethers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Netty服务端中，会利用``serverHandler`来处理从客户端中接收的信息，并利用反射的思想调用本地的方法，并将处理的结构封装在LwResponse中。</p><p><code>LwRequest</code>和<code>LwRespnse</code>要想在网络中进行传输，需要转化为二进制转换。具体方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HessianSerializer</span> <span class="keyword">implements</span> <span class="title">Serializer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] serialize(Object object) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ByteArrayOutputStream byteArrayOutputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        Hessian2Output output = <span class="keyword">new</span> Hessian2Output(byteArrayOutputStream);</span><br><span class="line">        output.writeObject(object);</span><br><span class="line">        output.flush();</span><br><span class="line">        <span class="keyword">return</span> byteArrayOutputStream.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Hessian2Input input = <span class="keyword">new</span> Hessian2Input(<span class="keyword">new</span> ByteArrayInputStream(bytes));</span><br><span class="line">        <span class="keyword">return</span> (T) input.readObject(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LwRpcDecoder</span> <span class="keyword">extends</span> <span class="title">ByteToMessageDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="keyword">private</span> Serializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LwRpcDecoder</span><span class="params">(Class&lt;?&gt; clazz, Serializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf, List&lt;Object&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (byteBuf.readableBytes() &lt; <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        byteBuf.markReaderIndex();</span><br><span class="line">        <span class="keyword">int</span> dataLength = byteBuf.readInt();</span><br><span class="line">        <span class="keyword">if</span> (dataLength &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            channelHandlerContext.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (byteBuf.readableBytes() &lt; dataLength) &#123;</span><br><span class="line">            byteBuf.resetReaderIndex();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[dataLength];</span><br><span class="line">        byteBuf.readBytes(data);</span><br><span class="line"></span><br><span class="line">        Object obj = serializer.deserialize(clazz, data);</span><br><span class="line">        list.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LwRpcEncoder</span> <span class="keyword">extends</span> <span class="title">MessageToByteEncoder</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; clazz;</span><br><span class="line">    <span class="keyword">private</span> Serializer serializer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LwRpcEncoder</span><span class="params">(Class&lt;?&gt; clazz, Serializer serializer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(ChannelHandlerContext ctx, Object in, ByteBuf out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (clazz.isInstance(in)) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = serializer.serialize(in);</span><br><span class="line">            out.writeInt(data.length);</span><br><span class="line">            out.writeBytes(data);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是RPC&quot;&gt;&lt;a href=&quot;#什么是RPC&quot; class=&quot;headerlink&quot; title=&quot;什么是RPC&quot;&gt;&lt;/a&gt;什么是RPC&lt;/h1&gt;&lt;p&gt;RPC (Remote Procedure Call Protocol), 远程过程调用，通俗的解释就是：客
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>轻量级分布式锁的设计原理分析与实现</title>
    <link href="https://github.com/spurstong/2020/01/17/%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E5%8F%8A%E5%AE%9E%E7%8E%B0/"/>
    <id>https://github.com/spurstong/2020/01/17/轻量级分布式锁的设计原理分析及实现/</id>
    <published>2020-01-17T10:02:06.498Z</published>
    <updated>2020-01-23T09:51:36.076Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要设计分布式锁"><a href="#为什么要设计分布式锁" class="headerlink" title="为什么要设计分布式锁"></a>为什么要设计分布式锁</h1><p>  在简单的单机系统中，当存在多个线程同时要修改某个共享变量时，为了数据的操作安全，往往需要通过加锁的方法，在同一时刻同一代码块只能有一个进程执行操作，存在很多加锁的方式，比如在java中有synchronize或Lock子类等。<br>  但是在分布式中，会存在多个主机，即会存在多个jvm, 在jvm之间数据是不能共享的，上面的方法只能在一个jvm中执行有效，在多个jvm中同一变量可能会有不同的值。所以我们要设计一种跨jvm的共享互斥机制来控制共享变量资源的访问，这也是提出分布式锁的初衷。</p><h1 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h1><p>为了将分布式锁实现较好的性能，我们需要解决下面几个重要的问题：</p><ul><li>一个方法或代码片段在同一时刻只能被一个进程所执行。</li><li>高可用的获取锁与释放锁功能。</li><li>避免死锁</li><li>锁只能被持有该锁的客户端删除或者释放。</li><li>容错，在服务器宕机时，锁依然能得到释放或者其他服务器可以进行加锁。</li></ul><p>下面分别利用redis和zookeeper来实现加锁和解锁机制。</p><h1 id="基于Redis的加锁第一版"><a href="#基于Redis的加锁第一版" class="headerlink" title="基于Redis的加锁第一版"></a>基于Redis的加锁第一版</h1><p>本版本通过变量sign设置锁的唯一标识，确保只有拥有该锁的客户端才能删除它，其他客户端不能删除。<br>利用阻塞锁的思想， 通过<code>while(System.currentTimeMillis() &lt; endTime)</code>和<code>Thread.sleep()</code>相结合，在设置的规定时间内进行多次尝试。<br>但是<code>setnx</code>操作和<code>expire</code>分割开了，不具有<strong>原子性</strong>，可能会出现问题。<br>比如说，在执行到<code>jedis.expire</code>时，可能系统发生了崩溃，导致锁没有设置过期时间，导致发生死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addLockVersion1</span><span class="params">(String key, <span class="keyword">int</span> blockTime, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (blockTime &lt;=<span class="number">0</span> || expireTime &lt;= <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           jedis = jedisPool.getResource();</span><br><span class="line">           String sign = UUID.randomUUID().toString();</span><br><span class="line">           String token = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">//设置阻塞尝试时间</span></span><br><span class="line">           <span class="keyword">long</span> endTime = System.currentTimeMillis() + blockTime;</span><br><span class="line">           <span class="keyword">while</span> (System.currentTimeMillis() &lt; endTime) &#123;</span><br><span class="line">               <span class="keyword">if</span> (jedis.setnx(key, sign) == <span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="comment">// 添加成功，设置锁的过期时间，防止死锁</span></span><br><span class="line">                   jedis.expire(key, expireTime);</span><br><span class="line">                   <span class="comment">// 在释放锁时用于验证</span></span><br><span class="line">                   token = sign;</span><br><span class="line">                   <span class="keyword">return</span> token;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//加锁失败，休眠一段时间，再进行尝试。</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(DEFAULT_SLEEP_TIME);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   Thread.currentThread().interrupt();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">               jedis.close();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="基于Redis的加锁第二版"><a href="#基于Redis的加锁第二版" class="headerlink" title="基于Redis的加锁第二版"></a>基于Redis的加锁第二版</h1><p>通过设置key对应的value值为锁的过期时间，当遇到系统崩溃，致使利用<code>expire</code>设置锁过期时间失败时，通过获取value值，来判断当前锁是否过期，如果该锁已经过期了，则进行重新获取。</p><p>但是它也存在一些问题。当锁过期时，如果多个进程同时执行<code>jedis.getSet</code>方法，虽然只有一个进程可以获得该锁，但是这个进程的锁的过期时间可能被其他进程的锁所覆盖。<br>该锁没有设置唯一标识，也会被其他客户端锁释放，不满足只能被锁的拥有者锁释放的条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addLockVersion2</span><span class="params">(String key, <span class="keyword">int</span> blockTime, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (blockTime &lt;=<span class="number">0</span> || expireTime &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            <span class="keyword">long</span> endTime = System.currentTimeMillis() + blockTime;</span><br><span class="line">            <span class="keyword">while</span> (System.currentTimeMillis() &lt; endTime) &#123;</span><br><span class="line">                <span class="keyword">long</span> redisExpierTime = System.currentTimeMillis() + expireTime;</span><br><span class="line">                <span class="keyword">if</span> (jedis.setnx(key, redisExpierTime + <span class="string">""</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    jedis.expire(key, expireTime);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String oldRedisExpierTime = jedis.get(key);</span><br><span class="line">                    <span class="comment">// 当锁设置成功，但是没有通过expire成功设置过期时间，但是根据存的值判断出它实际上已经过期了</span></span><br><span class="line">                    <span class="keyword">if</span> (oldRedisExpierTime != <span class="keyword">null</span> &amp;&amp; Long.parseLong(oldRedisExpierTime) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">                        String lastRedisExpierTime = jedis.getSet(key, System.currentTimeMillis() + blockTime + <span class="string">""</span>);</span><br><span class="line">                        <span class="comment">//获取到该锁，没有被其他线程所修改</span></span><br><span class="line">                        <span class="keyword">if</span> (lastRedisExpierTime.equals(oldRedisExpierTime)) &#123;</span><br><span class="line">                            jedis.expire(key, expireTime);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//加锁失败，休眠一段时间，再进行尝试。</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(DEFAULT_SLEEP_TIME);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="基于Redis的加锁第三版"><a href="#基于Redis的加锁第三版" class="headerlink" title="基于Redis的加锁第三版"></a>基于Redis的加锁第三版</h1><p>具体通过<code>set</code>方法来实现<code>setnx</code>和<code>expire</code>的相加功能，实现了原子操作。<br>如果key不存在时，就进行加锁操作，并对锁设置一个有效期，同时uniqueId表示加锁的客户端；如果key存在，不做任何操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addLockVersion3</span><span class="params">(String key, String uniqueId, <span class="keyword">int</span> blockTime, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> endTime = System.currentTimeMillis() + blockTime;</span><br><span class="line">            <span class="keyword">while</span> (System.currentTimeMillis() &lt; endTime) &#123;</span><br><span class="line">                jedis = jedisPool.getResource();</span><br><span class="line">                String result = jedis.set(key, uniqueId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">                <span class="keyword">if</span> (LOCK_STATE.equals(result))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(DEFAULT_SLEEP_TIME);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="基于Redis的加锁第四版"><a href="#基于Redis的加锁第四版" class="headerlink" title="基于Redis的加锁第四版"></a>基于Redis的加锁第四版</h1><p>为了使对同一个对象添加多次锁，并且不发生阻塞，即实现类似可重入锁，我们借鉴了<code>ReetrantLock</code>的思想，添加了变量<code>states</code>来控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addLockVersion4</span><span class="params">(String key, String uniqueId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> state = states.get();</span><br><span class="line">        <span class="keyword">if</span> (state &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            states.set(state+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> doLock(key, uniqueId, expireTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doLock</span><span class="params">(String key, String uniqueId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (expireTime &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            String result = jedis.set(key, uniqueId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">            <span class="keyword">if</span> (LOCK_STATE.equals(result))</span><br><span class="line">                states.set(states.get() + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="基于Redis的加锁第五版"><a href="#基于Redis的加锁第五版" class="headerlink" title="基于Redis的加锁第五版"></a>基于Redis的加锁第五版</h1><p>从上面可知，利用<code>setnx</code>和<code>expire</code>实现加锁机制时因为不是原子操作，会产生一些问题，我们可用lua脚本来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addLockVersion5</span><span class="params">(String key, String uniqueId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            String luaScript = <span class="string">"if redis.call('setnx',KEYS[1],ARGV[1]) == 1 then"</span> +</span><br><span class="line">                    <span class="string">"redis.call('expire',KEYS[1],ARGV[2]) return 1 else return 0 end"</span>;</span><br><span class="line">            List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            keys.add(key);</span><br><span class="line">            values.add(uniqueId);</span><br><span class="line">            values.add(String.valueOf(expireTime));</span><br><span class="line">            Object result = jedis.eval(luaScript, keys, values);</span><br><span class="line">            <span class="keyword">if</span> ((Long)result == <span class="number">1L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="基于Redis的释放锁第一版"><a href="#基于Redis的释放锁第一版" class="headerlink" title="基于Redis的释放锁第一版"></a>基于Redis的释放锁第一版</h1><p>在解锁时首先判断加速与解锁是否是同一个客户端，然后利用<code>del</code>方法进行删除。<br>但是会出现一些问题。<br>当方法执行到判断内部时，即将要执行<code>del</code>方法时，该锁已经过期了，并被其他的客户端所请求应有，此时执行<code>del</code>会造成锁的误删。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLockVersion1</span><span class="params">(String key, String uniqueId)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            <span class="comment">//加锁与解锁是否是同一个客户端</span></span><br><span class="line">            String lockId = jedis.get(key);</span><br><span class="line">            <span class="keyword">if</span> (lockId != <span class="keyword">null</span> &amp;&amp; lockId.equals(uniqueId)) &#123;</span><br><span class="line">                jedis.del(key);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="基于Redis的释放锁第二版"><a href="#基于Redis的释放锁第二版" class="headerlink" title="基于Redis的释放锁第二版"></a>基于Redis的释放锁第二版</h1><p>从上面的分析来看，我们要确保删除的原子性，利用lua脚本可以保证一点。<br>在脚本语言里，KEYS[1]和ARGV[1]分别表示传入的key名和唯一标识符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLockVersion2</span><span class="params">(String key, String uniqueId)</span> </span>&#123;</span><br><span class="line">        String luaScript = <span class="string">"if  redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            result = jedis.eval(luaScript, Collections.singletonList(key), Collections.singletonList(uniqueId));</span><br><span class="line">            <span class="keyword">if</span> ((Long)result == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="基于Redis的释放锁第三版"><a href="#基于Redis的释放锁第三版" class="headerlink" title="基于Redis的释放锁第三版"></a>基于Redis的释放锁第三版</h1><p>在利用可重入锁思想时，只有当<code>states=1</code>时才能被释放，大于0时，只能进行减1操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLockVersion3</span><span class="params">(String key, String uniqueId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> state = states.get();</span><br><span class="line">        <span class="keyword">if</span> (state &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            states.set(states.get() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.doRelease(key, uniqueId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doRelease</span><span class="params">(String key, String uniqueId)</span> </span>&#123;</span><br><span class="line">        String luaScript = <span class="string">"if  redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            result = jedis.eval(luaScript, Collections.singletonList(key), Collections.singletonList(uniqueId));</span><br><span class="line">            <span class="keyword">if</span> ((Long)result == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            states.set(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="利用Zookeeper实现分布式锁"><a href="#利用Zookeeper实现分布式锁" class="headerlink" title="利用Zookeeper实现分布式锁"></a>利用Zookeeper实现分布式锁</h1><p>Zookeeper提供一个多层次的节点命名空间，每个节点都用一个以斜杠（/）分割的路径表示，<br>而且每个节点都有父节点（根节点除外），非常类似于文件系统。</p><p><strong>基本思想流程</strong></p><ul><li>在某父节点下添加创建一个节点，</li><li>获取该父节点下的所有子节点，并进行排序，获得有个有序序列</li><li>如果当前添加的节点是序列中序号最小的节点，表示获取锁成功</li><li>如果不是最小的节点，则对在有序列表中的它的前一个节点进行监听，当被监听的节点被删除后，会通知该节点获取锁。</li><li>解锁的时候删除当前节点。</li></ul><p><strong>实现代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">zklock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ZkClient zkClient;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String currentLockPath;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATENT_LOCK_PATH = <span class="string">"distribute_lock"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RETEY_TIMES = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WAIT_TIME = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">zklock</span><span class="params">(ZkClient zkClient, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zkClient = zkClient;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!zkClient.exists(PATENT_LOCK_PATH)) &#123;</span><br><span class="line">            zkClient.createPersistent(PATENT_LOCK_PATH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> iscompleted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!iscompleted) &#123;</span><br><span class="line">            iscompleted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//创建当前目录下的临时有序节点</span></span><br><span class="line">                currentLockPath = zkClient.createEphemeralSequential(PATENT_LOCK_PATH + <span class="string">"/"</span>, System.currentTimeMillis());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count++ &lt; MAX_RETEY_TIMES) &#123;</span><br><span class="line">                    iscompleted = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">throw</span>  e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        zkClient.delete(currentLockPath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查是否是最小的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkMinNode</span><span class="params">(String localPath)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; children = zkClient.getChildren(PATENT_LOCK_PATH);</span><br><span class="line">        Collections.sort(children);</span><br><span class="line">        <span class="keyword">int</span> index = children.indexOf(localPath.substring(PATENT_LOCK_PATH.length()+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (countDownLatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String waitPath = PATENT_LOCK_PATH + <span class="string">"/"</span> + children.get(index-<span class="number">1</span>);</span><br><span class="line">            waitForLock(waitPath, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听有序序列中的前一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">waitForLock</span><span class="params">(String waitPath, <span class="keyword">boolean</span> useTime)</span> </span>&#123;</span><br><span class="line">        countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        zkClient.subscribeDataChanges(waitPath, <span class="keyword">new</span> IZkDataListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataChange</span><span class="params">(String s, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataDeleted</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                 checkMinNode(currentLockPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (!zkClient.exists(waitPath)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (useTime == <span class="keyword">true</span>)</span><br><span class="line">                countDownLatch.await(DEFAULT_WAIT_TIME, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于Redis和Zookeeper的分布式锁的优劣"><a href="#基于Redis和Zookeeper的分布式锁的优劣" class="headerlink" title="基于Redis和Zookeeper的分布式锁的优劣"></a>基于Redis和Zookeeper的分布式锁的优劣</h1><ul><li>Redis是nosql数据库，主要特点是缓存；</li><li>Zookeeper是分布式协调工具，主要用于分布式解决方案。</li></ul><p><strong>加锁机制</strong></p><ul><li>Redis: 通过<code>set</code>方法创建key， 因为Redis的key是唯一的，谁先创建成功，谁能够先获得锁。</li><li>Zookeeper: 会在Zookeeper上创建一个临时节点，因为Zookeeper节点命名路径保证唯一，只要谁先创建成功，谁能够获取到锁。</li></ul><p><strong>释放锁</strong></p><ul><li>Redis: 为了确保锁的一致性问题，在删除的redis的key时，需要判断是否是之前拥有该锁的客户端；通过设置有效期解决死锁。</li><li>Zookeeper: 直接关闭临时节点session会话连接，因为临时节点生命周期与session会话绑定在一块，如果session会话连接关闭的话，该临时节点也会被删除。</li></ul><p>就性能而言，redis是Nosql数据库，性能优于zookeeper;就健壮性而言，zookeeper明显优于redis。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么要设计分布式锁&quot;&gt;&lt;a href=&quot;#为什么要设计分布式锁&quot; class=&quot;headerlink&quot; title=&quot;为什么要设计分布式锁&quot;&gt;&lt;/a&gt;为什么要设计分布式锁&lt;/h1&gt;&lt;p&gt;  在简单的单机系统中，当存在多个线程同时要修改某个共享变量时，为了数据的操
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>redo日志、undo日志、binlog日志与doublewrite分析</title>
    <link href="https://github.com/spurstong/2020/01/11/redo%E6%97%A5%E5%BF%97%E3%80%81undo%E6%97%A5%E5%BF%97%E3%80%81binlog%E6%97%A5%E5%BF%97%E4%B8%8Edoulewrite%E6%93%8D%E4%BD%9C/"/>
    <id>https://github.com/spurstong/2020/01/11/redo日志、undo日志、binlog日志与doulewrite操作/</id>
    <published>2020-01-11T07:46:35.000Z</published>
    <updated>2020-01-11T07:47:14.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="binlog日志-（二进制日志）"><a href="#binlog日志-（二进制日志）" class="headerlink" title="binlog日志 （二进制日志）"></a>binlog日志 （二进制日志）</h1><p>二进制日志记录了对MySQL数据库<strong>执行更改的所有操作</strong>，它是一种逻辑操作，其记录的是对应的SQL语句。但是，不会记录SELECT和SHOW这类操作，因为这类操作对数据本身并没有修改。</p><h2 id="二进制文件格式"><a href="#二进制文件格式" class="headerlink" title="二进制文件格式"></a>二进制文件格式</h2><p>MySQL通过binlog_format参数来设置二进制文件格式。</p><ul><li><strong>STATEMENT格式</strong>。 最基础的版本。它记录的是日志的逻辑SQL语句。</li><li><strong>ROW格式</strong>。记录的不是简单的逻辑SQL语句，而是记录表的行更改情况，记录的是表中每个字段的值。</li><li><strong>MIXED格式</strong>。MySQL默认采用STATEMENT格式进行记录，但是一旦判断可能会有数据不一致的情况，则会有ROW格式来记录。</li></ul><h2 id="二进制文件的用途"><a href="#二进制文件的用途" class="headerlink" title="二进制文件的用途"></a>二进制文件的用途</h2><ul><li><strong>恢复</strong>。某些数据的恢复需要二进制文件。</li><li><strong>复制</strong>。通过复制和执行二进制文件进行两个数据库之间的实时同步。</li><li><strong>审计</strong>。判断是否有对数据库进行注入的攻击。</li></ul><p>在默认情况下，二进制文件并不是在每次写的时候同步到磁盘中。因此，当数据库所在操作系统发生宕机时，可能会有最后一部分数据没有写入到二进制日志文件中，这会给恢复和复制带来问题。<br>所有未提交的二进制日志会被记录到一个缓存中，等该事务提交时直接将缓存的二进制日志写入二进制日志文件，而该缓存的大小由binlog_cache_size决定。</p><h1 id="Redo日志"><a href="#Redo日志" class="headerlink" title="Redo日志"></a>Redo日志</h1><p>binlog主要用来做数据归档，但它不具备崩溃恢复的能力，如果你的系统突然崩溃宕机，重启后可能会有部分数据丢失，而Redo日志能够有效解决这个问题。可以把它看做一种恢复操作，它恢复提交事务修改的页操作。大部分情况下，Redo是<strong>物理日志</strong>，记录的是数据页的物理操作。<br>它主要有两部分：（1）重做日志缓冲，其是丢失的；（2）重做日志文件，其是持久的。</p><h2 id="Redo的整体流程"><a href="#Redo的整体流程" class="headerlink" title="Redo的整体流程"></a>Redo的整体流程</h2><ol><li>先将原始数据从磁盘中读入内存中，修改数据的内存拷贝</li><li>生成一条重做日志并写入重做日志缓存中，记录的是数据被修改后的值</li><li>当事务提交时，将重做日志缓存中的内容刷新追加到重做日志文件中。</li><li>定期将内存中修改的数据刷新到磁盘中。<h2 id="何时写入到Redo-重做日志文件-中"><a href="#何时写入到Redo-重做日志文件-中" class="headerlink" title="何时写入到Redo(重做日志文件)中"></a>何时写入到Redo(重做日志文件)中</h2></li></ol><ul><li>master thread 每一秒将重做日志缓存刷新到重做日志文件中。</li><li>每次事务提交时。</li><li>当重做日志缓存池剩余空间小于1/2时。</li></ul><h2 id="Redo日志与二进制日志的不同"><a href="#Redo日志与二进制日志的不同" class="headerlink" title="Redo日志与二进制日志的不同"></a>Redo日志与二进制日志的不同</h2><p>从表面上看，它们非常相似，都是记录了数据库操作的日志，但从本质上看，两者有非常大的不同。</p><ol><li><strong>产生位置不同</strong>。重做日志是在InnoDB存储引擎层中产生，而二进制日志是在MySQL数据库的上层产生。</li><li><strong>记录的内容形式不同</strong>。二进制日志是一种逻辑日志，其记录的是对应的SQL语句，但是在ROW格式下，它记录的是物理文件；而重做日志是物理格式日志，其记录的是对于每个页的修改。</li><li><strong>写入磁盘的时间点不同</strong>。二进制日志只是在事务提交完成后进行一次写入，而InnoDB存储引擎的重做日志在事务进行中不断被写入，</li></ol><h1 id="Undo日志"><a href="#Undo日志" class="headerlink" title="Undo日志"></a>Undo日志</h1><p>当用户执行的事务或语句由于某种原因失败时，又或者用户用一条ROLLBACK语句请求回滚，就可以利用这些undo信息将数据回滚到修改之前的样子。还有一个作用是MVCC。</p><p>undo存放在数据库内部的一个特殊段中，成为undo端（undo segment）。undo是逻辑日志，因此只是将数据库逻辑地恢复到原来的样子。所有修改都被逻辑地取消了，但是数据结构和页本身在回滚之后可能大不相同。<br>在MVCC中，当用户读取一行记录时，若该记录已经被其他事务占用，当前事务可以通过undo读取之前的行版本信息，以此实现非锁定读。</p><h2 id="undo-log格式"><a href="#undo-log格式" class="headerlink" title="undo log格式"></a>undo log格式</h2><ul><li><p>insert undo log<br>是指在insert操作中产生的undo log。因为insert操作的记录，只对事务本身可见，对其他事务不可见，故该undo log可以在事务提交后直接删除，不需要进行purge操作。</p></li><li><p>updae undo log<br>记录的是对delete和update操作产生的undo log。该undo log可能需要提供MVCC机制，因此不能在事务提交时就进行删除，提交时放入到undo log链表，等待purge线程进行最后的删除。</p></li></ul><h2 id="purge"><a href="#purge" class="headerlink" title="purge"></a>purge</h2><p>例如语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> t <span class="keyword">where</span> a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>其中，表t上列a有聚集索引，列b上有辅助索引。当执行delete删除操作时，仅是将主键列等于1的记录delete flag设置为1，记录并没有被删除，即记录还是存在于B+树中，其次，对于辅助索引上列a等于1，b等于1的记录同样没有做任何处理，甚至没有产生undo log。而真正删除这行记录的操作其实被“延迟”了，在purge操作中完成。<br>在MVCC下，有可能其他事务也在引用该行记录，故InnoDB需要保存记录之前的版本，当该条记录不被任何事务所引用时，那么可以执行真正的delete操作。</p><h1 id="doublewrite-两次写"><a href="#doublewrite-两次写" class="headerlink" title="doublewrite(两次写)"></a>doublewrite(两次写)</h1><p>doublewrite能够确保InnoDB存储引擎的数据页的可靠性。<br>如果InnnoDB存储引擎正在写入某个页到表中，可能只写了页中的一部分就发生了宕机等故障，造成部分写失效。需要对数据进行恢复。<br>可能首先想到实现数据恢复的做法是利用Redo log（重做日志）,但是重做日志记录的是对页的物理操作，但是如果这个页已经发生了损坏，再对其页页进行重做就没有意义了。这时就用到了<strong>doublewrite</strong>操作。<br>简单的说，在应用重做日志之前，用户需要一个页的副本，当写入失效发生时，先通过页的副本来还原该页，再进行重做。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/%E6%95%B0%E6%8D%AE%E5%BA%93doublewrite/1.png" alt="doublewrite步骤"><br>doublewrite由两部分组成，一部分是内存中的doublewrite,大小为2MB;另一部分是物理磁盘上共享表空间中连续的128个页，即两个区，大小同样我2MB。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过memcpy函数将脏页先复制到内存中的doublewrite buffer,之后通过double write再分两次，每次1MB顺序地写入共享表空间的物理磁盘上，然后马上调用fsync函数，同步磁盘，避免缓冲写带来的问题。<br>如果操作系统在将页写入磁盘的过程中发生了崩溃，在恢复过程中，InnoDB存储引擎可以从共享表空间中的doublewrite中找到该页的一个副本，将其复制到表空间文件中，再应用重做日志。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;binlog日志-（二进制日志）&quot;&gt;&lt;a href=&quot;#binlog日志-（二进制日志）&quot; class=&quot;headerlink&quot; title=&quot;binlog日志 （二进制日志）&quot;&gt;&lt;/a&gt;binlog日志 （二进制日志）&lt;/h1&gt;&lt;p&gt;二进制日志记录了对MySQL
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rocketMq消息主从同步机制</title>
    <link href="https://github.com/spurstong/2019/12/04/rocketMq%E6%B6%88%E6%81%AF%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    <id>https://github.com/spurstong/2019/12/04/rocketMq消息主从同步机制/</id>
    <published>2019-12-04T10:05:44.505Z</published>
    <updated>2019-12-05T14:39:21.545Z</updated>
    
    <content type="html"><![CDATA[<p>RocketMQ具有高可用性，消息消费到达主服务器Master后需要将消息同步到消息从服务器Slave,如果主服务器Master宕机后，消息消费者可以向Slave拉取消息。</p><h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p>主服务器Master启动，监听从服务器Slave的监听；从服务器Slave启动，主动向主服务器建立Tcp长连接，然后获取从服务器Slave的commitlog的最大偏移量，以此偏移量向主服务器Master主动拉取消息（间隔5s发送一次），主服务器根据偏移量，与自身commitlog文件的最大偏移量进行比较，如果大于Slave的最大偏移量，主服务器Master将向从服务器Slave返回一定数量的消息，将消息写入到Slave的commitlog文件中，该过程循环进行，如果从服务器Slave的最大偏移量大于等于主服务器Master的最大偏移量，说明主从服务器数据同步完成。</p><h1 id="相关类介绍"><a href="#相关类介绍" class="headerlink" title="相关类介绍"></a>相关类介绍</h1><p>HAservice: 主从同步核心实现类<br>AcceptSocketService： HA Master端监听客户端连接实现类<br>GroupTransferService: 主从同步通知实现类<br>HAClient: HA Client端实现类（从服务器）<br>HAConnection: HA Master服务端HA连接对象的封装，与Broker从服务器的网络读写实现类<br>ReadSocketService: HA Master网络读实现类<br>WriterSocketService: HA Master网络写实现类</p><h1 id="主从同步Slave端实现"><a href="#主从同步Slave端实现" class="headerlink" title="主从同步Slave端实现"></a>主从同步Slave端实现</h1><p>相关类是HAClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HAClient</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READ_MAX_BUFFER_SIZE = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// 主节点IP:PORT</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;String&gt; masterAddress = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">        <span class="comment">// 向Master汇报Slave最大Offset</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer reportOffset = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> lastWriteTimestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// Slave向Master汇报Offset，汇报到哪里</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> currentReportedOffset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> dispatchPostion = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从Master接收数据Buffer</span></span><br><span class="line">        <span class="keyword">private</span> ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);</span><br><span class="line">        <span class="keyword">private</span> ByteBuffer byteBufferBackup = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与Master进行连接</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">connectMaster</span><span class="params">()</span> <span class="keyword">throws</span> ClosedChannelException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == socketChannel) &#123;</span><br><span class="line">                String addr = <span class="keyword">this</span>.masterAddress.get();</span><br><span class="line">                <span class="keyword">if</span> (addr != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    SocketAddress socketAddress = RemotingUtil.string2SocketAddress(addr);</span><br><span class="line">                    <span class="keyword">if</span> (socketAddress != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.socketChannel = RemotingUtil.connect(socketAddress);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.socketChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.socketChannel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_READ);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 每次连接时，要重新拿到最大的Offset</span></span><br><span class="line">                <span class="keyword">this</span>.currentReportedOffset = HAService.<span class="keyword">this</span>.defaultMessageStore.getMaxPhyOffset();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.lastWriteTimestamp = System.currentTimeMillis();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.socketChannel != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>Slave服务器连接Master服务器，获取当前文件的最大偏移量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isTimeToReportOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">long</span> interval =</span><br><span class="line">               HAService.<span class="keyword">this</span>.defaultMessageStore.getSystemClock().now() - <span class="keyword">this</span>.lastWriteTimestamp;</span><br><span class="line">           <span class="keyword">boolean</span> needHeart = interval &gt; HAService.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig()</span><br><span class="line">               .getHaSendHeartbeatInterval();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> needHeart;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>判断是否向Master反馈当前待拉取偏移量，默认间隔5s发送一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">reportSlaveMaxOffset</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> maxOffset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.reportOffset.position(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">this</span>.reportOffset.limit(<span class="number">8</span>);</span><br><span class="line">  <span class="keyword">this</span>.reportOffset.putLong(maxOffset);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.reportOffset.position(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">this</span>.reportOffset.limit(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送失败了试三次，成功就成功</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> &amp;&amp; <span class="keyword">this</span>.reportOffset.hasRemaining(); i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.socketChannel.write(<span class="keyword">this</span>.reportOffset);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">log.error(<span class="keyword">this</span>.getServiceName()</span><br><span class="line">+ <span class="string">"reportSlaveMaxOffset this.socketChannel.write exception"</span>, e);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> !<span class="keyword">this</span>.reportOffset.hasRemaining();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向Master服务器反馈拉取偏移量，如果发送失败，会再进行尝试，总共三次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">processReadEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> readSizeZeroTimes = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.byteBufferRead.hasRemaining()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> readSize = <span class="keyword">this</span>.socketChannel.read(<span class="keyword">this</span>.byteBufferRead);</span><br><span class="line">                    <span class="keyword">if</span> (readSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        lastWriteTimestamp = HAService.<span class="keyword">this</span>.defaultMessageStore.getSystemClock().now();</span><br><span class="line">                        readSizeZeroTimes = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">boolean</span> result = <span class="keyword">this</span>.dispatchReadRequest();</span><br><span class="line">                        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                            log.error(<span class="string">"HAClient, dispatchReadRequest error"</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readSize == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (++readSizeZeroTimes &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// TODO ERROR</span></span><br><span class="line">                        log.info(<span class="string">"HAClient, processReadEvent read socket &lt; 0"</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    log.info(<span class="string">"HAClient, processReadEvent read socket exception"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>处理网络请求，即处理从Master服务器传回的消息数据。循环判断readByteBuffer是否有剩余空间，如果存在剩余空间，则将通道里的数据读入到读缓存区中。<br> 1） 如果读取到的字节数大于0，重置读取到0字节的次数，并更新最后一次写入时间戳，然后将读取到的所有消息全部追加到消息内存映射文件中，然后再次反馈拉取进度给服务器。<br> 2） 如果连续3次从网络通道里读取到0个字节，则结束本次读，并返回true。<br> 3） 如果读取到的字节数小于0或发生IO异常，则返回false。</p><h1 id="主服务器Master处理请求"><a href="#主服务器Master处理请求" class="headerlink" title="主服务器Master处理请求"></a>主服务器Master处理请求</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HAConnection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HAService haService;</span><br><span class="line">    <span class="comment">// 网络socket通道</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="comment">// 客户端连接地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String clientAddr;</span><br><span class="line">    <span class="comment">// 服务端向从服务器slave写数据服务类</span></span><br><span class="line">    <span class="keyword">private</span> WriteSocketService writeSocketService;</span><br><span class="line">    <span class="comment">// 服务端从从服务器slave读数据服务类</span></span><br><span class="line">    <span class="keyword">private</span> ReadSocketService readSocketService;</span><br><span class="line">    <span class="comment">// 从服务器slave请求拉取数据的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> slaveRequestOffset = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从服务器slave反馈已拉取完成的数据偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> slaveAckOffset = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>Master服务器每隔1s处理一次slave发起的拉取请求。<br>首先会调用proccessReadEvent方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">processReadEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> readSizeZeroTimes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.byteBufferRead.hasRemaining()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.byteBufferRead.flip();</span><br><span class="line">                <span class="keyword">this</span>.processPostion = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.byteBufferRead.hasRemaining()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> readSize = <span class="keyword">this</span>.socketChannel.read(<span class="keyword">this</span>.byteBufferRead);</span><br><span class="line">                    <span class="keyword">if</span> (readSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        readSizeZeroTimes = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">this</span>.lastReadTimestamp = HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getSystemClock().now();</span><br><span class="line">                        <span class="keyword">if</span> ((<span class="keyword">this</span>.byteBufferRead.position() - <span class="keyword">this</span>.processPostion) &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">                            <span class="keyword">int</span> pos = <span class="keyword">this</span>.byteBufferRead.position() - (<span class="keyword">this</span>.byteBufferRead.position() % <span class="number">8</span>);</span><br><span class="line">                            <span class="keyword">long</span> readOffset = <span class="keyword">this</span>.byteBufferRead.getLong(pos - <span class="number">8</span>);</span><br><span class="line">                            <span class="keyword">this</span>.processPostion = pos;</span><br><span class="line"></span><br><span class="line">                            HAConnection.<span class="keyword">this</span>.slaveAckOffset = readOffset;</span><br><span class="line">                            <span class="keyword">if</span> (HAConnection.<span class="keyword">this</span>.slaveRequestOffset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                HAConnection.<span class="keyword">this</span>.slaveRequestOffset = readOffset;</span><br><span class="line">                                log.info(<span class="string">"slave["</span> + HAConnection.<span class="keyword">this</span>.clientAddr + <span class="string">"] request offset "</span> + readOffset);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            HAConnection.<span class="keyword">this</span>.haService.notifyTransferSome(HAConnection.<span class="keyword">this</span>.slaveAckOffset);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readSize == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (++readSizeZeroTimes &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log.error(<span class="string">"read socket["</span> + HAConnection.<span class="keyword">this</span>.clientAddr + <span class="string">"] &lt; 0"</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    log.error(<span class="string">"processReadEvent exception"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>1) 如果byteBufferRead没有剩余空间，则调用byteBufferRead.flip()清空，并设置processPostion为0，表示从头开始处理。<br>2) 当byteBuffer有剩余空间时，先预设readSizeZeroTimes为0，如果读取的字节大于0并且本次读取到的内容大于8，则表明收到了从服务器Slave一条拉取消息的请求，并调用<strong>notifyTransferSome</strong>方法。<br>3) 如果读取到的字节数等于0，则判断readSizeZeroTimes，当小于3时需要再进行循环处理，如果大于3，说明该批次请求已成功处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyTransferSome</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">long</span> value = <span class="keyword">this</span>.push2SlaveMaxOffset.get(); offset &gt; value; ) &#123;</span><br><span class="line">           <span class="keyword">boolean</span> ok = <span class="keyword">this</span>.push2SlaveMaxOffset.compareAndSet(value, offset);</span><br><span class="line">           <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">               <span class="keyword">this</span>.groupTransferService.notifyTransferSome();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               value = <span class="keyword">this</span>.push2SlaveMaxOffset.get();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>该方法的参数offset记录的是从服务器slave反馈的已拉取完成的数据偏移量，<br>push2SlaveMaxOffset记录的是写入到Slave的最大偏移量。<br>如果从服务器slave确认的偏移量大于push2SlaveMaxOffset,说明该批次主从同步成功，并更新push2SlaveMaxOffset,<br>则唤醒GroupTransferService线程，各消息发送者线程再次判断自己</p><p>然后介绍WriteSocketService线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (-<span class="number">1</span> == HAConnection.<span class="keyword">this</span>.slaveRequestOffset) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure><p>如果<strong>slaveRequestOffset</strong>等于-1，说明Master还未收到从服务器的拉取请求，放弃本事件的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (-<span class="number">1</span> == <span class="keyword">this</span>.nextTransferFromWhere) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (<span class="number">0</span> == HAConnection.<span class="keyword">this</span>.slaveRequestOffset) &#123;</span><br><span class="line">                           <span class="keyword">long</span> masterOffset = HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getCommitLog().getMaxOffset();</span><br><span class="line">                           masterOffset =</span><br><span class="line">                               masterOffset</span><br><span class="line">                                   - (masterOffset % HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig()</span><br><span class="line">                                   .getMapedFileSizeCommitLog());</span><br><span class="line"></span><br><span class="line">                           <span class="keyword">if</span> (masterOffset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                               masterOffset = <span class="number">0</span>;</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                           <span class="keyword">this</span>.nextTransferFromWhere = masterOffset;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="keyword">this</span>.nextTransferFromWhere = HAConnection.<span class="keyword">this</span>.slaveRequestOffset;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       log.info(<span class="string">"master transfer data from "</span> + <span class="keyword">this</span>.nextTransferFromWhere + <span class="string">" to slave["</span> + HAConnection.<span class="keyword">this</span>.clientAddr</span><br><span class="line">                           + <span class="string">"], and slave request "</span> + HAConnection.<span class="keyword">this</span>.slaveRequestOffset);</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure><p>如果<strong>nextTransferFromWhere</strong>等于-1，表示初次进行数据传输，计算待传输的物理偏移量，如果slaveRequestOffset为0，则从当前commitlog文件最大偏移量开始传输，否则根据从服务器的拉取请求偏移量开始传输。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.lastWriteOver) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">long</span> interval =</span><br><span class="line">                            HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getSystemClock().now() - <span class="keyword">this</span>.lastWriteTimestamp;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (interval &gt; HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig()</span><br><span class="line">                            .getHaSendHeartbeatInterval()) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// Build Header</span></span><br><span class="line">                            <span class="keyword">this</span>.byteBufferHeader.position(<span class="number">0</span>);</span><br><span class="line">                            <span class="keyword">this</span>.byteBufferHeader.limit(headerSize);</span><br><span class="line">                            <span class="keyword">this</span>.byteBufferHeader.putLong(<span class="keyword">this</span>.nextTransferFromWhere);</span><br><span class="line">                            <span class="keyword">this</span>.byteBufferHeader.putInt(<span class="number">0</span>);</span><br><span class="line">                            <span class="keyword">this</span>.byteBufferHeader.flip();</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">this</span>.lastWriteOver = <span class="keyword">this</span>.transferData();</span><br><span class="line">                            <span class="keyword">if</span> (!<span class="keyword">this</span>.lastWriteOver)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.lastWriteOver = <span class="keyword">this</span>.transferData();</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="keyword">this</span>.lastWriteOver)</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure><p>判断上次写事件是否已将消息全部写入客户端，如果已全部写入，并且当前系统时间与上次最后写入的时间间隔大于HA心跳检测时间，则发送一个心跳包，避免长连接由于空闲被关闭；如果上次数据未写完，则先传输上一次的数据，如果消息还是未全部传输，则结束此次事件处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SelectMappedBufferResult selectResult =</span><br><span class="line">                        HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getCommitLogData(<span class="keyword">this</span>.nextTransferFromWhere);</span><br><span class="line">                    <span class="keyword">if</span> (selectResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> size = selectResult.getSize();</span><br><span class="line">                        <span class="keyword">if</span> (size &gt; HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize()) &#123;</span><br><span class="line">                            size = HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">long</span> thisOffset = <span class="keyword">this</span>.nextTransferFromWhere;</span><br><span class="line">                        <span class="keyword">this</span>.nextTransferFromWhere += size;</span><br><span class="line"></span><br><span class="line">                        selectResult.getByteBuffer().limit(size);</span><br><span class="line">                        <span class="keyword">this</span>.selectMappedBufferResult = selectResult;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Build Header</span></span><br><span class="line">                        <span class="keyword">this</span>.byteBufferHeader.position(<span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">this</span>.byteBufferHeader.limit(headerSize);</span><br><span class="line">                        <span class="keyword">this</span>.byteBufferHeader.putLong(thisOffset);</span><br><span class="line">                        <span class="keyword">this</span>.byteBufferHeader.putInt(size);</span><br><span class="line">                        <span class="keyword">this</span>.byteBufferHeader.flip();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">this</span>.lastWriteOver = <span class="keyword">this</span>.transferData();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        HAConnection.<span class="keyword">this</span>.haService.getWaitNotifyObject().allWaitForRunning(<span class="number">100</span>);</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure><p>传输消息到从服务器slave<br>1) 根据消息从服务器slave请求的待拉取偏移量，查找该偏移量之后的所有的可读消息，如果未查到匹配的消息，通知所有等待线程继续等待100ms。<br>2) 如果匹配到消息，且查找到的消息总长度大于配置的一次传输最大字节数，则会进行截取，可能会包含不完整的消息。</p><p>主服务器Master会一直执行该线程，每次事件处理完成后等待1s。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWaitTransfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!<span class="keyword">this</span>.requestsRead.isEmpty()) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (CommitLog.GroupCommitRequest req : <span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">                       <span class="keyword">boolean</span> transferOK = HAService.<span class="keyword">this</span>.push2SlaveMaxOffset.get() &gt;= req.getNextOffset();</span><br><span class="line">                       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; !transferOK &amp;&amp; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                           <span class="keyword">this</span>.notifyTransferObject.waitForRunning(<span class="number">1000</span>);</span><br><span class="line">                           transferOK = HAService.<span class="keyword">this</span>.push2SlaveMaxOffset.get() &gt;= req.getNextOffset();</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">if</span> (!transferOK) &#123;</span><br><span class="line">                           log.warn(<span class="string">"transfer messsage to slave timeout, "</span> + req.getNextOffset());</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       req.wakeupCustomer(transferOK);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">this</span>.requestsRead.clear();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>GroupTransferService#doWaitTransfer()方法<br>该类是主从同步复制的实现类</p><p>在进行主从同步时，有同步主从模式和异步主从模式，当主服务器Master发送消息给从服务器Slave时，需要先判断上一次同步主从复制的结果，如果Slave中已成功复制的最大偏移量是否大于Master发送给Slave消息后返回的下一条消息的起始偏移量，如果大于，则说明上一个主从同步复制已经完成，则会唤醒阻塞等待的消息发送到Slave的命令。</p><p>RocketMq读写分离与其他中间件的实现方式完全不同，RoketMq是消息者首先向主服务器Master发起拉取消息请求，然后主服务器返回一批消息，然后会根据主服务器负载压力与主从同步情况，建议下次消息拉取是从主服务器还是从从服务器拉取。</p><p>决定消费者是否向从服务器拉取消息消费的值存在 GetMessageResult 类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> suggestPullingFromSlave = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>其默认值为 false，即默认消费者不会消费从服务器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> diff = maxOffsetPy - maxPhyOffsetPulling;</span><br><span class="line"><span class="keyword">long</span> memory = (<span class="keyword">long</span>) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE</span><br><span class="line">    * (<span class="keyword">this</span>.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / <span class="number">100.0</span>));</span><br><span class="line">getResult.setSuggestPullingFromSlave(diff &gt; memory);</span><br></pre></td></tr></table></figure><p>其中 maxOffsetPy 为当前最大物理偏移量，maxPhyOffsetPulling 为本次消息拉取最大物理偏移量，他们的差即可表示消息堆积量，TOTAL_PHYSICAL_MEMORY_SIZE 表示当前系统物理内存，accessMessageInMemoryMaxRatio 的默认值为 40，以上逻辑即可算出当前消息堆积量是否大于物理内存的 40 %，如果大于则将 suggestPullingFromSlave 设置为 true。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RocketMQ具有高可用性，消息消费到达主服务器Master后需要将消息同步到消息从服务器Slave,如果主服务器Master宕机后，消息消费者可以向Slave拉取消息。&lt;/p&gt;
&lt;h1 id=&quot;整体流程&quot;&gt;&lt;a href=&quot;#整体流程&quot; class=&quot;headerlin
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ消费者消息队列负载均衡</title>
    <link href="https://github.com/spurstong/2019/11/30/RocketMQ%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>https://github.com/spurstong/2019/11/30/RocketMQ消费者消息队列负载均衡/</id>
    <published>2019-11-30T10:23:21.282Z</published>
    <updated>2019-11-30T14:57:35.198Z</updated>
    
    <content type="html"><![CDATA[<p>先从整体流程上简单梳理一下消息队列负载的过程。</p><p>消息队列负载由Rebalance线程默认每隔20s进行一次消息队列负载，获取主题队列信息mqSet与消费组当前所有消费者cidAll,然后按照某一种负载算法进行队列分配，分配原则为同一个消费者可以分配多个消息消息队列，同一个消息消费队列同一时间只会分配给一个消费者。此时，可以计算当前消费者分配到消息队列集合，对比原先的负载队列与当前的分配队列。如果新队列集合中不包含原来的队列，则停止原先队列消息消费并移除，如果原先队列中不包含新分配队列则创建PullRequest。</p><h1 id="何时会触发启动"><a href="#何时会触发启动" class="headerlink" title="何时会触发启动"></a>何时会触发启动</h1><ul><li>每隔20s会自动进行一次</li><li>每次有新的consumer加入到消费组中时，就会执行一次。</li></ul><h1 id="提供的分配算法"><a href="#提供的分配算法" class="headerlink" title="提供的分配算法"></a>提供的分配算法</h1><ul><li>AllocateMessageQueueAveragely: 平均分配。</li><li>AllocateMessageQueueAveragelyByCircle: 平均轮询分配</li><li>AllocateMessageQueueConsistentHash: 一致性hash</li><li>AllocateMessageQueueByConfig: 根据配置，为每一个消费者配置固定的消息队列。</li><li>AllocateMessageQueueByMachineRoom: 根据Broker部署机房名，对每个消费者负责不同的Broker上的队列。</li></ul><h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>进行负载均衡是在RebalanceService线程中启动的，一个MQClientInstance持有一个RebalanceService实现，并随着MQClientInstance的启动而启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service started"</span>);</span><br><span class="line">       <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">           <span class="comment">//waitInterval默认为20s。</span></span><br><span class="line">           <span class="keyword">this</span>.waitForRunning(waitInterval);</span><br><span class="line">           <span class="comment">//定时负载均衡</span></span><br><span class="line">           <span class="keyword">this</span>.mqClientFactory.doRebalance();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       log.info(<span class="keyword">this</span>.getServiceName() + <span class="string">" service end"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* group */</span>, MQConsumerInner&gt; consumerTable = <span class="keyword">new</span> ConcurrentHashMap&lt;String, MQConsumerInner&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, MQConsumerInner&gt; entry : <span class="keyword">this</span>.consumerTable.entrySet()) &#123;</span><br><span class="line">            MQConsumerInner impl = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    impl.doRebalance();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"doRebalance exception"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMQPushConsumerImpl</span> <span class="keyword">implements</span> <span class="title">MQConsumerInner</span></span></span><br></pre></td></tr></table></figure><p>从上面可以看出，MQClientinstance遍历已注册的消费者，对消费者执行doRebalance方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ConcurrentMap&lt;String <span class="comment">/* topic */</span>, SubscriptionData&gt; subscriptionInner =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;String, SubscriptionData&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRebalance</span><span class="params">(<span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">        Map&lt;String, SubscriptionData&gt; subTable = <span class="keyword">this</span>.getSubscriptionInner();</span><br><span class="line">        <span class="keyword">if</span> (subTable != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">final</span> String topic = entry.getKey();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.rebalanceByTopic(topic, isOrder);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!topic.startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                        log.warn(<span class="string">"rebalanceByTopic Exception"</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.truncateMessageQueueNotMyTopic();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面是遍历订阅信息对每个主题的队列进行重新负载。接下来将执行<em>rebalanceByTopic</em>方法，会根据广播模式或集群模式分别采用不同的方法进行处理。在此处，只解释集群模式下的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;MessageQueue&gt; mqSet = <span class="keyword">this</span>.topicSubscribeInfoTable.get(topic);</span><br><span class="line">List&lt;String&gt; cidAll = <span class="keyword">this</span>.mQClientFactory.findConsumerIdList(topic, consumerGroup);</span><br></pre></td></tr></table></figure><p>获取该主题下的队列信息和该消费组内当前所有的消费者ID。每个DefaultMQPushConsumerImpl都持有一个单独的RebalanceImpl对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mqSet != <span class="keyword">null</span> &amp;&amp; cidAll != <span class="keyword">null</span>) &#123;</span><br><span class="line">    List&lt;MessageQueue&gt; mqAll = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line">    mqAll.addAll(mqSet);</span><br><span class="line"></span><br><span class="line">   Collections.sort(mqAll);</span><br><span class="line">   Collections.sort(cidAll);</span><br><span class="line"></span><br><span class="line">   AllocateMessageQueueStrategy strategy = <span class="keyword">this</span>.allocateMessageQueueStrategy;</span><br><span class="line"></span><br><span class="line">   List&lt;MessageQueue&gt; allocateResult = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">//根据策略进行分配</span></span><br><span class="line">   allocateResult = strategy.allocate(<span class="comment">//</span></span><br><span class="line">   <span class="keyword">this</span>.consumerGroup, <span class="comment">//</span></span><br><span class="line">   <span class="keyword">this</span>.mQClientFactory.getClientId(), <span class="comment">//</span></span><br><span class="line">   mqAll, <span class="comment">//</span></span><br><span class="line">   cidAll);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">   log.error(<span class="string">"AllocateMessageQueueStrategy.allocate Exception. allocateMessageQueueStrategyName=&#123;&#125;"</span>, strategy.getName(),</span><br><span class="line">   e);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AllocateMessageQueueStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Allocating by consumer id</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> consumerGroup current consumer group</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> currentCID current consumer id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> mqAll message queue set in current topic</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cidAll consumer set in current consumer group</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> The allocate result of given strategy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;MessageQueue&gt; <span class="title">allocate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String consumerGroup,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String currentCID,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> List&lt;MessageQueue&gt; mqAll,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> List&lt;String&gt; cidAll</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br></pre></td></tr></table></figure><p>对该主题下的队列信息和该消费组内当前所有的消费者ID进行排序，确保一个消费组的成员看到的顺序是一致的，防止同一个消费队列不会被多个消费者分配。<br><strong>allocateResult</strong>记录的是当前消费者的所分配的消息队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> Set&lt;MessageQueue&gt; allocateResultSet = <span class="keyword">new</span> HashSet&lt;MessageQueue&gt;();</span><br><span class="line"> <span class="keyword">if</span> (allocateResult != <span class="keyword">null</span>) &#123;</span><br><span class="line"> allocateResultSet.addAll(allocateResult);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">boolean</span> changed = <span class="keyword">this</span>.updateProcessQueueTableInRebalance(topic, allocateResultSet, isOrder);</span><br></pre></td></tr></table></figure><p>调用<code>updateProcessQueueTableInRebalance</code>对比消息队列是否发生变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">updateProcessQueueTableInRebalance</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> Set&lt;MessageQueue&gt; mqSet, <span class="keyword">final</span> <span class="keyword">boolean</span> isOrder)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">       Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = <span class="keyword">this</span>.processQueueTable.entrySet().iterator();</span><br><span class="line">       <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">           Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();</span><br><span class="line">           MessageQueue mq = next.getKey();</span><br><span class="line">           ProcessQueue pq = next.getValue();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (mq.getTopic().equals(topic)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!mqSet.contains(mq)) &#123;</span><br><span class="line">                   pq.setDropped(<span class="keyword">true</span>);</span><br><span class="line">                   <span class="keyword">if</span> (<span class="keyword">this</span>.removeUnnecessaryMessageQueue(mq, pq)) &#123;</span><br><span class="line">                       it.remove();</span><br><span class="line">                       changed = <span class="keyword">true</span>;</span><br><span class="line">                       log.info(<span class="string">"doRebalance, &#123;&#125;, remove unnecessary mq, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pq.isPullExpired()) &#123;</span><br><span class="line">                   <span class="keyword">switch</span> (<span class="keyword">this</span>.consumeType()) &#123;</span><br><span class="line">                       <span class="keyword">case</span> CONSUME_ACTIVELY:</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       <span class="keyword">case</span> CONSUME_PASSIVELY:</span><br><span class="line">                           pq.setDropped(<span class="keyword">true</span>);</span><br><span class="line">                           <span class="keyword">if</span> (<span class="keyword">this</span>.removeUnnecessaryMessageQueue(mq, pq)) &#123;</span><br><span class="line">                               it.remove();</span><br><span class="line">                               changed = <span class="keyword">true</span>;</span><br><span class="line">                               log.error(<span class="string">"[BUG]doRebalance, &#123;&#125;, remove unnecessary mq, &#123;&#125;, because pull is pause, so try to fixed it"</span>,</span><br><span class="line">                                   consumerGroup, mq);</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       <span class="keyword">default</span>:</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       List&lt;PullRequest&gt; pullRequestList = <span class="keyword">new</span> ArrayList&lt;PullRequest&gt;();</span><br><span class="line">       <span class="keyword">for</span> (MessageQueue mq : mqSet) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!<span class="keyword">this</span>.processQueueTable.containsKey(mq)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (isOrder &amp;&amp; !<span class="keyword">this</span>.lock(mq)) &#123;</span><br><span class="line">                   log.warn(<span class="string">"doRebalance, &#123;&#125;, add a new mq failed, &#123;&#125;, because lock failed"</span>, consumerGroup, mq);</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">this</span>.removeDirtyOffset(mq);</span><br><span class="line">               ProcessQueue pq = <span class="keyword">new</span> ProcessQueue();</span><br><span class="line">               <span class="comment">//计算消息队列开始消费位置</span></span><br><span class="line">               <span class="keyword">long</span> nextOffset = <span class="keyword">this</span>.computePullFromWhere(mq);</span><br><span class="line">               <span class="keyword">if</span> (nextOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   ProcessQueue pre = <span class="keyword">this</span>.processQueueTable.putIfAbsent(mq, pq);</span><br><span class="line">                   <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       log.info(<span class="string">"doRebalance, &#123;&#125;, mq already exists, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       log.info(<span class="string">"doRebalance, &#123;&#125;, add a new mq, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">                       PullRequest pullRequest = <span class="keyword">new</span> PullRequest();</span><br><span class="line">                       pullRequest.setConsumerGroup(consumerGroup);</span><br><span class="line">                       pullRequest.setNextOffset(nextOffset);</span><br><span class="line">                       pullRequest.setMessageQueue(mq);</span><br><span class="line">                       pullRequest.setProcessQueue(pq);</span><br><span class="line">                       pullRequestList.add(pullRequest);</span><br><span class="line">                       changed = <span class="keyword">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   log.warn(<span class="string">"doRebalance, &#123;&#125;, add new mq failed, &#123;&#125;"</span>, consumerGroup, mq);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//马上执行拉请求</span></span><br><span class="line">       <span class="keyword">this</span>.dispatchPullRequest(pullRequestList);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> changed;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeDirtyOffset</span><span class="params">(<span class="keyword">final</span> MessageQueue mq)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从上面看，<strong>processQueueTable</strong>记录的是当前消费者负载的消息队列缓存表，该方法里面的<strong>mqSet</strong>记录的的是当前消费者经过负载分配后的消息队列集合。如果<strong>processQueueTable</strong>中的消息队列在<strong>mqSet</strong>中不存在，说明该消息队列已经被分配给其他消费者，所以需要暂停该消息队列消息的消费，通过** pq.setDropped(true);<strong>该语句即可。<br>然后通过</strong>removeUnnecessaryMessageQueue**方法判断是否该mq从缓存中移除。</p><p>之后，开始遍历本次负载分配给该消费者的消息队列结合mqSet。如果processQueueTable中没有包含该消息队列，表示这是本次新增加的消息队列。<br>首先从内存中移除该消息队列的消息进度，然后调用<strong>computePullFromWhere</strong>从磁盘中读取该消息队列的消费进度，创建一个PullRequest对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">computePullFromWhere</span><span class="params">(MessageQueue mq)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> result = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> ConsumeFromWhere consumeFromWhere = <span class="keyword">this</span>.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeFromWhere();</span><br><span class="line">        <span class="keyword">final</span> OffsetStore offsetStore = <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore();</span><br><span class="line">        <span class="keyword">switch</span> (consumeFromWhere) &#123;</span><br><span class="line">            <span class="keyword">case</span> CONSUME_FROM_LAST_OFFSET_AND_FROM_MIN_WHEN_BOOT_FIRST:</span><br><span class="line">            <span class="keyword">case</span> CONSUME_FROM_MIN_OFFSET:</span><br><span class="line">            <span class="keyword">case</span> CONSUME_FROM_MAX_OFFSET:</span><br><span class="line">            <span class="keyword">case</span> CONSUME_FROM_LAST_OFFSET: &#123;</span><br><span class="line">                <span class="keyword">long</span> lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);</span><br><span class="line">                <span class="keyword">if</span> (lastOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    result = lastOffset;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// First start,no offset</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> == lastOffset) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                        result = <span class="number">0L</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            result = <span class="keyword">this</span>.mQClientFactory.getMQAdminImpl().maxOffset(mq);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">                            result = -<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CONSUME_FROM_FIRST_OFFSET: &#123;</span><br><span class="line">                <span class="keyword">long</span> lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);</span><br><span class="line">                <span class="keyword">if</span> (lastOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    result = lastOffset;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> == lastOffset) &#123;</span><br><span class="line">                    result = <span class="number">0L</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> CONSUME_FROM_TIMESTAMP: &#123;</span><br><span class="line">                <span class="keyword">long</span> lastOffset = offsetStore.readOffset(mq, ReadOffsetType.READ_FROM_STORE);</span><br><span class="line">                <span class="keyword">if</span> (lastOffset &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    result = lastOffset;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (-<span class="number">1</span> == lastOffset) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mq.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            result = <span class="keyword">this</span>.mQClientFactory.getMQAdminImpl().maxOffset(mq);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">                            result = -<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">long</span> timestamp = UtilAll.parseDate(<span class="keyword">this</span>.defaultMQPushConsumerImpl.getDefaultMQPushConsumer().getConsumeTimestamp(),</span><br><span class="line">                                UtilAll.YYYYMMDDHHMMSS).getTime();</span><br><span class="line">                            result = <span class="keyword">this</span>.mQClientFactory.getMQAdminImpl().searchOffset(mq, timestamp);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">                            result = -<span class="number">1</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面看出，主要有三种计算消息进度的方法，有些大同小异。</p><ul><li><p>CONSUME_FROM_LAST_OFFSET:从队列最新偏移量开始消费<br>首先从磁盘中获取该消息队列的消费进度，如果大于0，说明该消息队列已经被消费过了，下次消费从该位置继续消费。如果等于-1，说明是首次消费，则从该消息队列的最大偏移量开始消费，如果小于-1，则说明该消息进度文件中存储了错误的偏移量，返回-1。</p></li><li><p>CONSUME_FROM_FIRST_OFFSET： 从头开始消费<br>首先从磁盘中获取该消息队列的消费进度，如果大于0，说明该消息队列已经被消费过了，下次消费从该位置继续消费。如果等于-1，说明是首次消费，则返回0，从头开始消费，如果小于-1，则说明该消息进度文件中存储了错误的偏移量，返回-1。</p></li><li><p>CONSUME_FROM_TIMESTAMP: 从消费者启动的时间戳对应的消费进度开始消费</p></li></ul><p>首先从磁盘中获取该消息队列的消费进度，如果大于0，说明该消息队列已经被消费过了，下次消费从该位置继续消费。如果等于-1，尝试去操作消息存储时间戳作为消费者启动的时间戳，如果能找到则返回找到的偏移量，找不到则返回0；如果小于-1，则说明该消息进度文件中存储了错误的偏移量，返回-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.dispatchPullRequest(pullRequestList);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchPullRequest</span><span class="params">(List&lt;PullRequest&gt; pullRequestList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (PullRequest pullRequest : pullRequestList) &#123;</span><br><span class="line">            <span class="comment">//马上执行拉请求</span></span><br><span class="line">            <span class="keyword">this</span>.defaultMQPushConsumerImpl.executePullRequestImmediately(pullRequest);</span><br><span class="line">            log.info(<span class="string">"doRebalance, &#123;&#125;, add a new pull request &#123;&#125;"</span>, consumerGroup, pullRequest);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在该方法的最后，会调用<strong>dispatchPullRequest</strong>方法，将PullRequest加入到PullMessageService中，以唤醒PullMessageService线程，进行消息拉取。</p><p>到这里，消费者负载均衡方面就结束了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先从整体流程上简单梳理一下消息队列负载的过程。&lt;/p&gt;
&lt;p&gt;消息队列负载由Rebalance线程默认每隔20s进行一次消息队列负载，获取主题队列信息mqSet与消费组当前所有消费者cidAll,然后按照某一种负载算法进行队列分配，分配原则为同一个消费者可以分配多个消息消息
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ并发消费</title>
    <link href="https://github.com/spurstong/2019/11/28/RocketMQ%E5%B9%B6%E5%8F%91%E6%B6%88%E8%B4%B9/"/>
    <id>https://github.com/spurstong/2019/11/28/RocketMQ并发消费/</id>
    <published>2019-11-28T11:43:03.299Z</published>
    <updated>2019-12-04T10:10:40.085Z</updated>
    
    <content type="html"><![CDATA[<p>拉取完消息后，将消息存放在ProcessQueue消息处理队列中，然后进行消息消费。</p><p>RocketMQ使用ConsumeMessageServie来实现消息消费，支持顺序消费和并发消费。在这里主要讲一下并发消费的流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeMessageConcurrentlyService</span> <span class="keyword">implements</span> <span class="title">ConsumeMessageService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = ClientLogger.getLog();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultMQPushConsumerImpl defaultMQPushConsumerImpl;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultMQPushConsumer defaultMQPushConsumer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageListenerConcurrently messageListener;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; consumeRequestQueue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadPoolExecutor consumeExecutor;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String consumerGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService scheduledExecutorService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService cleanExpireMsgExecutors;</span><br></pre></td></tr></table></figure><h1 id="启动位置"><a href="#启动位置" class="headerlink" title="启动位置"></a>启动位置</h1><p>从服务器拉取到消息后回调PullCallBack回调方法后，先将消息放入到ProcessQueue中，然后把消息提交到消息线程池中执行，则会调用ConsumeMessageConcurrentlyService.submitConsumeRequest方法开始消息消费</p><p>msgs: 消息列表<br>processQueue: 消息处理队列<br>messageQueue: 消息所属消费<br>dispatchToconsume: 是否转发到消费线程池，并发消费时忽略该参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitConsumeRequest</span><span class="params">(//</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> List&lt;MessageExt&gt; msgs, //</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ProcessQueue processQueue, //</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> MessageQueue messageQueue, //</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">boolean</span> dispatchToConsume)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> consumeBatchSize = <span class="keyword">this</span>.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();</span><br><span class="line">        <span class="comment">//类似分页，一页consumeBatchSize，如果大于一页就一页一页取。</span></span><br><span class="line">        <span class="keyword">if</span> (msgs.size() &lt;= consumeBatchSize) &#123;</span><br><span class="line">            ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgs, processQueue, messageQueue);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> total = <span class="number">0</span>; total &lt; msgs.size(); ) &#123;</span><br><span class="line">                List&lt;MessageExt&gt; msgThis = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeBatchSize);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumeBatchSize; i++, total++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (total &lt; msgs.size()) &#123;</span><br><span class="line">                        msgThis.add(msgs.get(total));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ConsumeRequest consumeRequest = <span class="keyword">new</span> ConsumeRequest(msgThis, processQueue, messageQueue);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.consumeExecutor.submit(consumeRequest);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RejectedExecutionException e) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (; total &lt; msgs.size(); total++) &#123;</span><br><span class="line">                        msgThis.add(msgs.get(total));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">this</span>.submitConsumeRequestLater(consumeRequest);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>首先获取系统设置的consumeMessageBatchMaxSize,即一次消息消费任务ConsumeRequest中包含的消息条数，默认为1，msgs默认最多为32，当msgs数量超过consumeMessageMaxSize时，采取分页处理。然后将consumeRequest提交到线程池。consumeRequest的run方法开始执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumeRequest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> List&lt;MessageExt&gt; msgs;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ProcessQueue processQueue;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> MessageQueue messageQueue;</span><br></pre></td></tr></table></figure><p>下面对run方法进行拆分，分批次进行介绍。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.processQueue.isDropped()) &#123;</span><br><span class="line">                log.info(<span class="string">"the message queue not be able to consume, because it's dropped. group=&#123;&#125; &#123;&#125;"</span>, ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup, <span class="keyword">this</span>.messageQueue);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>首先判断该processQueue的drop是否为true,如果drop为true,则说明该消息队列已经被分配给消费组里的其他消费者了，则要停止对该消息队列的消费。</p><p>如果有消费钩子函数的话，要执行钩子函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> beginTimestamp = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">boolean</span> hasException = <span class="keyword">false</span>;</span><br><span class="line">            ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.resetRetryTopic(msgs);</span><br><span class="line">                <span class="keyword">if</span> (msgs != <span class="keyword">null</span> &amp;&amp; !msgs.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">                    MessageAccessor.setConsumeStartTimeStamp(msg, String.valueOf(System.currentTimeMillis()));</span><br><span class="line">                &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开始调用自己些的消费监听进行消费</span></span><br><span class="line">status = listener.consumeMessage(Collections.unmodifiableList(msgs), context);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resetRetryTopic</span><span class="params">(<span class="keyword">final</span> List&lt;MessageExt&gt; msgs)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> String groupTopic = MixAll.getRetryTopic(consumerGroup);</span><br><span class="line">       <span class="keyword">for</span> (MessageExt msg : msgs) &#123;</span><br><span class="line">           String retryTopic = msg.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span><br><span class="line">           <span class="keyword">if</span> (retryTopic != <span class="keyword">null</span> &amp;&amp; groupTopic.equals(msg.getTopic())) &#123;</span><br><span class="line">               msg.setTopic(retryTopic);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>通过调用<strong>resetRetryTopic</strong>来恢复重试消息主题名。<br>RocketMQ将消息存入到commitlog文件时，如果发现消息的延迟级别delayTimeLevel大于0，会首先将重试主题存入在消息的属性中，然后设置主题名称为SCHEDULE_TOPIC，以便时间到后重新参与消息消费。</p><p>然后执行具体的消息消费，调用应用程序消息监听器的consumeMessage方法,返回消费结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == status) &#123;</span><br><span class="line">               log.warn(<span class="string">"consumeMessage return null, Group: &#123;&#125; Msgs: &#123;&#125; MQ: &#123;&#125;"</span>,</span><br><span class="line">                   ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.consumerGroup,</span><br><span class="line">                   msgs,</span><br><span class="line">                   messageQueue);</span><br><span class="line">               status = ConsumeConcurrentlyStatus.RECONSUME_LATER;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>返回的结果可能是CONSUME_SUCCESS(消费成功)或RECONSUME_LATER（需要重新消费）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!processQueue.isDropped()) &#123;</span><br><span class="line">                ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.processConsumeResult(status, context, <span class="keyword">this</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">"processQueue is dropped without process consume result. messageQueue=&#123;&#125;, msgs=&#123;&#125;"</span>, messageQueue, msgs);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>执行完消费后，需要对该ProcessQueue进行验证，如果drop为true,将不对结果进行处理。否则，调用<strong>processConsumeResult</strong>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ackIndex = context.getAckIndex();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (consumeRequest.getMsgs().isEmpty())</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (status) &#123;</span><br><span class="line">         <span class="keyword">case</span> CONSUME_SUCCESS:</span><br><span class="line">             <span class="keyword">if</span> (ackIndex &gt;= consumeRequest.getMsgs().size()) &#123;</span><br><span class="line">                 ackIndex = consumeRequest.getMsgs().size() - <span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">int</span> ok = ackIndex + <span class="number">1</span>;</span><br><span class="line">             <span class="keyword">int</span> failed = consumeRequest.getMsgs().size() - ok;</span><br><span class="line">             <span class="keyword">this</span>.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), ok);</span><br><span class="line">             <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), failed);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> RECONSUME_LATER:</span><br><span class="line">             <span class="comment">//需要稍微重试的</span></span><br><span class="line">             ackIndex = -<span class="number">1</span>;</span><br><span class="line">             <span class="keyword">this</span>.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(),</span><br><span class="line">                 consumeRequest.getMsgs().size());</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>:</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>当消费结果是成功时，计算成功的个数和失败的个数。，更新ackInex。<br>当消费结果是失败时，将ackIndex重置为-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">            <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                    MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                    log.warn(<span class="string">"BROADCASTING, the message consume failed, drop it, &#123;&#125;"</span>, msg.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">                List&lt;MessageExt&gt; msgBackFailed = <span class="keyword">new</span> ArrayList&lt;MessageExt&gt;(consumeRequest.getMsgs().size());</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = ackIndex + <span class="number">1</span>; i &lt; consumeRequest.getMsgs().size(); i++) &#123;</span><br><span class="line">                    MessageExt msg = consumeRequest.getMsgs().get(i);</span><br><span class="line">                    <span class="keyword">boolean</span> result = <span class="keyword">this</span>.sendMessageBack(msg, context);</span><br><span class="line">                    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                        msg.setReconsumeTimes(msg.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line">                        msgBackFailed.add(msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!msgBackFailed.isEmpty()) &#123;</span><br><span class="line">                    consumeRequest.getMsgs().removeAll(msgBackFailed);</span><br><span class="line">                    <span class="comment">//请求重试消费</span></span><br><span class="line">                    <span class="keyword">this</span>.submitConsumeRequestLater(msgBackFailed, consumeRequest.getProcessQueue(), consumeRequest.getMessageQueue());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ul><li>如果是广播模式，消息不会执行任何操作，只是以警告级别输出到日志文件。</li><li>如果是集群模式，对发送失败的消息执行操作。<br>执行<strong>sendMessageBack</strong>操作。<br>然后更新该消息重新消费的次数，并将要重新消费的消息添加到msgBackFailed集合中。<br>并将需要重新消费的消息从原先的消息集合中移除，然后执行<strong>submitConsumeRequestLater</strong>方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">submitConsumeRequestLater</span><span class="params">(//</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> List&lt;MessageExt&gt; msgs, //</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> ProcessQueue processQueue, //</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> MessageQueue messageQueue//</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.scheduledExecutorService.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              ConsumeMessageConcurrentlyService.<span class="keyword">this</span>.submitConsumeRequest(msgs, processQueue, messageQueue, <span class="keyword">true</span>);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="number">5000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出，它会在5s后重新执行开头介绍的<strong>submitConsumeRequest</strong>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会操作msgTreeMap，如果重试的情况在上面consumeRequest.getMsgs()已经被清空了</span></span><br><span class="line">        <span class="keyword">long</span> offset = consumeRequest.getProcessQueue().removeMessage(consumeRequest.getMsgs());</span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= <span class="number">0</span> &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), offset, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从ProcessQueue中移除消费成功的消息集合，返回的偏移量是移除该批消息后最小的偏移量，然后用该偏移量更新消息消费进度，以便在消费者重启后能从上一次的消费进度开始消费，避免消息重复消费。</p><p>下面开始介绍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageBack</span><span class="params">(<span class="keyword">final</span> MessageExt msg, <span class="keyword">final</span> ConsumeConcurrentlyContext context)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> delayLevel = context.getDelayLevelWhenNextConsume();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.defaultMQPushConsumerImpl.sendMessageBack(msg, delayLevel, context.getMessageQueue().getBrokerName());</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           log.error(<span class="string">"sendMessageBack exception, group: "</span> + <span class="keyword">this</span>.consumerGroup + <span class="string">" msg: "</span> + msg.toString(), e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageBack</span><span class="params">(MessageExt msg, <span class="keyword">int</span> delayLevel, <span class="keyword">final</span> String brokerName)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException, MQClientException </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           String brokerAddr = (<span class="keyword">null</span> != brokerName) ? <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(brokerName)</span><br><span class="line">               : RemotingHelper.parseSocketAddressAddr(msg.getStoreHost());</span><br><span class="line">           <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().consumerSendMessageBack(brokerAddr, msg,</span><br><span class="line">               <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), delayLevel, <span class="number">5000</span>, getMaxReconsumeTimes());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           log.error(<span class="string">"sendMessageBack Exception, "</span> + <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), e);</span><br><span class="line"></span><br><span class="line">           Message newMsg = <span class="keyword">new</span> Message(MixAll.getRetryTopic(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());</span><br><span class="line"></span><br><span class="line">           String originMsgId = MessageAccessor.getOriginMessageId(msg);</span><br><span class="line">           MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);</span><br><span class="line"></span><br><span class="line">           newMsg.setFlag(msg.getFlag());</span><br><span class="line">           MessageAccessor.setProperties(newMsg, msg.getProperties());</span><br><span class="line">           MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());</span><br><span class="line">           MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes() + <span class="number">1</span>));</span><br><span class="line">           MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));</span><br><span class="line">           newMsg.setDelayTimeLevel(<span class="number">3</span> + msg.getReconsumeTimes());</span><br><span class="line"></span><br><span class="line">           <span class="keyword">this</span>.mQClientFactory.getDefaultMQProducer().send(newMsg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>MQClientAPIImpl类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumerSendMessageBack</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String addr,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> MessageExt msg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String consumerGroup,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">int</span> delayLevel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">long</span> timeoutMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">int</span> maxConsumeRetryTimes</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> <span class="keyword">throws</span> RemotingException, MQBrokerException, InterruptedException </span>&#123;</span><br><span class="line">        ConsumerSendMsgBackRequestHeader requestHeader = <span class="keyword">new</span> ConsumerSendMsgBackRequestHeader();</span><br><span class="line">        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CONSUMER_SEND_MSG_BACK, requestHeader);</span><br><span class="line"></span><br><span class="line">        requestHeader.setGroup(consumerGroup);</span><br><span class="line">        requestHeader.setOriginTopic(msg.getTopic());</span><br><span class="line">        requestHeader.setOffset(msg.getCommitLogOffset());</span><br><span class="line">        requestHeader.setDelayLevel(delayLevel);</span><br><span class="line">        requestHeader.setOriginMsgId(msg.getMsgId());</span><br><span class="line">        requestHeader.setMaxReconsumeTimes(maxConsumeRetryTimes);</span><br><span class="line"></span><br><span class="line">        RemotingCommand response = <span class="keyword">this</span>.remotingClient.invokeSync(MixAll.brokerVIPChannel(<span class="keyword">this</span>.clientConfig.isVipChannelEnabled(), addr),</span><br><span class="line">            request, timeoutMillis);</span><br><span class="line">        <span class="keyword">assert</span> response != <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (response.getCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> ResponseCode.SUCCESS: &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> MQBrokerException(response.getCode(), response.getRemark());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ACK消息发送的网络客户端入口：MQClientAPIImpl#consumerSendMessageBack,命令编码：RequestCode.CONSUMER_SEND_MSG_BACK</p><p>客户端以同步方式发送RequestCode.CONSUMER_SEND_MSG_BACK到服务端，服务端中的类SendMessageProcessor#consumerSendMsgBack会接收处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> RemotingCommand response = RemotingCommand.createResponseCommand(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">final</span> ConsumerSendMsgBackRequestHeader requestHeader =</span><br><span class="line">            (ConsumerSendMsgBackRequestHeader) request.decodeCommandCustomHeader(ConsumerSendMsgBackRequestHeader.class);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 消息轨迹：记录消费失败的消息</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.hasConsumeMessageHook() &amp;&amp; !UtilAll.isBlank(requestHeader.getOriginMsgId())) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行hook</span></span><br><span class="line">            ConsumeMessageContext context = <span class="keyword">new</span> ConsumeMessageContext();</span><br><span class="line">            context.setConsumerGroup(requestHeader.getGroup());</span><br><span class="line">            context.setTopic(requestHeader.getOriginTopic());</span><br><span class="line">            context.setCommercialRcvStats(BrokerStatsManager.StatsType.SEND_BACK);</span><br><span class="line">            context.setCommercialRcvTimes(<span class="number">1</span>);</span><br><span class="line">            context.setCommercialOwner(request.getExtFields().get(BrokerStatsManager.COMMERCIAL_OWNER));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.executeConsumeMessageHookAfter(context);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 确保订阅组存在</span></span><br><span class="line">        SubscriptionGroupConfig subscriptionGroupConfig =</span><br><span class="line">            <span class="keyword">this</span>.brokerController.getSubscriptionGroupManager().findSubscriptionGroupConfig(requestHeader.getGroup());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == subscriptionGroupConfig) &#123;</span><br><span class="line">            response.setCode(ResponseCode.SUBSCRIPTION_GROUP_NOT_EXIST);</span><br><span class="line">            response.setRemark(<span class="string">"subscription group not exist, "</span> + requestHeader.getGroup() + <span class="string">" "</span></span><br><span class="line">                + FAQUrl.suggestTodo(FAQUrl.SUBSCRIPTION_GROUP_NOT_EXIST));</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 检查Broker权限</span></span><br><span class="line">        <span class="keyword">if</span> (!PermName.isWriteable(<span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerPermission())) &#123;</span><br><span class="line">            response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">            response.setRemark(<span class="string">"the broker["</span> + <span class="keyword">this</span>.brokerController.getBrokerConfig().getBrokerIP1() + <span class="string">"] sending message is forbidden"</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果重试队列数目为0，则直接丢弃消息</span></span><br><span class="line">        <span class="keyword">if</span> (subscriptionGroupConfig.getRetryQueueNums() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            response.setCode(ResponseCode.SUCCESS);</span><br><span class="line">            response.setRemark(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>获取消费组的订阅配置消息，如果配置消息未空返回配置组消息不存在错误。如果重试队列数量小于1，则直接返回成功，说明该消费组不支持重试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String newTopic = MixAll.getRetryTopic(requestHeader.getGroup());</span><br><span class="line"><span class="keyword">int</span> queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % subscriptionGroupConfig.getRetryQueueNums();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是单元化模式，则对 topic 进行设置</span></span><br><span class="line">        <span class="keyword">int</span> topicSysFlag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (requestHeader.isUnitMode()) &#123;</span><br><span class="line">            topicSysFlag = TopicSysFlag.buildSysFlag(<span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查topic是否存在</span></span><br><span class="line">        TopicConfig topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(<span class="comment">//</span></span><br><span class="line">            newTopic, <span class="comment">//</span></span><br><span class="line">            subscriptionGroupConfig.getRetryQueueNums(), <span class="comment">//</span></span><br><span class="line">            PermName.PERM_WRITE | PermName.PERM_READ, topicSysFlag);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">            response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">            response.setRemark(<span class="string">"topic["</span> + newTopic + <span class="string">"] not exist"</span>);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 检查topic权限</span></span><br><span class="line">        <span class="keyword">if</span> (!PermName.isWriteable(topicConfig.getPerm())) &#123;</span><br><span class="line">            response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">            response.setRemark(String.format(<span class="string">"the topic[%s] sending message is forbidden"</span>, newTopic));</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>当消息需要重新消费时，不会使用原先的消息队列结合，而是重新创建一个重试主题，名称为%RETRY%+消费组名称，并从重试队列中随机选择一个队列，并构建TopicConig主题配置消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询消息，这里如果堆积消息过多，会访问磁盘</span></span><br><span class="line">        <span class="comment">// 另外如果频繁调用，是否会引起gc问题，需要关注 TODO</span></span><br><span class="line">        MessageExt msgExt = <span class="keyword">this</span>.brokerController.getMessageStore().lookMessageByOffset(requestHeader.getOffset());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == msgExt) &#123;</span><br><span class="line">            response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">            response.setRemark(<span class="string">"look message by offset failed, "</span> + requestHeader.getOffset());</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 构造消息</span></span><br><span class="line">        <span class="keyword">final</span> String retryTopic = msgExt.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == retryTopic) &#123;</span><br><span class="line">            MessageAccessor.putProperty(msgExt, MessageConst.PROPERTY_RETRY_TOPIC, msgExt.getTopic());</span><br><span class="line">        &#125;</span><br><span class="line">        msgExt.setWaitStoreMsgOK(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>根据消息物理偏移量从commitlog文件中获取消息，同时将消息的主题存放到属性中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> delayLevel = requestHeader.getDelayLevel();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> maxReconsumeTimes = subscriptionGroupConfig.getRetryMaxTimes();</span><br><span class="line">       <span class="keyword">if</span> (request.getVersion() &gt;= MQVersion.Version.V3_4_9.ordinal()) &#123;</span><br><span class="line">           maxReconsumeTimes = requestHeader.getMaxReconsumeTimes();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 死信消息处理</span></span><br><span class="line">       <span class="keyword">if</span> (msgExt.getReconsumeTimes() &gt;= maxReconsumeTimes<span class="comment">//</span></span><br><span class="line">           || delayLevel &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           newTopic = MixAll.getDLQTopic(requestHeader.getGroup());</span><br><span class="line">           queueIdInt = Math.abs(<span class="keyword">this</span>.random.nextInt() % <span class="number">99999999</span>) % DLQ_NUMS_PER_GROUP;</span><br><span class="line"></span><br><span class="line">           topicConfig = <span class="keyword">this</span>.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(newTopic, <span class="comment">//</span></span><br><span class="line">               DLQ_NUMS_PER_GROUP, <span class="comment">//</span></span><br><span class="line">               PermName.PERM_WRITE, <span class="number">0</span> <span class="comment">// 死信消息不需要同步，不需要较正。</span></span><br><span class="line">           );</span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> == topicConfig) &#123;</span><br><span class="line">               response.setCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">               response.setRemark(<span class="string">"topic["</span> + newTopic + <span class="string">"] not exist"</span>);</span><br><span class="line">               <span class="keyword">return</span> response;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>设置消息重试次数，如果消息已重试次数超过maxReconsumeTimes，再次改变newTopic主题为DLQ(%DLQ%)(死信队列)，该主题的权限为只写，说明消息一旦进入了DLQ，该主题的权限为只写，说明消息一旦进入到DLQ队列中，RocketMQ将不负责再次调度进行消费了，需要人工干预。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">MessageExtBrokerInner msgInner = <span class="keyword">new</span> MessageExtBrokerInner();</span><br><span class="line">        msgInner.setTopic(newTopic);</span><br><span class="line">        msgInner.setBody(msgExt.getBody());</span><br><span class="line">        msgInner.setFlag(msgExt.getFlag());</span><br><span class="line">        MessageAccessor.setProperties(msgInner, msgExt.getProperties());</span><br><span class="line">        msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgExt.getProperties()));</span><br><span class="line">        msgInner.setTagsCode(MessageExtBrokerInner.tagsString2tagsCode(<span class="keyword">null</span>, msgExt.getTags()));</span><br><span class="line"></span><br><span class="line">        msgInner.setQueueId(queueIdInt);</span><br><span class="line">        msgInner.setSysFlag(msgExt.getSysFlag());</span><br><span class="line">        msgInner.setBornTimestamp(msgExt.getBornTimestamp());</span><br><span class="line">        msgInner.setBornHost(msgExt.getBornHost());</span><br><span class="line">        msgInner.setStoreHost(<span class="keyword">this</span>.getStoreHost());</span><br><span class="line">        msgInner.setReconsumeTimes(msgExt.getReconsumeTimes() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 保存源生消息的 msgId</span></span><br><span class="line">        String originMsgId = MessageAccessor.getOriginMessageId(msgExt);</span><br><span class="line">        MessageAccessor.setOriginMessageId(msgInner, UtilAll.isBlank(originMsgId) ? msgExt.getMsgId() : originMsgId);</span><br></pre></td></tr></table></figure><p>根据原先的消息创建一个新的消息对象，重试消息会拥有自己的唯一消息ID并存入到commitlog文件中，并不会去更新原先消息，而是会将原来的主题、消息ID存入消息的属性中，主题名称为重试主题，其他属性与原来消息保持一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PutMessageResult putMessageResult = <span class="keyword">this</span>.brokerController.getMessageStore().putMessage(msgInner);</span><br></pre></td></tr></table></figure><p>将消息存放到Commitlog文件中。</p><p>在存入Commitlog文件之前，如果消息的延迟级别delayTimeLevel大于0，替换消息的主题与队列为定时任务主题队列“SCHEDULE_TOPIC_XXXX”,队列ID为延迟级别减1，再次将消息主题、队列存入消息的属性中。</p><p>在Broker端存在一个后台服务线程<strong>ScheduleMessageService</strong>,其中有一个DeliverDelayedMessageTimeTask定时任务线程，它会根据Topic(“SCHEDULE_TOPIC_XXXX”)与QueueId,先查找逻辑消费队列ConsumeQueue,然后根据偏移量，找到ConsumeQueue中的内存映射对象，从commitlog日志中找到消息对象MessageExt,并做一个消息体的转换，由定时延迟队列消息转化Wie重试队列的消息，再次做持久化磁盘，这是才会真正的保存至重试队列中。定时延迟队列只是为了用于暂存的，然后延迟一段时间后再将消息移入到重试队列中。</p><p>RocketMQ会保证消息至少会被消费1次，但是可能会出现消息重复消费问题，需要开发者自己设计解决这一问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;拉取完消息后，将消息存放在ProcessQueue消息处理队列中，然后进行消息消费。&lt;/p&gt;
&lt;p&gt;RocketMQ使用ConsumeMessageServie来实现消息消费，支持顺序消费和并发消费。在这里主要讲一下并发消费的流程。&lt;/p&gt;
&lt;figure class=&quot;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ消息消费之长轮询</title>
    <link href="https://github.com/spurstong/2019/11/26/RocketMQ%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E4%B9%8B%E9%95%BF%E8%BD%AE%E8%AF%A2/"/>
    <id>https://github.com/spurstong/2019/11/26/RocketMQ消息消费之长轮询/</id>
    <published>2019-11-26T14:15:06.159Z</published>
    <updated>2019-11-27T10:24:22.382Z</updated>
    
    <content type="html"><![CDATA[<p>  RocketMQ消费端有两种获取消息的方式，Push方式和Pull方式。但这两种方式都有一定的缺陷，后来采用了一种折中的方法，采用”长轮询“的方式，它既可以拥有Pull的优点，又能达到保证实时性的目的。</p><p>长轮询的思想：<br>服务端接收到新消息请求后，如果队列里没有新消息，并不急于返回，通过一个循环不断查看状态，每次waitForRunning一段时间（默认是5秒），然后再Check。Broker默认最长阻塞时间为15秒，默认情况下当Broker一直没有新消息，第三次Check的时候，等待时间超过最长阻塞时间，就返回空结果。在等待的过程中，Broker收到了新的消息后会直接返回请求结果。<br>“长轮询”的核心是，Broker端hold住客户端过来的请求一小段时间。在这段时间内有新的消息到达，就利用现有的连接立即返回消息给Consumer。</p><p>何时调用？</p><p>当未在Broker中查找到新信息时，状态代码为PULL_NOT_FOUND,会创建拉取任务PullRequest并提交到PullRequestHoldService线程中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ConcurrentMap&lt;String<span class="comment">/* topic@queueId */</span>, ManyPullRequest&gt; pullRequestTable =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;String, ManyPullRequest&gt;(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>该类中有一个重要的参数<code>pullRequestTable</code>,key为“主题@队列号”，value是对应的ManyPullRequest。</p><p>先看一下它的run方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       log.info(<span class="string">"&#123;&#125; service started"</span>, <span class="keyword">this</span>.getServiceName());</span><br><span class="line">       <span class="keyword">while</span> (!<span class="keyword">this</span>.isStopped()) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">//Consumer订阅消息时，Broker是否开启长轮询</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.brokerController.getBrokerConfig().isLongPollingEnable()) &#123;                <span class="comment">//开启长轮询，每5秒尝试一次</span></span><br><span class="line">                   <span class="keyword">this</span>.waitForRunning(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//没有开启长轮询，默认等待1秒再次尝试                this.waitForRunning(this.brokerController.getBrokerConfig().getShortPollingTimeMills());</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">long</span> beginLockTimestamp = <span class="keyword">this</span>.systemClock.now();</span><br><span class="line">               <span class="keyword">this</span>.checkHoldRequest();</span><br><span class="line">               <span class="keyword">long</span> costTime = <span class="keyword">this</span>.systemClock.now() - beginLockTimestamp;</span><br><span class="line">               <span class="keyword">if</span> (costTime &gt; <span class="number">5</span> * <span class="number">1000</span>) &#123;</span><br><span class="line">                   log.info(<span class="string">"[NOTIFYME] check hold request cost &#123;&#125; ms."</span>, costTime);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">               log.warn(<span class="keyword">this</span>.getServiceName() + <span class="string">" service has exception. "</span>, e);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       log.info(<span class="string">"&#123;&#125; service end"</span>, <span class="keyword">this</span>.getServiceName());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出，如果开启了长轮询，每5s尝试一次，利用checkHoldRequest方法来判断是否有新消息的产生。如果未开启长轮询，则默认1s再次尝试。</p><p>然后再阅读一下checkHoldRequest方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkHoldRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String key : <span class="keyword">this</span>.pullRequestTable.keySet()) &#123;</span><br><span class="line">            String[] kArray = key.split(TOPIC_QUEUEID_SEPARATOR);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> == kArray.length) &#123;</span><br><span class="line">                String topic = kArray[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> queueId = Integer.parseInt(kArray[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> offset = <span class="keyword">this</span>.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.notifyMessageArriving(topic, queueId, offset);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                    log.error(<span class="string">"check hold request failed. topic=&#123;&#125;, queueId=&#123;&#125;"</span>, topic, queueId, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出，它会遍历pullRequestTable，从key名中可以得到主题名topic和队列名queueId,然后通过topic和queueID获取到该消息队列的最大偏移量，之后调用notifyMessageArriving方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyMessageArriving</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">int</span> queueId, <span class="keyword">final</span> <span class="keyword">long</span> maxOffset, <span class="keyword">final</span> Long tagsCode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">long</span> msgStoreTime, <span class="keyword">byte</span>[] filterBitMap, Map&lt;String, String&gt; properties)</span> </span>&#123;</span><br><span class="line">       String key = <span class="keyword">this</span>.buildKey(topic, queueId);</span><br><span class="line">       ManyPullRequest mpr = <span class="keyword">this</span>.pullRequestTable.get(key);</span><br><span class="line">       <span class="keyword">if</span> (mpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">           List&lt;PullRequest&gt; requestList = mpr.cloneListAndClear();</span><br><span class="line">           <span class="keyword">if</span> (requestList != <span class="keyword">null</span>) &#123;</span><br><span class="line">               List&lt;PullRequest&gt; replayList = <span class="keyword">new</span> ArrayList&lt;PullRequest&gt;();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">for</span> (PullRequest request : requestList) &#123;</span><br><span class="line">                   <span class="keyword">long</span> newestOffset = maxOffset;</span><br><span class="line">                   <span class="keyword">if</span> (newestOffset &lt;= request.getPullFromThisOffset()) &#123;</span><br><span class="line">                       newestOffset = <span class="keyword">this</span>.brokerController.getMessageStore().getMaxOffsetInQueue(topic, queueId);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (newestOffset &gt; request.getPullFromThisOffset()) &#123;</span><br><span class="line">                       <span class="keyword">boolean</span> match = request.getMessageFilter().isMatchedByConsumeQueue(tagsCode,</span><br><span class="line">                           <span class="keyword">new</span> ConsumeQueueExt.CqExtUnit(tagsCode, msgStoreTime, filterBitMap));</span><br><span class="line">                       <span class="comment">// match by bit map, need eval again when properties is not null.</span></span><br><span class="line">                       <span class="keyword">if</span> (match &amp;&amp; properties != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           match = request.getMessageFilter().isMatchedByCommitLog(<span class="keyword">null</span>, properties);</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">if</span> (match) &#123;</span><br><span class="line">                           <span class="keyword">try</span> &#123;</span><br><span class="line">                               <span class="keyword">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">                                   request.getRequestCommand());</span><br><span class="line">                           &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                               log.error(<span class="string">"execute request when wakeup failed."</span>, e);</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">continue</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (System.currentTimeMillis() &gt;= (request.getSuspendTimestamp() + request.getTimeoutMillis())) &#123;</span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="keyword">this</span>.brokerController.getPullMessageProcessor().executeRequestWhenWakeup(request.getClientChannel(),</span><br><span class="line">                               request.getRequestCommand());</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                           log.error(<span class="string">"execute request when wakeup failed."</span>, e);</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">continue</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   replayList.add(request);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!replayList.isEmpty()) &#123;</span><br><span class="line">                   mpr.addPullRequest(replayList);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在<code>notifyMessageArriving</code>方法中，首先会获取到当前该主题、队列中的所有的挂起拉取任务，如果该消息队列的最大偏移量大于待拉取偏移量，说明有新的消息传入。如果消息匹配后，则调用executeRequestWhenWakeup将消息返回给消息拉取客户端，否则等待下一次尝试。<br>如果挂起超时时间超时，则不继续等待将直接返回客户消息未找到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;  RocketMQ消费端有两种获取消息的方式，Push方式和Pull方式。但这两种方式都有一定的缺陷，后来采用了一种折中的方法，采用”长轮询“的方式，它既可以拥有Pull的优点，又能达到保证实时性的目的。&lt;/p&gt;
&lt;p&gt;长轮询的思想：&lt;br&gt;服务端接收到新消息请求后，如果
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ阅读笔记之消息消费的消息拉取</title>
    <link href="https://github.com/spurstong/2019/11/17/RocketMQ%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/"/>
    <id>https://github.com/spurstong/2019/11/17/RocketMQ阅读笔记之消息消费/</id>
    <published>2019-11-17T11:03:07.977Z</published>
    <updated>2019-11-25T15:21:08.194Z</updated>
    
    <content type="html"><![CDATA[<p>消息消费，简而言之就是消费者从消息队列里读取数据。消费者有两种消费方式：</p><ol><li><p><strong>Push方式</strong>。消息服务器接收到信息后，主动把消息推送给消费者，实时性高。但是这样加大了消息服务器的工作压力，会影响其性能。除此之外，不同消费者的处理信息的能力不同，可能无法及时的消费消息，造成 <em>慢消费</em> 问题。相关类是<code>DefaultMQPushConsumer</code>。</p></li><li><p><strong>Pull方式</strong>。消费者主动向消息服务器拉取消息，主动权在消费者这里。主要的问题是循环拉取消息的间隔不好设定，设置的间隔时间太久会增加消息的延迟；设置的事件间隔太短，如果消费服务器里没有可用的消息，那么会造成很多无用的请求开销，影响其性能。相关类是<code>DefaultMQPullConsumer</code>。</p></li></ol><p>消息消费以组的模式开展，一个消费组里可以包含多个消费者，每一个消费组可以订阅多个主题，消费组之间有<em>集群模式</em>和<em>广播模式</em>两种消费模式。</p><ul><li>集群模式:<br>同一个ConsumerGroup里的每个Consumer只消费所订阅消息的一部分内容，同一个ConsumerGroup里的所有的Consumer消费的内容合起来才是订阅的Topic内容的整体，从而达到负载均衡的目的。</li><li>广播模式<br>同一个ConsumerGroup里的每个Consumer都能消费到所订阅Topic的全部信息，也就是一个消息会被多次分发，被多个Consumer消费。</li></ul><p>首先先将一下DefaultMQPushConsumer的相关操作。</p><h2 id="DefaultMQPushConsumer的启动"><a href="#DefaultMQPushConsumer的启动" class="headerlink" title="DefaultMQPushConsumer的启动"></a>DefaultMQPushConsumer的启动</h2><p>启动方法是在DefaultMQPushConsumerImpl.start()方法。</p><p>首先会根据服务状态选择策略。定义的状态如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ServiceState &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service just created,not start</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CREATE_JUST,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service Running</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNING,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service shutdown</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SHUTDOWN_ALREADY,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service Start failure</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    START_FAILED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br></pre></td></tr></table></figure><p>如果是<em>RUNNING<em>、</em>START_FAILED</em>,则跳过该环节，直接进行下一环节。如果是<em>SULTdOWN_ALREDAY</em>，则抛出异常。如果是<em>CREATE_JUST</em>，则需要进入执行该环节的代码。<br>进入里面的区域时，先预设serviceState的值为START_FAILE，在执行一段操作后，如果注册消费者没有成功，则修改serviceState为CREATE_JUST，并抛出异常；如果顺利执行则修改serviceState为RUNNING。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证配置</span></span><br><span class="line"><span class="keyword">this</span>.checkConfig();</span><br><span class="line"><span class="keyword">this</span>.copySubscription();</span><br></pre></td></tr></table></figure><p>订阅主题订阅消息SubscriptionData,并放入到RebalanceImpl的订阅消息中。订阅关系来源主要有两个。</p><ul><li>defaultMQPushConsumer.getSubscription()</li><li>订阅重试主题消息。RocketMQ消息重试是以消费组为单位，而不是主题，消息重试主题为%RETRY%+消费组名。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">copySubscription</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Map&lt;String, String&gt; sub = <span class="keyword">this</span>.defaultMQPushConsumer.getSubscription();</span><br><span class="line">           <span class="keyword">if</span> (sub != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;String, String&gt; entry : sub.entrySet()) &#123;</span><br><span class="line">                   <span class="keyword">final</span> String topic = entry.getKey();</span><br><span class="line">                   <span class="keyword">final</span> String subString = entry.getValue();</span><br><span class="line">                   SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="comment">//</span></span><br><span class="line">                       topic, subString);</span><br><span class="line">                   <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.messageListenerInner) &#123;</span><br><span class="line">               <span class="keyword">this</span>.messageListenerInner = <span class="keyword">this</span>.defaultMQPushConsumer.getMessageListener();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">               <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">                   <span class="keyword">final</span> String retryTopic = MixAll.getRetryTopic(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                   SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="comment">//</span></span><br><span class="line">                       retryTopic, SubscriptionData.SUB_ALL);</span><br><span class="line">                   <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().put(retryTopic, subscriptionData);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"subscription exception"</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul><p>如果当前是集群消费模式，修改实例名为Pid。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;</span><br><span class="line"><span class="keyword">this</span>.defaultMQPushConsumer.changeInstanceNameToPID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初始化MQClientInstance、ReblanceImple(消息重新负载实现类)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQPushConsumer, <span class="keyword">this</span>.rpcHook);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 设置负载均衡器</span></span><br><span class="line">               <span class="keyword">this</span>.rebalanceImpl.setConsumerGroup(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">               <span class="comment">//设置消费集群模式</span></span><br><span class="line">               <span class="keyword">this</span>.rebalanceImpl.setMessageModel(<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel());</span><br><span class="line">               <span class="comment">//Queue allocation algorithm specifying how message queues are allocated to each consumer clients.</span></span><br><span class="line">               <span class="keyword">this</span>.rebalanceImpl.setAllocateMessageQueueStrategy(<span class="keyword">this</span>.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span><br><span class="line">   </span><br><span class="line">               <span class="keyword">this</span>.rebalanceImpl.setmQClientFactory(<span class="keyword">this</span>.mQClientFactory);</span><br><span class="line">   </span><br><span class="line">               <span class="keyword">this</span>.pullAPIWrapper = <span class="keyword">new</span> PullAPIWrapper(</span><br><span class="line">                   mQClientFactory,</span><br><span class="line">                   <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span><br><span class="line">               <span class="keyword">this</span>.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span><br></pre></td></tr></table></figure><p>处理offset存储方式。<br>如果消息消费是集群模式，那么消息进度保存在Broker上；如果是广播模式，那么消息消费进度存储在消费端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.offsetStore = <span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore();</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">                      <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">                          <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> LocalFileOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">                          <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> RemoteBrokerOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">default</span>:</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">this</span>.offsetStore.load();</span><br></pre></td></tr></table></figure><p>根据MessageListener的具体实现方式选择具体的消息拉取线程实现<br>可以选择顺序消息消费服务或者并行消息消费服务<br>最后执行ConsumerMessageService主要负责消费消息，内部维护一个线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerOrderly) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.consumeOrderly = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                        <span class="keyword">new</span> ConsumeMessageOrderlyService(<span class="keyword">this</span>, (MessageListenerOrderly) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerConcurrently) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.consumeOrderly = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                        <span class="keyword">new</span> ConsumeMessageConcurrentlyService(<span class="keyword">this</span>, (MessageListenerConcurrently) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService.start();</span><br></pre></td></tr></table></figure><p>向MQClientInstance注册消费者，并启动MQClientInstance,在一个JVM中的所有消费者、生产者持有同一个MQClientInstance,MQClientInstance只会启动一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> registerOK = mQClientFactory.registerConsumer(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                    <span class="keyword">this</span>.consumeMessageService.shutdown();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The consumer group["</span> + <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()</span><br><span class="line">                        + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                        <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mQClientFactory.start();</span><br></pre></td></tr></table></figure><p>订阅关系改变，更新NameServer的订阅关系表。<br>检查客户端状态<br>发送心跳条<br>唤醒执行消费者负载均衡。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();</span><br><span class="line"><span class="keyword">this</span>.mQClientFactory.checkClientInBroker();</span><br><span class="line">       <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">       <span class="comment">//马上rebalance</span></span><br><span class="line"><span class="keyword">this</span>.mQClientFactory.rebalanceImmediately();</span><br></pre></td></tr></table></figure><p>在上面提到了offset的存储问题。现在先讲一下什么是offset和存储规则。</p><h1 id="消息消费进度记录"><a href="#消息消费进度记录" class="headerlink" title="消息消费进度记录"></a>消息消费进度记录</h1><p>消息消费者在消费一批消息后，需要记录该批消息已经消费完毕，否则当消费者重新启动时又得从消息消费队列的开始消费，这样显然会产生问题。一次消息消费后会从ProcessQueue处理队列中移除该批消息，返回ProcessQueue最小偏移量，并存入到消息进度表中。该消息进度表的存储位置和机制是一个重要的问题。</p><p>由上面可知,有两种消费模式，<em>广播模式</em>  和 <em>集群模式</em></p><p>广播模式： 同一消费组的所有消费者都会消费该主题下的所有消息。即同一个消息会被所有消费者消费，所以每个消费者应该各自独立有一个记录消费进度的文件。<br>广播模式下消息进度存储在消费者本地，主要类是LocalFileOffsetStore.</p><p>集群模式： 同一消费者的所有消费者共同消费该主题下的所有消息，一个消息只能被一个消费者所消费，即每个消费者消费的是该消费主题下的部分消息，所以消息消费进度记录被所有消费者所共享。<br>集群模式消息进度存储文件存放在消息服务端Broker,主要类中RemoteBrokerOffsetStore。</p><h1 id="几个重要有关消息消费的类"><a href="#几个重要有关消息消费的类" class="headerlink" title="几个重要有关消息消费的类"></a>几个重要有关消息消费的类</h1><p>每一个PullRequest代表一个消费的分组单元<br>PullRequest会记录一个topic记录对应的consumerGroup的拉取进度。</p><h2 id="PullRequest"><a href="#PullRequest" class="headerlink" title="PullRequest"></a>PullRequest</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PullRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String consumerGroup;</span><br><span class="line">    # 待拉取消息队列</span><br><span class="line">    <span class="keyword">private</span> MessageQueue messageQueue;</span><br><span class="line">    # 消息处理队列，从Broker拉取到的消费先存入到ProcessQueue,然后提交到消费者消费线程池消费</span><br><span class="line">    <span class="keyword">private</span> ProcessQueue processQueue;</span><br><span class="line">    # 待拉取的MessageQueue偏移量</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line">    # 是否被锁定</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lockedFirst = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>ProcessQueue是MessageQueue在消费端的重现、快照。</p><h2 id="ProcessQueue"><a href="#ProcessQueue" class="headerlink" title="ProcessQueue"></a>ProcessQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> REBALANCE_LOCK_MAX_LIVE_TIME =</span><br><span class="line">        Long.parseLong(System.getProperty(<span class="string">"rocketmq.client.rebalance.lockMaxLiveTime"</span>, <span class="string">"30000"</span>));</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> REBALANCE_LOCK_INTERVAL = Long.parseLong(System.getProperty(<span class="string">"rocketmq.client.rebalance.lockInterval"</span>, <span class="string">"20000"</span>));</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> PULL_MAX_IDLE_TIME = Long.parseLong(System.getProperty(<span class="string">"rocketmq.client.pull.pullMaxIdleTime"</span>, <span class="string">"120000"</span>));</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = ClientLogger.getLog();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lockTreeMap = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    # 消息存储容器，键为消息在ConsumeQueue中的偏移量，value为消息实体</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMap = <span class="keyword">new</span> TreeMap&lt;Long, MessageExt&gt;();</span><br><span class="line">    # ProcessQueue中的消息总数</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong msgCount = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lockConsume = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    # 消息临时存储容器，消息消费线程从ProcessQueue的msgTreeMap中取出消息前，先将消息临时存储在msgTreeMapTemp中。</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMapTemp = <span class="keyword">new</span> TreeMap&lt;Long, MessageExt&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong tryUnlockTimes = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> queueOffsetMax = <span class="number">0L</span>;</span><br><span class="line">    # 当前ProcessQueue是否被丢弃</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> dropped = <span class="keyword">false</span>;</span><br><span class="line">    # 上一次开始消息拉取时间戳</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastPullTimestamp = System.currentTimeMillis();</span><br><span class="line">    # 上一次消息消费时间戳</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastConsumeTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastLockTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> consuming = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> msgAccCnt = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h2 id="DefaultMQPushConsumer-客户端消费者实现"><a href="#DefaultMQPushConsumer-客户端消费者实现" class="headerlink" title="DefaultMQPushConsumer 客户端消费者实现"></a>DefaultMQPushConsumer 客户端消费者实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMQPushConsumer</span> <span class="keyword">extends</span> <span class="title">ClientConfig</span> <span class="keyword">implements</span> <span class="title">MQPushConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Internal implementation. Most of the functions herein are delegated to it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">transient</span> DefaultMQPushConsumerImpl defaultMQPushConsumerImpl;</span><br><span class="line"></span><br><span class="line">    # 消费者组名</span><br><span class="line">    <span class="keyword">private</span> String consumerGroup;</span><br><span class="line"></span><br><span class="line">    # 消费模式</span><br><span class="line">    <span class="keyword">private</span> MessageModel messageModel = MessageModel.CLUSTERING;</span><br><span class="line"></span><br><span class="line">   # 消费者从哪个位置消费</span><br><span class="line">   # CONSUME_FROM_LAST_OFFSET: 第一次启动从队列最后位置消费，后续再接着上次消费的进度开始消费</span><br><span class="line">   # CONSUME_FROM_First_OFFSET: 第一次启动从队列开始位置消费，后续再接着上次消费的进度开始消费</span><br><span class="line">   # CONSUME_FROM_TimeStamp: 第一次启动从指定时间点位置消费，后续再接着上次消费的进度开始消费</span><br><span class="line">   # 这里的第一次启动指的是该消费者之前没有消费过该消息队列，如果消费过，则会在Broker端记录消费位置，如果该消费者挂了再启动时，会自动从上次消费的地方开始。</span><br><span class="line">    <span class="keyword">private</span> ConsumeFromWhere consumeFromWhere = ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> String consumeTimestamp = UtilAll.timeMillisToHumanString3(System.currentTimeMillis() - (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">30</span>));</span><br><span class="line">    # 消费分配策略，默认消息平均分配给所有客户端</span><br><span class="line">    <span class="keyword">private</span> AllocateMessageQueueStrategy allocateMessageQueueStrategy;</span><br><span class="line">    # topic对应的订阅tag</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String <span class="comment">/* topic */</span>, String <span class="comment">/* sub expression */</span>&gt; subscription = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    # 客户端消费消息的实现类</span><br><span class="line">    <span class="keyword">private</span> MessageListener messageListener;</span><br><span class="line">    # 存储实现，本地存储或者Broker存储</span><br><span class="line">    <span class="keyword">private</span> OffsetStore offsetStore;</span><br><span class="line">    # Minimum consumer thread number</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> consumeThreadMin = <span class="number">20</span>;</span><br><span class="line">    # Max consumer thread number</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> consumeThreadMax = <span class="number">64</span>;</span><br><span class="line">    # Threshold for dynamic adjustment of the number of thread pool</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> adjustThreadPoolNumsThreshold = <span class="number">100000</span>;</span><br><span class="line">    # 单队列并行消费的最大跨度，用于流量控制</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> consumeConcurrentlyMaxSpan = <span class="number">2000</span>;</span><br><span class="line">    # 一个queue最大消费的消息个数，用于流量控制</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pullThresholdForQueue = <span class="number">1000</span>;</span><br><span class="line">    # 消息拉取时间间隔，默认为0，</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> pullInterval = <span class="number">0</span>;</span><br><span class="line">    # 并发消费时，一次消费消息的数量</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> consumeMessageBatchMaxSize = <span class="number">1</span>;</span><br><span class="line">    # 消息拉取一次的数量</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pullBatchSize = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">     # Whether update subscription relationship when every pull</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> postSubscriptionWhenPull = <span class="keyword">false</span>;</span><br><span class="line">    # Whether the unit of subscription group</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> unitMode = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Max re-consume times. -1 means 16 times.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If messages are re-consumed more than &#123;<span class="doctag">@link</span> #maxReconsumeTimes&#125; before success, it's be directed to a deletion</span></span><br><span class="line"><span class="comment">     * queue waiting.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxReconsumeTimes = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Suspending pulling time for cases requiring slow pulling like flow-control scenario.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> suspendCurrentQueueTimeMillis = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    # Maximum amount of time in minutes a message may block the consuming thread.</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> consumeTimeout = <span class="number">15</span>;</span><br></pre></td></tr></table></figure><h2 id="DefaultMQPushConsumerImpl-消费者具体实现类"><a href="#DefaultMQPushConsumerImpl-消费者具体实现类" class="headerlink" title="DefaultMQPushConsumerImpl 消费者具体实现类"></a>DefaultMQPushConsumerImpl 消费者具体实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMQPushConsumerImpl</span> <span class="keyword">implements</span> <span class="title">MQConsumerInner</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Delay some time when exception occur</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION = <span class="number">3000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Flow control interval</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL = <span class="number">50</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Delay some time when suspend pull service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PULL_TIME_DELAY_MILLS_WHEN_SUSPEND = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BROKER_SUSPEND_MAX_TIME_MILLIS = <span class="number">1000</span> * <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND = <span class="number">1000</span> * <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = ClientLogger.getLog();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultMQPushConsumer defaultMQPushConsumer;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//负载均衡实现类 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RebalanceImpl rebalanceImpl = <span class="keyword">new</span> RebalancePushImpl(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;FilterMessageHook&gt; filterMessageHookList = <span class="keyword">new</span> ArrayList&lt;FilterMessageHook&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> consumerStartTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ConsumeMessageHook&gt; consumeMessageHookList = <span class="keyword">new</span> ArrayList&lt;ConsumeMessageHook&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RPCHook rpcHook;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServiceState serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">    <span class="keyword">private</span> MQClientInstance mQClientFactory;</span><br><span class="line">    <span class="keyword">private</span> PullAPIWrapper pullAPIWrapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> pause = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> consumeOrderly = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> MessageListener messageListenerInner;</span><br><span class="line">    <span class="keyword">private</span> OffsetStore offsetStore;</span><br><span class="line">    <span class="keyword">private</span> ConsumeMessageService consumeMessageService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> flowControlTimes1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> flowControlTimes2 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="消息拉取基本流程"><a href="#消息拉取基本流程" class="headerlink" title="消息拉取基本流程"></a>消息拉取基本流程</h1><p>具体的实现类是DefaultMQPushConsumerImpl<br>消息拉取主要有3个主要步骤：</p><ul><li>消费拉取客户端消息拉取请求封装</li><li>消息服务器查找并返回消息</li><li>消息拉取客户端处理返回的消息</li></ul><ol><li><p>客户端封装消息拉取请求</p><p>1.1 从PullRequest中获取ProcessQueue,如果处理队列当前状态未被丢弃，则更新ProcessQueue的lastPullTimestamp为当前时间戳；如果当前消费者被挂起，则将拉取任务延迟1s再次放入到PullMessageService的拉取任务中，结束本次消息拉取。</p><p>1.2 进行消息拉取流量控制</p><p>PushConsumer有个线程池，消息处理逻辑在各个线程里同时执行，在PushConsumer运行的时候，每个Message Queue都有一个对用的ProcessQueue对象，保存了这个Message Queue 消息处理状态的快照。</p><p>ProcessQueue对象里主要内容是一个TreeMap和一个读写锁。TreeMap里以Message Queue的Offset作为Key，以消息内容的引用为Value,保存了所有从MessageQueue获取的，但是还未被处理的信息，读写锁控制着多个线程对TreeMap对象的并发处理。</p><p>流量控制策略：</p><ul><li>消息处理总数，如果ProcessQueue当前处理的消息超过了pullThresholdForQueue=1000将触发流量控制，放弃本次拉取任务，并且该队列的下一次拉取任务将在50毫秒后才加入到拉取任务队列中。</li><li>ProcessQueue中队列最大偏移量与最小偏移量的间距，不能超过consumeConcurrencyMaxSpan,否则触发流量控制。</li></ul><p>1.3 拉取该主题订阅信息，如果为空，结束本次消息拉取，关于该队列的下一次拉取任务延迟3秒。<br>1.4 构建消息拉取系统标记。<br>1.5 调用PullAPIWrapper.pullKernelImpl方法后与服务端交互。<br>1.6 根据brokerName、BrokerId从MQClientInstance中获取Broker地址，在整个RocketMQ Broker的部署结构中，相同名称的Broker构成主从结构，其BrokerId会不一样，在每次拉取消息后，会给出一个建议，下次拉取从主节点还是从节点拉取。</p></li></ol><p>然后是消息服务端Broker组装消息。会根据处理的结果返回不同的状态编码。<br>主要有下面几种状态编码。</p><ul><li>SUCCESS : 成功</li><li>PULL_RETRY_IMMEDIATElY : 立即重试</li><li>PULL_OFFSET_MOVED : 偏移量移动</li><li>PULL_NOT_FOUND : 未找到消息</li></ul><ol start="3"><li>消息拉取客户端处理消息。</li></ol><p>先分析状态编码为SUCCESS的后续处理步骤。</p><ul><li>更新PullRequest的下一次拉取偏移量，如果msgFoundList为空，则立即将PullRequest放入到PullMessageService的pullRequestQueue,以便PullMessageService能及时唤醒并再次执行消息拉取。</li><li>将拉取到的消息存放到ProcessQueue,然后将拉取到的消息提交到ConsumeMessageService中供消费者消费。</li><li>将消费提交给消费者线程之后PullCallBack将立即返回，可以说本次消息拉取顺利完成，然后根据pullInterval参数，如果pullInterval &gt; 0,则等待pullInterval毫秒后将PullRequest对象放入到PullMessageService的pullRequestQueue中，该消息队列的下次拉取即将被激活，达到持续消息拉取，实现准实时拉取消息的效果。</li></ul><p>如果拉取结果为偏移量非法，首先将ProcessQueue设置dropped为ture,表示丢弃该消息队列，意味着ProcessQueue中拉取的消息将停止消费，然后根据服务端下一次校对的偏移量尝试更新消息消费进度，然后尝试持久化消息消费进度，并将该消息队列从RebalanceImpl的处理队列中移除，意味着暂停该消息队列的消息拉取，等待下一次消息队列重新加载。</p><p>这篇对消息拉取的笔记就暂时写到这里，下一篇阿静详细介绍关于消息拉取失败后的长轮询方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;消息消费，简而言之就是消费者从消息队列里读取数据。消费者有两种消费方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;Push方式&lt;/strong&gt;。消息服务器接收到信息后，主动把消息推送给消费者，实时性高。但是这样加大了消息服务器的工作压力，会影响其性能。除此之外，不
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ阅读笔记之消息存储</title>
    <link href="https://github.com/spurstong/2019/11/09/RocketMQ%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/"/>
    <id>https://github.com/spurstong/2019/11/09/RocketMQ阅读笔记之消息存储/</id>
    <published>2019-11-09T14:02:34.819Z</published>
    <updated>2019-11-14T13:40:11.949Z</updated>
    
    <content type="html"><![CDATA[<p>消息存储部分是RocketMQ的重要组成部分，良好的存储机制会有效降低延迟，提高整体效率。RocketMQ利用到了文件系统，将消息存放在磁盘中实现持久化。</p><p>首先先介绍消息存储的整体结构，先大体了解其处理机制。</p><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/RocketMQ%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/1.png" alt="RocketMQ消息存储整体架构"></p><p>从上图中可以看出有几个重要的文件。</p><ul><li><p>CommitLog: 消息存储文件，所有消息主题的消息都存储在CommitLog文件夹中，它以物理文件的方式存放，每台Broker上有一个CommitLog文件夹，里面有多个文件，单个文件的大小默认为1G,文件名表示的是该文件中的第1条信息的物理偏移量。每台Broker上的CommitLog被本机器所有ConsumeQueue共享。在CommitLog中，一个消息的存储长度是不固定的。每条消息的前4个字节存储该条消息的总长度，其余的信息就是在该长度下的消息内容。</p></li><li><p>ConsumerQueue: 消息队列文件，在ConsumerQueue文件夹中存在以topic(主题名)为文件夹名的多个文件夹。然后在每个文件夹里根据消息队列数创建了多个文件夹，文件夹名为0，1，2，..。然后在最里面的文件记录的是某主题下的某消息队列下的文件信息，但是它并没有存储消息的具体信息，它起到了类似于索引的功能，更够使消费者可以快速的在CommitLog文件中查找到所需的信息。</p><p>单个ConsumerQueue文件中默认包含30万个条目，单个文件的长度为30W * 20字节，即每条信息占20字节。前8个字节为commitlog offset,为该条消息在commitlog的实际偏移量，中间4个字节为size,即该条消息的长度，最后8字节为tag hashcode,即存储该条消息的tag的哈希值，用于订阅时消息过滤。</p></li><li><p>IndexFile：索引文件。如果消息包含key值的话，会使用IndexFile来存储消息索引。具体的逻辑结构在后面讲解到。</p></li></ul><h1 id="内存映射技术"><a href="#内存映射技术" class="headerlink" title="内存映射技术"></a>内存映射技术</h1><p>  在Linux操作系统中分为“用户态”和“内核态”，在进行IO操作时，会涉及到这两种形态的切换及read()和write()操作。在执行read()操作时，是系统调用的，期间进行了数据拷贝，它首先将文件内容从硬盘拷贝到内核空间的一个缓冲区，然后再将这些数据拷贝到用户空间，在这个过程中实际上完成了两次的数据拷贝。这样会对访问速度有所影响。</p><p>  针对这种情况，提出了mmap内存映射技术，mmap内存映射和普通标准IO操作的本质区别是它并不需要将文件中的数据先拷贝到OS的内核IO缓冲区，而是可以直接将用户进程私有地址空间的一块区域与文件对象建立映射关系，就好像可以直接从内存中完成对文件读写操作一样。只有当缺页中断发生时，直接将磁盘拷贝至用户态的进程空间内，只进行了一次数据拷贝。</p><p>  <img src="https://raw.githubusercontent.com/spurstong/img_data/master/RocketMQ%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/3.png" alt="标准IO与NIO的区别"></p><h1 id="高可用机制"><a href="#高可用机制" class="headerlink" title="高可用机制"></a>高可用机制</h1><p>  RocketMQ分布式集群是通过Master和Slave的配合达到高可用性的，在Broker的配置文件中，参数brokerId的值为0表示这个Broker是Master,大于0表示该Broker是Slave。Master角色的Broker支持读和写，Slave角色的Broker仅支持读，也就是说,Producer只能和Master角色的Broker连接写入信息；Consumer可以连接Master角色和Slave角色的Broker来读取消息。</p><p>  对于Consumer,当Master不可用或者繁忙的时候，Consumer会自动切换到Slave进行读取消息，实现了消费端的高可用性。</p><p>  对于Producer,在创建topic的时候，把Topic的多个Message Queue创建在多个Broker组上（相同Broker名称，不同BrokerId的机器组成一个Broker组），这样当一个Broker组的Master不可用候，其他组的Master依然可用，Producer仍然可以发送消息。</p><h1 id="内存映射相关类"><a href="#内存映射相关类" class="headerlink" title="内存映射相关类"></a>内存映射相关类</h1><p>  由上面可知，RocketMQ通过使用内存映射文件来提高IO访问性能，现在介绍几个相关的类。</p><p>  <em>MappedFile</em></p><p>  它是CommitLog里面具体文件的映射。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedFile</span> <span class="keyword">extends</span> <span class="title">ReferenceResource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OS_PAGE_SIZE = <span class="number">1024</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);</span><br><span class="line">    <span class="comment">// 当前JVM中映射的虚拟内存总大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong TOTAL_MAPPED_VIRTUAL_MEMORY = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 当前JVM中mmap句柄数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger TOTAL_MAPPED_FILES = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 当前写到什么位置</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> AtomicInteger wrotePosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//ADD BY ChenYang</span></span><br><span class="line">    <span class="comment">// Flush到什么位置</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> AtomicInteger committedPosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger flushedPosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 映射的文件大小，定长</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> fileSize;</span><br><span class="line">    <span class="comment">// 映射的FileChannel对象</span></span><br><span class="line">    <span class="keyword">protected</span> FileChannel fileChannel;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Message will put to here first, and then reput to FileChannel if writeBuffer is not null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> ByteBuffer writeBuffer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> TransientStorePool transientStorePool = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 映射的文件名</span></span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line">    <span class="comment">// 映射的起始偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> fileFromOffset;</span><br><span class="line">    <span class="comment">// 映射的文件</span></span><br><span class="line">    <span class="keyword">private</span> File file;</span><br><span class="line">    <span class="comment">// 映射的内存对象，position永远不变</span></span><br><span class="line">    <span class="keyword">private</span> MappedByteBuffer mappedByteBuffer;</span><br><span class="line">    <span class="comment">// 最后一条消息存储时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> storeTimestamp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> firstCreateInQueue = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>  <em>MappedFileQueue</em></p><p>  MappedFileQueue是MappedFile的管理容器，MappedFileQueue是对存储目录的封装。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedFileQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG_ERROR = LoggerFactory.getLogger(LoggerName.STORE_ERROR_LOGGER_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次触发删除文件，最多删除多少个文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELETE_FILES_BATCH_MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 文件存储位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String storePath;</span><br><span class="line">    <span class="comment">// 每个文件的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mappedFileSize;</span><br><span class="line">    <span class="comment">// 各个文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;MappedFile&gt; mappedFiles = <span class="keyword">new</span> CopyOnWriteArrayList&lt;MappedFile&gt;();</span><br><span class="line">    <span class="comment">// 预分配MapedFile对象服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AllocateMappedFileService allocateMappedFileService;</span><br><span class="line">    <span class="comment">// 当前刷盘指针，表示该指针之前的所有数据全部持久化到磁盘</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> flushedWhere = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前数据提交指针，内存中ByteBuffer当前的写指针，该值大于等于flushedWhere.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> committedWhere = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 最后一条消息存储时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> storeTimestamp = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>  根据消息偏移量offset查找MappedFile时，不会直接使用offset/mappedFileSize，因为消息文件不是永久存在的，RocketMQ会定时删除存储文件，第一个文件不一定是000000000000000000，可能最初的起始文件已经被删除，那么利用上述方法是会产生错误的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MappedFile <span class="title">findMappedFileByOffset</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset, <span class="keyword">final</span> <span class="keyword">boolean</span> returnFirstOnNotFound)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          # 获取第一个MappedFile</span><br><span class="line">          MappedFile mappedFile = <span class="keyword">this</span>.getFirstMappedFile();</span><br><span class="line">          <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">int</span> index = (<span class="keyword">int</span>) ((offset / <span class="keyword">this</span>.mappedFileSize) - (mappedFile.getFileFromOffset() / <span class="keyword">this</span>.mappedFileSize));</span><br><span class="line">              <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.mappedFiles.size()) &#123;</span><br><span class="line">                  LOG_ERROR.warn(<span class="string">"Offset for &#123;&#125; not matched. Request offset: &#123;&#125;, index: &#123;&#125;, "</span> +</span><br><span class="line">                          <span class="string">"mappedFileSize: &#123;&#125;, mappedFiles count: &#123;&#125;"</span>,</span><br><span class="line">                      mappedFile,</span><br><span class="line">                      offset,</span><br><span class="line">                      index,</span><br><span class="line">                      <span class="keyword">this</span>.mappedFileSize,</span><br><span class="line">                      <span class="keyword">this</span>.mappedFiles.size());</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">this</span>.mappedFiles.get(index);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (returnFirstOnNotFound) &#123;</span><br><span class="line">                      <span class="keyword">return</span> mappedFile;</span><br><span class="line">                  &#125;</span><br><span class="line">                  LOG_ERROR.warn(<span class="string">"findMappedFileByOffset failure. "</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          log.error(<span class="string">"findMappedFileByOffset Exception"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>  其中，重要的一个公式是<em>(int) ((offset / this.mappedFileSize) - (mappedFile.getFileFromOffset() / this.mappedFileSize));</em>    offset / this.mappedFileSize得到的是假设所有文件没有被删除的情况下该偏移量所处的文件，然后mappedFile.getFileFromOffset() / this.mappedFileSize，获取第一个文件的起始偏移量，如果之前有文件删除的话，计算已删除的文件数。这样就可以得到定位到实际的文件。</p><p><em>ConsumeQueue</em></p><p>ConsumeQueue是消息的逻辑队列，类似数据库的索引文件，存储的指向物理存储的地址，每个topic下的每一个Message Queue都有一个对应的ConsumeQueue文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储单元大小 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CQ_STORE_UNIT_SIZE = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG_ERROR = LoggerFactory.getLogger(LoggerName.STORE_ERROR_LOGGER_NAME);</span><br><span class="line">    <span class="comment">// 存储顶层对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultMessageStore defaultMessageStore;</span><br><span class="line">    <span class="comment">// 存储消息索引的队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MappedFileQueue mappedFileQueue;</span><br><span class="line">    <span class="comment">// Topic</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;</span><br><span class="line">    <span class="comment">// queueId</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> queueId;</span><br><span class="line">    <span class="comment">// 写索引时用到的ByteBuffer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer byteBufferIndex;</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String storePath;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mappedFileSize;</span><br><span class="line">    <span class="comment">// 最后一个消息对应的物理Offset</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxPhysicOffset = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 逻辑队列的最小Offset，删除物理文件时，计算出来的最小Offset</span></span><br><span class="line">    <span class="comment">// 实际使用需要除以 StoreUnitSize</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> minLogicOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> ConsumeQueueExt consumeQueueExt = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p><em>IndexFile</em></p><p>如果该消息存在key,可以根据key进行查询，这时需要用到IndexFile索引文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> hashSlotSize = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> indexSize = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> invalidIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hashSlotNum;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> indexNum;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MappedFile mappedFile;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileChannel fileChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MappedByteBuffer mappedByteBuffer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IndexHeader indexHeader;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/RocketMQ%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/4.png" alt="RocketMQ索引文件"></p><p>从大的方面来说，分为3个部分，IndexHead,500w个hsah槽和2000w个Index条目。<br>IndexHead头部，包含40个字节，记录该IndexFile的统计信息，其结构如下：</p><ul><li>beginTimestamp: 该索引文件中包含信息的最小存储时间。</li><li>endTimestamp: 该索引文件中包含信息的最大存储时间。</li><li>beginPhyoffset: 该索引文件中包含的消息在commitlog文件中的最小物理偏移量。</li><li>endPhyoffset: 该索引文件中包含的消息在commitlog文件中的最大物理偏移量。</li><li>hashlogCount: hashlot个数。</li><li>indexCount: Index条目列表当前已使用的个数。</li></ul><p>500w个hsah槽<br>每个Hash槽存储的是落在该Hash槽的hashcode最新的Index的索引，每个Hash槽占4个字节。</p><p>2000w个Index<br>每一个Index条目结构如下：</p><ul><li>hashcode: key的hashcode</li><li>phyoffset: 消息对应的物理偏移量</li><li>timedif: 该消息存储时间与第一条消息的时间戳的差值</li><li>preIndexNo: 该条目的前一条记录的Index索引</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putKey</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">long</span> phyOffset, <span class="keyword">final</span> <span class="keyword">long</span> storeTimestamp)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getIndexCount() &lt; <span class="keyword">this</span>.indexNum) &#123;</span><br><span class="line">           # 消息key的hashcode </span><br><span class="line">           <span class="keyword">int</span> keyHash = indexKeyHashMethod(key);</span><br><span class="line">           # 将key的hashcode与hash槽数量取余，得到该hashcode下的hash槽下标</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">int</span> slotPos = keyHash % <span class="keyword">this</span>.hashSlotNum;</span><br><span class="line">           # 该槽的物理地址</span><br><span class="line">           <span class="keyword">int</span> absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize;</span><br><span class="line"></span><br><span class="line">           FileLock fileLock = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// fileLock = this.fileChannel.lock(absSlotPos, hashSlotSize,</span></span><br><span class="line">               <span class="comment">// false);</span></span><br><span class="line">               # 获取该hashcode的存储的Index索引，</span><br><span class="line">               <span class="keyword">int</span> slotValue = <span class="keyword">this</span>.mappedByteBuffer.getInt(absSlotPos);</span><br><span class="line">               <span class="keyword">if</span> (slotValue &lt;= invalidIndex || slotValue &gt; <span class="keyword">this</span>.indexHeader.getIndexCount()) &#123;</span><br><span class="line">                   slotValue = invalidIndex;</span><br><span class="line">               &#125;</span><br><span class="line">              # 计算待存储消息的时间戳与第一条消息时间戳的差值，并转换为秒</span><br><span class="line">               <span class="keyword">long</span> timeDiff = storeTimestamp - <span class="keyword">this</span>.indexHeader.getBeginTimestamp();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 时间差存储单位由毫秒改为秒</span></span><br><span class="line">               timeDiff = timeDiff / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 25000天后溢出</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getBeginTimestamp() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   timeDiff = <span class="number">0</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeDiff &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                   timeDiff = Integer.MAX_VALUE;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   timeDiff = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">int</span> absIndexPos =</span><br><span class="line">                   IndexHeader.INDEX_HEADER_SIZE + <span class="keyword">this</span>.hashSlotNum * hashSlotSize</span><br><span class="line">                       + <span class="keyword">this</span>.indexHeader.getIndexCount() * indexSize;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 写入真正索引</span></span><br><span class="line">               <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos, keyHash);</span><br><span class="line">               <span class="keyword">this</span>.mappedByteBuffer.putLong(absIndexPos + <span class="number">4</span>, phyOffset);</span><br><span class="line">               <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span>, (<span class="keyword">int</span>) timeDiff);</span><br><span class="line">              <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span> + <span class="number">4</span>, slotValue);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 更新哈希槽</span></span><br><span class="line">               <span class="keyword">this</span>.mappedByteBuffer.putInt(absSlotPos, <span class="keyword">this</span>.indexHeader.getIndexCount());</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 第一次写入</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getIndexCount() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.indexHeader.setBeginPhyOffset(phyOffset);</span><br><span class="line">                   <span class="keyword">this</span>.indexHeader.setBeginTimestamp(storeTimestamp);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">this</span>.indexHeader.incHashSlotCount();</span><br><span class="line">               <span class="keyword">this</span>.indexHeader.incIndexCount();</span><br><span class="line">               <span class="keyword">this</span>.indexHeader.setEndPhyOffset(phyOffset);</span><br><span class="line">               <span class="keyword">this</span>.indexHeader.setEndTimestamp(storeTimestamp);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               log.error(<span class="string">"putKey exception, Key: "</span> + key + <span class="string">" KeyHashCode: "</span> + key.hashCode(), e);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (fileLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       fileLock.release();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           log.warn(<span class="string">"Over index file capacity: index count = "</span> + <span class="keyword">this</span>.indexHeader.getIndexCount()</span><br><span class="line">               + <span class="string">"; index max num = "</span> + <span class="keyword">this</span>.indexNum);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>将该条目信息存储在IndexFile中，在之前的所存储的最后一个Index的后面添加，依次存放hashcode、消息物理偏移值、消息存储时间戳与第一条消息时间戳的差值、上一条相同hashcode的索引位置。并将当前新放入的Index条目个数即下标放入到该key值所处的卡槽位置中，即会覆盖掉原来记录的Index条目的下标，它只会记录最新的Index条目的下标。</p><p>但会存在一种情况，即不同的key可能会存在相同的hashcode，在查找hash槽是根据hashcode查找的，只能记录一个，所以会产生冲突，面对这种情况，在Index索引记录时有一个属性记录了该条目的前一条记录的索引值，即他们的hashcode是相同的。</p><p>下面是根据索引key查找消息，其中有一步是解决了hashcode冲突问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectPhyOffset</span><span class="params">(<span class="keyword">final</span> List&lt;Long&gt; phyOffsets, <span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">int</span> maxNum,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">long</span> begin, <span class="keyword">final</span> <span class="keyword">long</span> end, <span class="keyword">boolean</span> lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mappedFile.hold()) &#123;</span><br><span class="line">            <span class="keyword">int</span> keyHash = indexKeyHashMethod(key);</span><br><span class="line">            <span class="keyword">int</span> slotPos = keyHash % <span class="keyword">this</span>.hashSlotNum;</span><br><span class="line">            <span class="keyword">int</span> absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize;</span><br><span class="line"></span><br><span class="line">            FileLock fileLock = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// fileLock = this.fileChannel.lock(absSlotPos,</span></span><br><span class="line">                    <span class="comment">// hashSlotSize, true);</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> slotValue = <span class="keyword">this</span>.mappedByteBuffer.getInt(absSlotPos);</span><br><span class="line">                <span class="comment">// if (fileLock != null) &#123;</span></span><br><span class="line">                <span class="comment">// fileLock.release();</span></span><br><span class="line">                <span class="comment">// fileLock = null;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (slotValue &lt;= invalidIndex || slotValue &gt; <span class="keyword">this</span>.indexHeader.getIndexCount()</span><br><span class="line">                    || <span class="keyword">this</span>.indexHeader.getIndexCount() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// TODO NOTFOUND</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> nextIndexToRead = slotValue;;) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (phyOffsets.size() &gt;= maxNum) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> absIndexPos =</span><br><span class="line">                            IndexHeader.INDEX_HEADER_SIZE + <span class="keyword">this</span>.hashSlotNum * hashSlotSize</span><br><span class="line">                                + nextIndexToRead * indexSize;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> keyHashRead = <span class="keyword">this</span>.mappedByteBuffer.getInt(absIndexPos);</span><br><span class="line">                        <span class="keyword">long</span> phyOffsetRead = <span class="keyword">this</span>.mappedByteBuffer.getLong(absIndexPos + <span class="number">4</span>);</span><br><span class="line">                        <span class="comment">// int转为long，避免下面计算时间差值时溢出</span></span><br><span class="line">                        <span class="keyword">long</span> timeDiff = (<span class="keyword">long</span>) <span class="keyword">this</span>.mappedByteBuffer.getInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span>);</span><br><span class="line">                       <span class="keyword">int</span> prevIndexRead = <span class="keyword">this</span>.mappedByteBuffer.getInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span> + <span class="number">4</span>);</span><br><span class="line">                        <span class="comment">// 读到了未知数据</span></span><br><span class="line"><span class="keyword">if</span> (timeDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 时间差存储的是秒，再还原为毫秒， long避免溢出</span></span><br><span class="line">                        timeDiff *= <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">long</span> timeRead = <span class="keyword">this</span>.indexHeader.getBeginTimestamp() + timeDiff;</span><br><span class="line">                        <span class="keyword">boolean</span> timeMatched = (timeRead &gt;= begin) &amp;&amp; (timeRead &lt;= end);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (keyHash == keyHashRead &amp;&amp; timeMatched) &#123;</span><br><span class="line">                            phyOffsets.add(phyOffsetRead);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (prevIndexRead &lt;= invalidIndex</span><br><span class="line">                            || prevIndexRead &gt; <span class="keyword">this</span>.indexHeader.getIndexCount()</span><br><span class="line">                            || prevIndexRead == nextIndexToRead || timeRead &lt; begin) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        nextIndexToRead = prevIndexRead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"selectPhyOffset exception "</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fileLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        fileLock.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.mappedFile.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于会存在hash冲突，根据slotValue定位该hash槽最新的一个Item条目，经过一些处理后，会通过 <em>prevIndexRead</em> 获取到该Hashcode下的上一个Index下标，如果大于等于1并且小于最大条目数，则继续查找，否则结束查找。</p><h1 id="文件刷盘机制"><a href="#文件刷盘机制" class="headerlink" title="文件刷盘机制"></a>文件刷盘机制</h1><p>RocketMQ的存储与读写是基于JDK NIO的内存映射机制（MappedByteBuffer）的，消息存储时首先将消息追加到内存，再根据配置的刷盘策略在不同时间进行刷写磁盘，如果是同步刷盘，消息追加到内存后，将同步调用MappedByteBuffer的force方法；如果是异步刷盘，在消息追加到内存后立刻返回给消息发送端，RocketMQ使用一个单独的线程按照某一个设定的频率执行刷盘操作。</p><h1 id="Consume与IndexFile文件的实时更新"><a href="#Consume与IndexFile文件的实时更新" class="headerlink" title="Consume与IndexFile文件的实时更新"></a>Consume与IndexFile文件的实时更新</h1><p>当消息提交存储在Commitlog文件中，ConsumeQueue、IndexFile文件需要及时更新，否则消息无法及时被消费，如何确保消息内容能及时更新到ConsumeQueue、IndexFile等文件，RocketMQ通过开启一个线程ReputMessageService来实时更新消息信息。</p><p>在ReputMessageService线程中有一个重要的参数reputFromOffset,该参数表示从哪个物理偏移量开始转发消息给ConsumeQueue和IndexFile,如果允许重复转发，reputFromOffset设置为CommitLog的提交指针，如果不允许重复转发，reputFromOffset设置为CommitLog的内存中最大偏移量。读取的时候会读取该偏移量后的所有消息。</p><p>ReputMessageService线程每执行一次任务推送休息1毫秒就继续推送消息到消息消费队列和索引文件。<br>获取到新增的消息后，会采用不同的方法来对ConsumeQueue和IndexFile文件进行更新。</p><h2 id="根据消息更新对应文件"><a href="#根据消息更新对应文件" class="headerlink" title="根据消息更新对应文件"></a>根据消息更新对应文件</h2><p>获取到新增的消息后，要将这些消息更新到ConsumeQueue或IndexFile中，现以ConsumeQueue文件为例。</p><ul><li>根据消息主题与队列ID,获取到对应的ConsumeQueue文件，ConsumeQueue文件实际是对应的该队列ID下的文件夹，文件夹里有很多文件，在ConsumeQueue属性里面有一个MappedFileQueue,对该文件夹下的所有文件做映射。</li><li>依次将消息偏移量、消息长度、tag hashcode写入到ByteBuffer中，将内容追加到ConsumeQueue的内存映射文件中，ConsumeQueue的刷盘方式固定为异步刷盘方式。</li></ul><h1 id="过期文件删除机制"><a href="#过期文件删除机制" class="headerlink" title="过期文件删除机制"></a>过期文件删除机制</h1><p>CommitLog、ConsumeQueue文件是基于内存映射机制并在启动的时候会加载commitlog、ConsumeQueue目录下的所有文件，为了避免内存与磁盘的浪费，不可能将消息永久的存储在消息服务器上。</p><p>RocketMQ顺序写CommitLog文件、ConsumeQueue文件，所有写操作全部落在了最后一个CommitLog或ConsumeQueue文件上，之前的文件在下一个文件创建后将不会再更新，如果非当前写文件在下一个文件创建后将不会再被更新，则认为是过期文件，默认的过期时间是72小时。</p><p>RocketMQ会在下面几种情况下执行删除文件操作。</p><ul><li>指定删除文件的时间点，通过设置deleteWhen设置一天的固定时间执行一次删除过期文件操作，默认是凌晨4点</li><li>磁盘空间是否充足，如果磁盘空间不充足，则会触发过期文件删除操作。</li><li>可以通过调用excuteDeleteFilesManualy方法手动触发过期文件删除。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;消息存储部分是RocketMQ的重要组成部分，良好的存储机制会有效降低延迟，提高整体效率。RocketMQ利用到了文件系统，将消息存放在磁盘中实现持久化。&lt;/p&gt;
&lt;p&gt;首先先介绍消息存储的整体结构，先大体了解其处理机制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ阅读笔记之消息发送</title>
    <link href="https://github.com/spurstong/2019/10/31/RocketMQ%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81/"/>
    <id>https://github.com/spurstong/2019/10/31/RocketMQ阅读笔记之消息发送/</id>
    <published>2019-10-31T15:16:01.333Z</published>
    <updated>2019-11-09T07:10:38.794Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章中我们可以了解到NameServer需要等Broker失效至少120s才能将该Broker从路由表中移除，那如果在Broker故障期间，消息生产者Producer根据获取到的路由信息可能包含已经宕机的Broker,会导致消息发送失败，在接下来的消息发送阶段会解决这个问题。</p><a id="more"></a><h1 id="初识消息有关类"><a href="#初识消息有关类" class="headerlink" title="初识消息有关类"></a>初识消息有关类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8445773977080406428L</span>;  </span><br><span class="line">    # 消息所属主题</span><br><span class="line">    <span class="keyword">private</span> String topic;</span><br><span class="line"> # 消息Flag</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> flag;</span><br><span class="line"> # 扩展属性</span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, String&gt; properties;</span><br><span class="line"> # 消息体</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">byte</span>[] body;</span><br><span class="line"> <span class="keyword">private</span> String transactionId;</span><br></pre></td></tr></table></figure><p>其中，Message扩展属性主要包括下面几个：</p><ul><li>tag : 消息Tag,用于消息过滤</li><li>keys ：Message索引建，多个用空格隔开，RocketMQ可以根据这些key快速检索到消息</li><li>waitStoreMsgOK ： 消息发送时是否等到消息存储完成后再返回</li><li>delayTimeLevel : 消息延迟级别，用于定时消息或消息重试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMQProducer</span> <span class="keyword">extends</span> <span class="title">ClientConfig</span> <span class="keyword">implements</span> <span class="title">MQProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InternalLogger log = ClientLogger.getLog();    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrapping internal implementations for virtually all methods presented in this class. */</span>  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">transient</span> DefaultMQProducerImpl defaultMQProducerImpl;   </span><br><span class="line">  # 生产者所属组，消息服务器在回查事务状态时会随机选择该组中的任何一个生产者发起事务回查请求</span><br><span class="line">  <span class="keyword">private</span> String producerGroup;   </span><br><span class="line">  <span class="keyword">private</span> String createTopicKey = MixAll.AUTO_CREATE_TOPIC_KEY_TOPIC;    </span><br><span class="line">  # 默认主题在每一个Broker队列的数量</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> defaultTopicQueueNums = <span class="number">4</span>;    </span><br><span class="line">  # 发送消息默认超时时间，默认3秒</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> sendMsgTimeout = <span class="number">3000</span>;</span><br><span class="line">  # 消息体超过该值则启用压缩，默认4K     </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> compressMsgBodyOverHowmuch = <span class="number">1024</span> * <span class="number">4</span>;    </span><br><span class="line">  # 同步方式发送消息重试次数，默认为2，总共执行3次</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> retryTimesWhenSendFailed = <span class="number">2</span>;</span><br><span class="line">  # 异步方式发送消息重试次数，默认为2    </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> retryTimesWhenSendAsyncFailed = <span class="number">2</span>; </span><br><span class="line">  # 允许发送的最大消息长度   </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxMessageSize = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>; <span class="comment">// 4M    </span></span><br><span class="line">  <span class="keyword">private</span> TraceDispatcher traceDispatcher = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">MessageQueue</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6191200464116433425L</span>;</span><br><span class="line"> <span class="keyword">private</span> String topic;</span><br><span class="line"> <span class="keyword">private</span> String brokerName;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> queueId;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicPublishInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> orderTopic = <span class="keyword">false</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">boolean</span> haveTopicRouterInfo = <span class="keyword">false</span>;</span><br><span class="line"> <span class="keyword">private</span> List&lt;MessageQueue&gt; messageQueueList = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadLocalIndex sendWhichQueue = <span class="keyword">new</span> ThreadLocalIndex();</span><br><span class="line"> <span class="keyword">private</span> TopicRouteData topicRouteData;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicRouteData</span> <span class="keyword">extends</span> <span class="title">RemotingSerializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String orderTopicConf;</span><br><span class="line">    <span class="keyword">private</span> List&lt;QueueData&gt; queueDatas;</span><br><span class="line">    <span class="keyword">private</span> List&lt;BrokerData&gt; brokerDatas;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br></pre></td></tr></table></figure><h1 id="发送信息总体过程"><a href="#发送信息总体过程" class="headerlink" title="发送信息总体过程"></a>发送信息总体过程</h1><ol><li>发送消息的入口  DefaultMQProducerImpl#send()  ，默认消息发送以同步方式发送，默认超时时间为3s。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg, SendCallback sendCallback)</span> <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException </span>&#123;</span><br><span class="line">       send(msg, sendCallback, <span class="keyword">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg, SendCallback sendCallback, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.sendDefaultImpl(msg, CommunicationMode.ASYNC, sendCallback, timeout);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"unknownn exception"</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>调用sendDefaultImpl，形参为下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendDefaultImpl</span><span class="params">(//</span></span></span><br><span class="line"><span class="function"><span class="params">       Message msg, //</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> CommunicationMode communicationMode, //</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> SendCallback sendCallback, //</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> <span class="keyword">long</span> timeout//</span></span></span><br><span class="line"><span class="function"><span class="params">   )</span></span></span><br></pre></td></tr></table></figure></li></ol><p>其中，CommunicationMode表示消息发送的方式，同步、异步和单向。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CommunicationMode &#123;</span><br><span class="line">    SYNC,</span><br><span class="line">    ASYNC,</span><br><span class="line">    ONEWAY,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会验证服务服务是否可用，消息是否符合规范，具体的验证就不解释了。<br>然后记录当前时间，后面会判断是否timeout。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> beginTimestampFirst = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> beginTimestampPrev = beginTimestampFirst;</span><br></pre></td></tr></table></figure><p>根据要发送消息的topic,寻找该topic的路由信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br></pre></td></tr></table></figure><p>当前类有一个属性，记录所有topic的路由信息和消息队列信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* topic */</span>, TopicPublishInfo&gt; topicPublishInfoTable =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;String, TopicPublishInfo&gt;();</span><br></pre></td></tr></table></figure><p>首先从topicPublishInfoTable中查找该topic的topicPublishInfoTable信息，<br>如果不存在当前topic的信息或者当前topicPublishInfoTable不可用，则先新创建一个TopicPublishInfo()，并放入到topicPublishInfoTable中，然后向NameServer查询该topic的路由信息，此时会调用MQClientInstance的updateTopicRouteInfoFromNameServer(topic)方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TopicPublishInfo <span class="title">tryToFindTopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存中获取 Topic发布信息</span></span><br><span class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    <span class="comment">// 当无或者可用的 Topic信息时，从Namesrv获取一次 并且缓存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == topicPublishInfo || !topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.topicPublishInfoTable.putIfAbsent(topic, <span class="keyword">new</span> TopicPublishInfo());<span class="comment">//如果key存在的情况下，在putIfAbsent下不会修改</span></span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic); <span class="comment">//进行调用获取规则存下来</span></span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, <span class="keyword">true</span>, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock lockNamesrv = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure><p>MQClientInstance#updateTopicRouteInfoFromNameServer方法,LOCK_TIMEOUT_MILLIS默认是3秒，在此处用到了ReentrantLock.tryLock。<br>该锁的方法的简单解释：<br>假如线程A和线程B使用同一个锁Lock,此时线程A首先获取锁Lock.lock(),并且始终持有不释放，如果此时B要去获取锁，调用tryLock(3000, mils),则说明在3秒内如果线程A释放锁，会获取到锁并返回true,否则3秒过后会获取不到锁并返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.lockNamesrv.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br></pre></td></tr></table></figure><p>如果isDefault为true,则使用默认主题去查询，如果查询到路由信息，则替换路由信息中读写队列个数为消息生产者默认的队列个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TopicRouteData topicRouteData;</span><br><span class="line"><span class="keyword">if</span> (isDefault &amp;&amp; defaultMQProducer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getDefaultTopicRouteInfoFromNameServer(defaultMQProducer.getCreateTopicKey(),</span><br><span class="line">        <span class="number">1000</span> * <span class="number">3</span>);<span class="comment">//获取topic规则</span></span><br><span class="line">    <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (QueueData data : topicRouteData.getQueueDatas()) &#123;</span><br><span class="line">            <span class="keyword">int</span> queueNums = Math.min(defaultMQProducer.getDefaultTopicQueueNums(), data.getReadQueueNums());</span><br><span class="line">            data.setReadQueueNums(queueNums);</span><br><span class="line">            data.setWriteQueueNums(queueNums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果isDefault为false,则使用参数topic去查询，如果未查询到路由信息，则返回false,表示路由信息未变化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getTopicRouteInfoFromNameServer(topic, <span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果路由信息找到，与本地缓存中的路由信息进行对比，判断路由信息是否发生了变化，如果没有发生变化，则直接返回fasle。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">    TopicRouteData old = <span class="keyword">this</span>.topicRouteTable.get(topic);</span><br><span class="line">    <span class="keyword">boolean</span> changed = topicRouteDataIsChange(old, topicRouteData);</span><br><span class="line">    <span class="keyword">if</span> (!changed) &#123;</span><br><span class="line">        changed = <span class="keyword">this</span>.isNeedUpdateTopicRouteInfo(topic);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"the topic[&#123;&#125;] route info changed, old[&#123;&#125;] ,new[&#123;&#125;]"</span>, topic, old, topicRouteData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果发生了变化，先对topicRouteData进行复制，然后根据获得的topicRouteData信息对brokerAddrTable进行更新，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (changed) &#123;</span><br><span class="line">    TopicRouteData cloneTopicRouteData = topicRouteData.cloneTopicRouteData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BrokerData bd : topicRouteData.getBrokerDatas()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerAddrTable.put(bd.getBrokerName(), bd.getBrokerAddrs());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>根据topicRouteData中的List&lt;\queueData&gt;转化成topicPublishInfo的List&lt;\MessageQueue&gt;列表。具体的是在topicRouteData2TopicPublishInfo中实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TopicPublishInfo publishInfo = topicRouteData2TopicPublishInfo(topic, topicRouteData);</span><br><span class="line">publishInfo.setHaveTopicRouterInfo(<span class="keyword">true</span>);</span><br><span class="line">Iterator&lt;Entry&lt;String, MQProducerInner&gt;&gt; it = <span class="keyword">this</span>.producerTable.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Entry&lt;String, MQProducerInner&gt; entry = it.next();</span><br><span class="line">    MQProducerInner impl = entry.getValue();</span><br><span class="line">    <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        impl.updateTopicPublishInfo(topic, publishInfo);<span class="comment">//更新topic的PublishInfo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环遍历路由信息的QueueData信息，如果队列没有写权限，则继续遍历下一个QueueData,根据brokerName找到brokerData信息，找不到或没有找到Master节点，则遍历下一个QueueData,根据写队列个数，根据topic+序号创建MessageQueue,填充topicPublishInfo的List&lt;\QueueMessage&gt;,此时，完成了消息发送的路由查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//topicRouteData转换为TopicPublishInfo</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TopicPublishInfo <span class="title">topicRouteData2TopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> TopicRouteData route)</span> </span>&#123;</span><br><span class="line">        TopicPublishInfo info = <span class="keyword">new</span> TopicPublishInfo();</span><br><span class="line">        info.setTopicRouteData(route);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有序</span></span><br><span class="line">        <span class="keyword">if</span> (route.getOrderTopicConf() != <span class="keyword">null</span> &amp;&amp; route.getOrderTopicConf().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String[] brokers = route.getOrderTopicConf().split(<span class="string">";"</span>);</span><br><span class="line">            <span class="keyword">for</span> (String broker : brokers) &#123;</span><br><span class="line">                String[] item = broker.split(<span class="string">":"</span>);</span><br><span class="line">                <span class="keyword">int</span> nums = Integer.parseInt(item[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">                    MessageQueue mq = <span class="keyword">new</span> MessageQueue(topic, item[<span class="number">0</span>], i);</span><br><span class="line">                    info.getMessageQueueList().add(mq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            info.setOrderTopic(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//无序</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;QueueData&gt; qds = route.getQueueDatas();</span><br><span class="line">            Collections.sort(qds);<span class="comment">//按照brokerName升序进行排序的</span></span><br><span class="line">            <span class="keyword">for</span> (QueueData qd : qds) &#123;</span><br><span class="line">                <span class="keyword">if</span> (PermName.isWriteable(qd.getPerm())) &#123;</span><br><span class="line">                    BrokerData brokerData = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (BrokerData bd : route.getBrokerDatas()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (bd.getBrokerName().equals(qd.getBrokerName())) &#123;</span><br><span class="line">                            brokerData = bd;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == brokerData) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!brokerData.getBrokerAddrs().containsKey(MixAll.MASTER_ID)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qd.getWriteQueueNums(); i++) &#123;</span><br><span class="line">                        MessageQueue mq = <span class="keyword">new</span> MessageQueue(topic, qd.getBrokerName(), i);</span><br><span class="line">                        info.getMessageQueueList().add(mq);<span class="comment">//由于brokerName是排序的，TopicPublishInfo里面的messageQueueList就是有序的了从小到大</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            info.setOrderTopic(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取到路由信息之后，如果该路由信息可用，则先计算尝试的次数，如果发送模式是sync,则是3次，其他情况下是1次。<br>之后记录上次发送失败的broker名称，在第一次发送的时候，lastBrokerName为null,然后根据消息队列选择策略选择消息队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">    MessageQueue mq = <span class="keyword">null</span>;</span><br><span class="line">    Exception exception = <span class="keyword">null</span>;</span><br><span class="line">    SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//发送模式是sync 会有3次其他1次</span></span><br><span class="line">    <span class="keyword">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? <span class="number">1</span> + <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">            String[] brokersSent = <span class="keyword">new</span> String[timesTotal];</span><br><span class="line">            <span class="keyword">for</span> (; times &lt; timesTotal; times++) &#123;</span><br><span class="line">                String lastBrokerName = <span class="keyword">null</span> == mq ? <span class="keyword">null</span> : mq.getBrokerName(); <span class="comment">//第一次的确是null 但是如果第二次呢？ 所以这里存在的意义</span></span><br><span class="line">                MessageQueue tmpmq = <span class="keyword">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName);<span class="comment">//选择一个queue</span></span><br><span class="line">                <span class="keyword">if</span> (tmpmq != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mq = tmpmq;</span><br><span class="line">                    brokersSent[times] = mq.getBrokerName();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line">                        <span class="comment">//调用sendKernelImpl发送消息  发送消息核心</span></span><br><span class="line">                        sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        <span class="comment">//更新Broker可用信息</span></span><br><span class="line">                        <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line">                        <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">                            <span class="keyword">case</span> ASYNC:</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">case</span> SYNC:</span><br><span class="line">                                <span class="keyword">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">return</span> sendResult;</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">true</span>);</span><br><span class="line">                        log.warn(String.format(<span class="string">"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        exception = e;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">true</span>);</span><br><span class="line">                        log.warn(String.format(<span class="string">"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        exception = e;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">true</span>);</span><br><span class="line">                        log.warn(String.format(<span class="string">"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        exception = e;</span><br><span class="line">                        <span class="keyword">switch</span> (e.getResponseCode()) &#123;</span><br><span class="line">                           <span class="comment">// 如下异常continue，进行发送消息重试</span></span><br><span class="line">                            <span class="keyword">case</span> ResponseCode.TOPIC_NOT_EXIST:</span><br><span class="line">                            <span class="keyword">case</span> ResponseCode.SERVICE_NOT_AVAILABLE:</span><br><span class="line">                            <span class="keyword">case</span> ResponseCode.SYSTEM_ERROR:</span><br><span class="line">                            <span class="keyword">case</span> ResponseCode.NO_PERMISSION:</span><br><span class="line">                            <span class="keyword">case</span> ResponseCode.NO_BUYER_ID:</span><br><span class="line">                            <span class="keyword">case</span> ResponseCode.NOT_IN_CURRENT_UNIT:</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                <span class="keyword">if</span> (sendResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">return</span> sendResult;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">throw</span> e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line">                        log.warn(String.format(<span class="string">"sendKernelImpl exception, throw exception, InvokeID: %s, RT: %sms, Broker: %s"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line">                        log.warn(<span class="string">"sendKernelImpl exception"</span>, e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>消息队列选择策略。<br>有两种策略， sendLatencyFaultEnable=false, 默认不启用Broker故障延迟机制。<br>                       sendLatencyFaultEnable=true,启用Broker故障延迟机制。<br> 先介绍默认的消息队列选择策略，调用TopicPublishInfo#selectOneMessageQueue<br> 当第一次调用时，lastBrokerName为null,对sendWhichQueue本地线程变量进行加1，并与当前路由表中消息队列个数取模，返回该位置的MessageQueue。<br> 如果该消息发送失败，则可能会进行重试发送，此时，lastBrokerName不是null,会记录上次信息发送失败的BrokerName,之后获取sendWhichQueue本地线程变量进行加1，并与当前路由表中消息队列个数取模，获取该位置上的MessageQueue,如果获取的该信息的BrokerName与上一次发送失败的lastBrokerName不相同，则返回该信息，否则再遍历下一个消息，直到第一个不与lastBrokerName相同的消息返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastBrokerName == <span class="keyword">null</span>) &#123;<span class="comment">//第一次进入就是空的</span></span><br><span class="line">            <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="keyword">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.messageQueueList.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = Math.abs(index++) % <span class="keyword">this</span>.messageQueueList.size();</span><br><span class="line">                <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                    pos = <span class="number">0</span>;</span><br><span class="line">                MessageQueue mq = <span class="keyword">this</span>.messageQueueList.get(pos);</span><br><span class="line">                <span class="keyword">if</span> (!mq.getBrokerName().equals(lastBrokerName)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mq;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> index = <span class="keyword">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line">       <span class="keyword">int</span> pos = Math.abs(index) % <span class="keyword">this</span>.messageQueueList.size();</span><br><span class="line">       <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">           pos = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.messageQueueList.get(pos);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>接下来讲解启用Broker故障延迟机制的消息选择策略<br>前面部分和上述介绍的差不多，根据index先获取当前位置的消息，然后判断该消息队列是否可用，通过isAvailable方法判断。如果该消息队列可用，在上次发送，或者这次发送的消息队列的broker姓名与上次发送失败的broker姓名一致，则返回该消息队列。<br>如果所有的broker都预计不可用，随机选择一个不可用的broker,再从路由信息中选择下一个消息队列，将该消息队列的broker重置为上面随机选择的broker,并重置queueId,并返回该消息队列。但是，如果该随机选择的broker内已经没有要发送的消息队列时，则需要将该broker从latencyFaultTolerance中移除，并利用默认的选择机制选择一个消息队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延迟故障容错，维护每个Broker的发送消息的延迟</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> LatencyFaultTolerance&lt;String&gt; latencyFaultTolerance = <span class="keyword">new</span> LatencyFaultToleranceImpl();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123; <span class="comment">//发送消息延迟容错开关</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</span><br><span class="line">            <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</span><br><span class="line">            <span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</span><br><span class="line">                    <span class="keyword">return</span> mq;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</span><br><span class="line">        <span class="keyword">int</span> writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</span><br><span class="line">        <span class="keyword">if</span> (writeQueueNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> MessageQueue mq = tpInfo.selectOneMessageQueue();</span><br><span class="line">            <span class="keyword">if</span> (notBestBroker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mq.setBrokerName(notBestBroker);</span><br><span class="line">                mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mq;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            latencyFaultTolerance.remove(notBestBroker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.eror(<span class="string">"Error occurred when selecting message queue"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tpInfo.selectOneMessageQueue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面部分是根据不同策略选择消息队列的具体解释，获取到消息队列之后，返回到发送消息的最外层方法endDefaultImpl中，执行消息发送步骤。</p><h1 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h1><p>tmpmq是选择获取到的消息队列。<br>brokersSent是存储消息发送的broker,由上面可知，如果发送方式是同步，则该数组长度为3，其他方式下长度为1。然后记录当前时间，然后执行<em>sendKernelImpl</em>方法进行发送消息。之后，获取发送完之后的时间，执行<em>updateFaultItem</em>方法来更新Broker异常信息，一个broker会对应一个faultItem。<br>之后，根据消息发送的方式，如果是同步的，如果此次消息没有成功，则可以再进行尝试，如果是异步或者单向，则执行结束。如果期间发送了异常，则会调用<em>updateFaultItem</em>方法来更新Broker异常信息。<br>接下来详细介绍<em>sendKernelImpl</em>方法和<em>updateFaultItem</em>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue tmpmq = <span class="keyword">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName)</span><br><span class="line"><span class="keyword">if</span> (tmpmq != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mq = tmpmq;</span><br><span class="line">    brokersSent[times] = mq.getBrokerName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//调用sendKernelImpl发送消息  发送消息核心</span></span><br><span class="line">        sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);</span><br><span class="line">        endTimestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//更新Broker可用信息</span></span><br><span class="line">        <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> ASYNC:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> SYNC:</span><br><span class="line">                <span class="keyword">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> sendResult;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="DefaultMQProducerImpl-sendKernelImpl"><a href="#DefaultMQProducerImpl-sendKernelImpl" class="headerlink" title="DefaultMQProducerImpl.sendKernelImpl"></a>DefaultMQProducerImpl.sendKernelImpl</h2><p>该方法的形参有：</p><ul><li>Message msg : 待发送的消息</li><li>MessageQueue mq : 消息将发送到该消息队列上</li><li>CommunicationMode commuicationMode : 消息发送模式，SYNC、ASYNC、ONEWAy</li><li>SendCallback sendCallback :异步消息回调函数</li><li>TopicPublishInfo topicPublishInfo ： 主题路由信息</li><li>long timeout:消息发送超时时间</li></ul><ol><li>根据MessageQueue获取Broker的网络地址,如果MQClientInstance的brokerAddrTable未缓存该Broker的信息，则从NameServer主动更新一下topic的路由信息，如果路由更新后还是找不到Broker信息，则抛出MQClientException，提示Broker不存在。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == brokerAddr) &#123;</span><br><span class="line">            tryToFindTopicPublishInfo(mq.getTopic());</span><br><span class="line">            brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>为消息分配全局唯一ID,如果消息体默认超过4K,会对消息体采用zip压缩，并设置消息的系统标记为MessageSysFlag.COMPRESED_FLAG。如果是事务Prepared消息，则设置消息的系统标记为MessageSysFlag.TRANSACTION_PREPARED_TYPE。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//for MessageBatch,ID has been set in the generating process</span></span><br><span class="line"><span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</span><br><span class="line">    MessageClientIDSetter.setUniqID(msg);<span class="comment">//设置设置UNIQ_id，所以当看见msgId的时候为什么解析不一样了懂了吧</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sysFlag = <span class="number">0</span>; <span class="comment">//又是根据位来进行每位是啥的判断</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.tryToCompressMessage(msg)) &#123;</span><br><span class="line">    sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);<span class="comment">//根据事务属性key获取值看是否是事务消息</span></span><br><span class="line"><span class="keyword">if</span> (tranMsg != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line">    sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果注册了消息发送钩子函数，则执行消息发送之前的增强逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">                context = <span class="keyword">new</span> SendMessageContext();</span><br><span class="line">                context.setProducer(<span class="keyword">this</span>);</span><br><span class="line">                context.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">                context.setCommunicationMode(communicationMode);</span><br><span class="line">                context.setBornHost(<span class="keyword">this</span>.defaultMQProducer.getClientIP());</span><br><span class="line">                context.setBrokerAddr(brokerAddr);</span><br><span class="line">                context.setMessage(msg);</span><br><span class="line">                context.setMq(mq);</span><br><span class="line">                String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">                <span class="keyword">if</span> (isTrans != <span class="keyword">null</span> &amp;&amp; isTrans.equals(<span class="string">"true"</span>)) &#123;</span><br><span class="line">                    context.setMsgType(MessageType.Trans_Msg_Half);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (msg.getProperty(<span class="string">"__STARTDELIVERTIME"</span>) != <span class="keyword">null</span> || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    context.setMsgType(MessageType.Delay_Msg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.executeSendMessageHookBefore(context);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></li><li><p>构建消息发送请求包。主要包含下列重要信息：</p></li></ol><ul><li>生产者组、主题名称、默认创建主题Key、该主题在单个Broker默认队列数、队列ID</li><li>消息系统标记、消息发送时间、消息标记、消息扩展属性、消息重试次数、是否是批量信息。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//构建SendMessageRequestHeader</span></span><br><span class="line">SendMessageRequestHeader requestHeader = <span class="keyword">new</span> SendMessageRequestHeader();</span><br><span class="line">    requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">    requestHeader.setTopic(msg.getTopic());</span><br><span class="line">    requestHeader.setDefaultTopic(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey());</span><br><span class="line">    requestHeader.setDefaultTopicQueueNums(<span class="keyword">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</span><br><span class="line">    requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line">    requestHeader.setSysFlag(sysFlag);</span><br><span class="line">    <span class="comment">//生成消息时间戳</span></span><br><span class="line">    requestHeader.setBornTimestamp(System.currentTimeMillis());</span><br><span class="line">    requestHeader.setFlag(msg.getFlag());</span><br><span class="line">    requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line">    requestHeader.setReconsumeTimes(<span class="number">0</span>);</span><br><span class="line">    requestHeader.setUnitMode(<span class="keyword">this</span>.isUnitMode());</span><br><span class="line">    requestHeader.setBatch(msg <span class="keyword">instanceof</span> MessageBatch);</span><br><span class="line">    <span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">        String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</span><br><span class="line">        <span class="keyword">if</span> (reconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</span><br><span class="line">            MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</span><br><span class="line">        <span class="keyword">if</span> (maxReconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</span><br><span class="line">            MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><p>按照消息发送方式，同步、异步、单向方式进行网络传输。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> ASYNC:</span><br><span class="line">        sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(<span class="comment">//异步发送消息</span></span><br><span class="line">            brokerAddr, <span class="comment">// 1</span></span><br><span class="line">            mq.getBrokerName(), <span class="comment">// 2</span></span><br><span class="line">            msg, <span class="comment">// 3</span></span><br><span class="line">            requestHeader, <span class="comment">// 4</span></span><br><span class="line">            timeout, <span class="comment">// 5</span></span><br><span class="line">            communicationMode, <span class="comment">// 6</span></span><br><span class="line">            sendCallback, <span class="comment">// 7</span></span><br><span class="line">            topicPublishInfo, <span class="comment">// 8</span></span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory, <span class="comment">// 9</span></span><br><span class="line">            <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(), <span class="comment">// 10</span></span><br><span class="line">            context, <span class="comment">//</span></span><br><span class="line">            <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ONEWAY:</span><br><span class="line">    <span class="keyword">case</span> SYNC:</span><br><span class="line">        sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(<span class="comment">//同步以及广播发送消息</span></span><br><span class="line">            brokerAddr,</span><br><span class="line">            mq.getBrokerName(),</span><br><span class="line">            msg,</span><br><span class="line">            requestHeader,</span><br><span class="line">            timeout,</span><br><span class="line">            communicationMode,</span><br><span class="line">            context,</span><br><span class="line">            <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">    context.setSendResult(sendResult);</span><br><span class="line">    <span class="keyword">this</span>.executeSendMessageHookAfter(context); <span class="comment">//发送消息后逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sendResult;</span><br></pre></td></tr></table></figure></li><li><p>之后就是按照不同的方式进行发送。在发送之前会检查消息发送是否合理，检查该Broker是否有写权限，该Topic是否可以进行消息发送，在NameServer端存储主题的配置信息，除此之外，开始检查队列，如果队列不合法，返回错误码</p></li><li><p>如果消息重试次数超过允许的最大重试次数，消息将进入到DLD延迟队列。延迟队列主题：%DLQ%+消费组名，</p></li><li><p>调用DefaultMessageStore.putMessage进行消息存储。</p></li></ol><h2 id="DefaultMQProducerImpl-updateFaultItem"><a href="#DefaultMQProducerImpl-updateFaultItem" class="headerlink" title="DefaultMQProducerImpl.updateFaultItem"></a>DefaultMQProducerImpl.updateFaultItem</h2><p>由上面可知，在执行消息发送完之后和出现发送异常的时候，会调用该方法对broker进行异常更新。<br>形参解释：</p><ul><li>brokerName : broker名称</li><li>currentLatency : 本次消息发送延迟时间currentLatency </li><li>isolation : 是否隔离，如果为true,则使用默认时长30s来计算BroKer故障规避时长；如果为false,则使用本次消息发送延迟时间来计算Broker故障规避时长。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">boolean</span> isolation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">            <span class="keyword">long</span> duration = computeNotAvailableDuration(isolation ? <span class="number">30000</span> : currentLatency);</span><br><span class="line">            <span class="keyword">this</span>.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>利用<em>computeNotAvailableDuration()</em> 方法计算规避时长。<br>从latencyMax数组尾部开始查找，找到第一个比currentLatency小的下标，然后从notAvailableDuration数组中获取需要规避的时长。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延迟级别数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] latencyMax = &#123;<span class="number">50L</span>, <span class="number">100L</span>, <span class="number">550L</span>, <span class="number">1000L</span>, <span class="number">2000L</span>, <span class="number">3000L</span>, <span class="number">15000L</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不可用时长数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] notAvailableDuration = &#123;<span class="number">0L</span>, <span class="number">0L</span>, <span class="number">30000L</span>, <span class="number">60000L</span>, <span class="number">120000L</span>, <span class="number">180000L</span>, <span class="number">600000L</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">computeNotAvailableDuration</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> currentLatency)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = latencyMax.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentLatency &gt;= latencyMax[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.notAvailableDuration[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>根据broker名称从缓存表faultItemTable中获取FaultItem,如果找到则更新FaultItem,否则创建FaultItem。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, FaultItem&gt; faultItemTable = <span class="keyword">new</span> ConcurrentHashMap&lt;String, FaultItem&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">final</span> <span class="keyword">long</span> notAvailableDuration)</span> </span>&#123;</span><br><span class="line">    FaultItem old = <span class="keyword">this</span>.faultItemTable.get(name);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == old) &#123;</span><br><span class="line">        <span class="keyword">final</span> FaultItem faultItem = <span class="keyword">new</span> FaultItem(name);</span><br><span class="line">        faultItem.setCurrentLatency(currentLatency);</span><br><span class="line">        faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line"></span><br><span class="line">        old = <span class="keyword">this</span>.faultItemTable.putIfAbsent(name, faultItem);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.setCurrentLatency(currentLatency);</span><br><span class="line">            old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        old.setCurrentLatency(currentLatency);</span><br><span class="line">        old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>一个broker对应一个faultItem,记录broker名称、消息发送时长和broker恢复正常时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FaultItem</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">FaultItem</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> currentLatency;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> startTimestamp;</span><br></pre></td></tr></table></figure><h1 id="批量消息发送"><a href="#批量消息发送" class="headerlink" title="批量消息发送"></a>批量消息发送</h1><p>批量消息发送就是将同一主题的多条信息一起打包发送到消息服务端，减少网络调用次数。<br>单挑信息发送时，消息体的内容将保存在body中。批量消息发送，需要将多条消息体的内容采用固定格式存储在body中。<br>在消息发送端，调用batch方法，将一批消息封装成MessageBatch对象，之后的处理流程与上面的基本一致，只需要将该集合的每一条消息的消息体body聚合成一个byte[]数值，在消息服务端能够从该byte[]数值中正确解析消息即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章中我们可以了解到NameServer需要等Broker失效至少120s才能将该Broker从路由表中移除，那如果在Broker故障期间，消息生产者Producer根据获取到的路由信息可能包含已经宕机的Broker,会导致消息发送失败，在接下来的消息发送阶段会解决这个问题。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RocketMQ阅读笔记之路由中心NameServer</title>
    <link href="https://github.com/spurstong/2019/10/22/RocketMQ%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E8%B7%AF%E7%94%B1%E4%B8%AD%E5%BF%83NameServer/"/>
    <id>https://github.com/spurstong/2019/10/22/RocketMQ阅读笔记之路由中心NameServer/</id>
    <published>2019-10-22T14:37:25.400Z</published>
    <updated>2019-10-31T12:28:26.486Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么会有NameServer"><a href="#为什么会有NameServer" class="headerlink" title="为什么会有NameServer"></a>为什么会有NameServer</h1><p>消息中间件一般基于主题的订阅发布机制，消息生产者会发送某一主体（Topic）的消息到消息服务器（Broker）,消息服务器负责该消息的持久化存储，消息消费者订阅感兴趣的主题。通常情况下，为了避免消息服务器的单点故障导致的整个系统瘫痪，通常会部署多台消息服务器共同承担消息的存储。那么消息生产者如何 知道消息要发往哪台消息服务器呢？如果某一台消息服务器宕机了，那么生产者如何在不重启服务的情况下感知。NameServer可以 解决上述问题。</p><p>Broker消息服务器在启动的时候向所有NameServer注册，消息生产者在发送消息之前先从NameServer获取Broker服务器地址列表，然后 根据负载均衡算法从列表中选择一台消息服务器进行消息发送，如果检测到Broker宕机，则从路由注册表中将其移除，但是路由变化不会马上通知消息生产者。</p><p>NameServer本身的高可用可通过部署多台NameServer服务器来实现，但彼此互不通信，也就是NameServer服务器之间在某一时刻的数据并不会完全相同 。</p><h1 id="NameServer作用及重要变量"><a href="#NameServer作用及重要变量" class="headerlink" title="NameServer作用及重要变量"></a>NameServer作用及重要变量</h1><p>NameServer存储路由的基础信息，还能够管理Broker节点，包括路由注册、路由删除等功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* topic */</span>, List&lt;QueueData&gt;&gt; topicQueueTable; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerName */</span>, BrokerData&gt; brokerAddrTable; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* clusterName */</span>, Set&lt;String<span class="comment">/* brokerName */</span>&gt;&gt; clusterAddrTable; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, BrokerLiveInfo&gt; brokerLiveTable; <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br></pre></td></tr></table></figure><p>从上面可以看出数据类型都是HashMap,  其中，QueueData记录的是消息队列的信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueData</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">QueueData</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String brokerName;</span><br><span class="line"> # 读队列数量</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> readQueueNums;</span><br><span class="line"> # 写队列数量</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> writeQueueNums;</span><br><span class="line"> # 读写权限，具体含义参考PermName</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> perm;</span><br><span class="line"> # topic同步标记，具体含义参考TopicSysFlag</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> topicSynFlag;</span><br></pre></td></tr></table></figure><ul><li><p>记录集群信息，存储集群中所有Broker名称</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BrokerData</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">BrokerData</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String cluster;</span><br><span class="line"> <span class="keyword">private</span> String brokerName;</span><br><span class="line"> <span class="keyword">private</span> HashMap&lt;Long<span class="comment">/* brokerId */</span>, String<span class="comment">/* broker address */</span>&gt; brokerAddrs;</span><br></pre></td></tr></table></figure></li><li><p>Broker状态信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrokerLiveInfo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> lastUpdateTimestamp;</span><br><span class="line"> <span class="keyword">private</span> DataVersion dataVersion;</span><br><span class="line"> <span class="keyword">private</span> Channel channel;</span><br><span class="line"> <span class="keyword">private</span> String haServerAddr;</span><br></pre></td></tr></table></figure></li><li><p>topicQueueTable: Topic消息队列路由信息 ，消息发送时根据路由表进行负载均衡。</p></li><li><p>brokerAddrTable: Broker基础信息，包含brokerName、所属集群名称、主备Broker地址。</p></li><li><p>clusterAddrTable: Broker状态信息，存储集群中所有Broker名称。</p></li><li><p>brokerLiveTable: Broker状态信息。NameServer每次收到心跳包时会替换该信息。</p></li><li><p>filterServerTable: Broker上的FilterServer列表，用于类模式消息过滤。</p></li></ul><h1 id="路由注册"><a href="#路由注册" class="headerlink" title="路由注册"></a>路由注册</h1><p>Broker启动时向集群中所有的NameServer发送心跳语句，每隔30s向集群中所有NameServer发送心跳包，NameServer收到Broker心跳包时会更新brokerLiveTable缓存中BrokerLiveInfo的lastUpdateTimestamp,然后NameServer每隔10s扫描brokerLiveTable,如果连续120s没有收到心跳包，NameServer将移除该Broker的路由信息同时关闭Socket连接。</p><h1 id="NameServer处理心跳包"><a href="#NameServer处理心跳包" class="headerlink" title="NameServer处理心跳包"></a>NameServer处理心跳包</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RegisterBrokerResult <span class="title">registerBroker</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> String clusterName,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">final</span> String brokerAddr,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">final</span> String brokerName,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">final</span> <span class="keyword">long</span> brokerId,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">final</span> String haServerAddr,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">final</span> TopicConfigSerializeWrapper topicConfigWrapper,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">final</span> List&lt;String&gt; filterServerList,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">final</span> Channel channel)</span> </span>&#123;</span><br><span class="line">    RegisterBrokerResult result = <span class="keyword">new</span> RegisterBrokerResult();</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.writeLock().lockInterruptibly();    Set&lt;String&gt; brokerNames = <span class="keyword">this</span>.clusterAddrTable.get(clusterName);</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">null</span> == brokerNames) &#123;</span><br><span class="line">                brokerNames = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"> <span class="keyword">this</span>.clusterAddrTable.put(clusterName, brokerNames);</span><br><span class="line">  &#125;</span><br><span class="line">            brokerNames.add(brokerName);   <span class="keyword">boolean</span> registerFirst = <span class="keyword">false</span>;    BrokerData brokerData = <span class="keyword">this</span>.brokerAddrTable.get(brokerName);</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">null</span> == brokerData) &#123;</span><br><span class="line">                registerFirst = <span class="keyword">true</span>;</span><br><span class="line">  brokerData = <span class="keyword">new</span> BrokerData(clusterName, brokerName, <span class="keyword">new</span> HashMap&lt;Long, String&gt;());</span><br><span class="line"> <span class="keyword">this</span>.brokerAddrTable.put(brokerName, brokerData);</span><br><span class="line">  &#125;</span><br><span class="line">            Map&lt;Long, String&gt; brokerAddrsMap = brokerData.getBrokerAddrs();</span><br><span class="line">  <span class="comment">//Switch slave to master: first remove &lt;1, IP:PORT&gt; in namesrv, then add &lt;0, IP:PORT&gt;</span></span><br><span class="line"> <span class="comment">//The same IP:PORT must only have one record in brokerAddrTable  Iterator&lt;Entry&lt;Long, String&gt;&gt; it = brokerAddrsMap.entrySet().iterator();</span></span><br><span class="line"> <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                Entry&lt;Long, String&gt; item = it.next();</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">null</span> != brokerAddr &amp;&amp; brokerAddr.equals(item.getValue()) &amp;&amp; brokerId != item.getKey()) &#123;</span><br><span class="line">                    it.remove();</span><br><span class="line">  &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String oldAddr = brokerData.getBrokerAddrs().put(brokerId, brokerAddr);</span><br><span class="line">  registerFirst = registerFirst || (<span class="keyword">null</span> == oldAddr);   <span class="keyword">if</span> (<span class="keyword">null</span> != topicConfigWrapper</span><br><span class="line">                &amp;&amp; MixAll.MASTER_ID == brokerId) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion())</span><br><span class="line">                    || registerFirst) &#123;</span><br><span class="line">                    ConcurrentMap&lt;String, TopicConfig&gt; tcTable =</span><br><span class="line">                        topicConfigWrapper.getTopicConfigTable();</span><br><span class="line"> <span class="keyword">if</span> (tcTable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (Map.Entry&lt;String, TopicConfig&gt; entry : tcTable.entrySet()) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.createAndUpdateQueueData(brokerName, entry.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            BrokerLiveInfo prevBrokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.put(brokerAddr,</span><br><span class="line"> <span class="keyword">new</span> BrokerLiveInfo(</span><br><span class="line">                    System.currentTimeMillis(),</span><br><span class="line">  topicConfigWrapper.getDataVersion(),</span><br><span class="line">  channel,</span><br><span class="line">  haServerAddr));</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">null</span> == prevBrokerLiveInfo) &#123;</span><br><span class="line">                log.info(<span class="string">"new broker registered, &#123;&#125; HAServer: &#123;&#125;"</span>, brokerAddr, haServerAddr);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (filterServerList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (filterServerList.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.filterServerTable.remove(brokerAddr);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">this</span>.filterServerTable.put(brokerAddr, filterServerList);</span><br><span class="line">  &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (MixAll.MASTER_ID != brokerId) &#123;</span><br><span class="line">                String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);</span><br><span class="line"> <span class="keyword">if</span> (masterAddr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    BrokerLiveInfo brokerLiveInfo = <span class="keyword">this</span>.brokerLiveTable.get(masterAddr);</span><br><span class="line"> <span class="keyword">if</span> (brokerLiveInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());</span><br><span class="line">  result.setMasterAddr(masterAddr);</span><br><span class="line">  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.lock.writeLock().unlock();</span><br><span class="line">  &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">"registerBroker Exception"</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result; &#125;</span><br></pre></td></tr></table></figure><ul><li>路由注册需要加写锁，防止并发修改RouteInfoManager中的路由表。首先判断Broker所属集群是否存在，如果不存在，则创建，然后将broker名加入到集群Broker集合中。</li><li>维护BrokerData信息，首先从brokerAddrTable根据BrokerName尝试获取Broker信息，如果不存在，则新建BrokerData并放入到brokerAddrTable,registerFirst设置为true；如果存在，直接替换原来的，registerFirst设置为false,表示非第一次注册。</li><li>如果Broker为Master,并且Broker Topic配置信息发生变化或者是初次注册，则需要创建或更新Topic路由元数据，填充topicQueueTable,其实就是为默认主题自动注册路由信息。根据TopicConfig创建QueueData的数据结构，然后更新topicQueueTable。</li><li>更新BrokerLiveInfo,存活Broker信息表，BrokerLiveInfo是执行路由删除的重要依据。</li><li>注册Broker的过滤器Server地址列表，一个Broker上会关联多个FilterServer消息过滤服务器。</li></ul><h1 id="路由删除"><a href="#路由删除" class="headerlink" title="路由删除"></a>路由删除</h1><p>NameServer会每隔10s扫描brokerLiveTable状态表，如果BrokerLive的lastUpdateTimestamp的时间戳距当前时间超过120s,则认为Broker失效，移除该Broker,关闭与Broker连接，并同时更新topicQueueTable、brokerAddrTable、brokerLiveTable、filterServerTable。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么会有NameServer&quot;&gt;&lt;a href=&quot;#为什么会有NameServer&quot; class=&quot;headerlink&quot; title=&quot;为什么会有NameServer&quot;&gt;&lt;/a&gt;为什么会有NameServer&lt;/h1&gt;&lt;p&gt;消息中间件一般基于主题的订阅发布机制
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HashTable源码分析</title>
    <link href="https://github.com/spurstong/2019/10/22/HashTable%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/spurstong/2019/10/22/HashTable源码分析/</id>
    <published>2019-10-22T10:47:06.517Z</published>
    <updated>2019-10-22T12:55:02.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Map的架构"><a href="#Map的架构" class="headerlink" title="Map的架构"></a>Map的架构</h1><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/HashTable%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png" alt="1.png"><br>从上面图中可以看出，Map类型的子类主要有TreeMap、HashMap和HashTable等。<br>其中，TreeMap和HashMap主要继承的是AbstractMap，也同时实现了Map接口，而HashTable则继承了Directionary，同时也实现了Map接口。<br>HashMap和HashTable的内容都是键值对，都不保证次序，但HashMap是线程不安全的，而HashTable是线程安全的，它的key和value都不允许为空。</p><p>HashTable的继承情况如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>其中，Dictionary抽象类定义了键值对的基本操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dictionary</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> Enumeration&lt;K&gt; <span class="title">keys</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> Enumeration&lt;V&gt; <span class="title">elements</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HashTable源码分析"><a href="#HashTable源码分析" class="headerlink" title="HashTable源码分析"></a>HashTable源码分析</h1><ol><li>HashTable成员变量</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 键值对数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Entry&lt;?,?&gt;[] table;</span><br><span class="line"><span class="comment">//数组的实际数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">//阈值，用来判断是否要调整HashTable的容量 （threshold = 容量 * loadFactor）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//加载因子</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">//被修改的次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> modCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//版本序列号</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1421746759512286392L</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>构造函数<br>HashMap的构造函数有四种形式，你可以手动设置数组的初始化容量和加载因子，如果没有设置，默认的初始化容量值为11，加载因子为0.75, 也可以将一个给定的同等类型的Map构造映射为新的HashTable.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line"> <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Load: "</span>+loadFactor);   <span class="keyword">if</span> (initialCapacity==<span class="number">0</span>)</span><br><span class="line">        initialCapacity = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">  table = <span class="keyword">new</span> Entry&lt;?,?&gt;[initialCapacity];</span><br><span class="line">  threshold = (<span class="keyword">int</span>)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, <span class="number">0.75f</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="number">11</span>, <span class="number">0.75f</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Hashtable</span><span class="params">(Map&lt;? extends K, ? extends V&gt; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Math.max(<span class="number">2</span>*t.size(), <span class="number">11</span>), <span class="number">0.75f</span>);</span><br><span class="line">  putAll(t); &#125;</span><br></pre></td></tr></table></figure></li><li><p>判断是否包含该value</p></li></ol><p>首先将该键值对数组赋值给tab数组，然后从尾到头逆向查找,然后在该位置的单向链表中进行依次查找，找到后返回true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = tab.length ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.value.equals(value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>判断是否包含该key<br>在获取到该key的hash值后，会与0x7FFFFFFF执行按位与操作，这样做是为了保证index的第一位是0，也就是为了保证得到的是一个正数，因为有符号数的第一位是0时代表为正数，1表示为负数。<br>然后根据index找到该key所在数组中的位置，然后开始单向遍历该位置的链表。如果该节点的hash值与要查找的key的hash值相等，并且key值相等，则返回true。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">     <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">     <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">     <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br></pre></td></tr></table></figure></li></ol><p>返回该key上的值的原理同上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">        <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;?,?&gt; e = tab[index] ; e != <span class="keyword">null</span> ; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                <span class="keyword">return</span> (V)e.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>HashTable扩容</li></ol><p>首先将原来table赋值给oldMap数组，然后将新的数组长度扩展为原来数组长度的2倍+1，如果超出最大值，将设置新的数组长度为最大值。之后，创建一个该新长度的数组。<br>修改次数+1，并设置新的阈值。<br>开始初始化HashTable,根据新的容量长度查找在新的数组的位置，之后采用头插法插入到该位置的单向链表的头部。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> oldCapacity = table.length;</span><br><span class="line">       Entry&lt;?,?&gt;[] oldMap = table;</span><br><span class="line">       <span class="comment">// overflow-conscious code</span></span><br><span class="line">       <span class="keyword">int</span> newCapacity = (oldCapacity &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (oldCapacity == MAX_ARRAY_SIZE)</span><br><span class="line">               <span class="comment">// Keep running with MAX_ARRAY_SIZE buckets</span></span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           newCapacity = MAX_ARRAY_SIZE;</span><br><span class="line">       &#125;</span><br><span class="line">       Entry&lt;?,?&gt;[] newMap = <span class="keyword">new</span> Entry&lt;?,?&gt;[newCapacity];</span><br><span class="line"></span><br><span class="line">       modCount++;</span><br><span class="line">       threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAX_ARRAY_SIZE + <span class="number">1</span>);</span><br><span class="line">       table = newMap;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = oldCapacity ; i-- &gt; <span class="number">0</span> ;) &#123;</span><br><span class="line">           <span class="keyword">for</span> (Entry&lt;K,V&gt; old = (Entry&lt;K,V&gt;)oldMap[i] ; old != <span class="keyword">null</span> ; ) &#123;</span><br><span class="line">               Entry&lt;K,V&gt; e = old;</span><br><span class="line">               old = old.next;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">int</span> index = (e.hash &amp; <span class="number">0x7FFFFFFF</span>) % newCapacity;</span><br><span class="line">               e.next = (Entry&lt;K,V&gt;)newMap[index];</span><br><span class="line">               newMap[index] = e;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>HashTable添加元素</li></ol><p>首先它会判断该数组中是否含有该key值，如果有则进行值替换。<br>如果没有，则利用头插法插入到该数组位置的头结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Make sure the value is not null</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="comment">// Makes sure the key is not already in the hashtable.</span></span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">   <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">   <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">      Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">   <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</span><br><span class="line">          <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</span><br><span class="line">              V old = entry.value;</span><br><span class="line">    entry.value = value;</span><br><span class="line">   <span class="keyword">return</span> old;</span><br><span class="line">    &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      addEntry(hash, key, value, index);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;   </span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">   <span class="keyword">if</span> (count &gt;= threshold) &#123;</span><br><span class="line">          <span class="comment">// Rehash the table if the threshold is exceeded</span></span><br><span class="line">    rehash();    </span><br><span class="line">    tab = table;</span><br><span class="line">    hash = key.hashCode();</span><br><span class="line">    index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Creates the new entry.</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</span><br><span class="line">  tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">  count++; &#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>HashTable删除元素<br>如果删除的位置是某一单向链表的非头结点位置，则记录它的前一结点和下一结点，然后将前一结点的next指向它的下一结点。<br>如果是该链表的头结点的话，就将待删除结点的下一结点赋值给头结点。最后，设置待删除结点的值为null.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;?,?&gt; tab[] = table;</span><br><span class="line">     <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">     <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</span><br><span class="line">      <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;)tab[index];</span><br><span class="line">     <span class="keyword">for</span>(Entry&lt;K,V&gt; prev = <span class="keyword">null</span> ; e != <span class="keyword">null</span> ; prev = e, e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">     <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    prev.next = e.next;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = e.next;</span><br><span class="line">      &#125;</span><br><span class="line">      count--;</span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      e.value = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">return</span> oldValue;</span><br><span class="line">      &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="HashTable与HashMap的不同"><a href="#HashTable与HashMap的不同" class="headerlink" title="HashTable与HashMap的不同"></a>HashTable与HashMap的不同</h1><ol><li>基类不同：HashTable基于Dictionary类，而HashMap是基于AbstractMap。</li><li>null不同：HashMap可以允许存在一个为null和任意个为null的value,但是HashTable中的key和value都不允许为null。</li><li>线程安全：HashMap是单线程安全的，多线程不安全，而Hashtable是多线程安全的。</li><li>遍历不同：HashMap仅支持Iterator的遍历方式，而Hashtable支持Iterrator和Enumeration两种遍历放式。</li><li>存储结构： HashMap是数组+单向链表+红黑树，而HashTable是数组+单向链表</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Map的架构&quot;&gt;&lt;a href=&quot;#Map的架构&quot; class=&quot;headerlink&quot; title=&quot;Map的架构&quot;&gt;&lt;/a&gt;Map的架构&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/spurstong/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring MVC源码分析</title>
    <link href="https://github.com/spurstong/2019/09/14/Spring%20MVC%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://github.com/spurstong/2019/09/14/Spring MVC源码分析/</id>
    <published>2019-09-14T09:09:35.381Z</published>
    <updated>2019-10-13T13:00:24.358Z</updated>
    
    <content type="html"><![CDATA[<p>Spring MVC是Spring的一个重要模块，在使用Spring MVC的时候，需要在web.xml中配置DispatcherServlet,可以把它看成一个前端控制器的具体实现，还需要在Bean定义中配置Web请求和Controller(控制器)的对应关系，以及各种视图的展现方式。具体流程如下图所示。从中可以看出核心类是DispatcherServlet.<br><img src="https://pic3.zhimg.com/80/v2-959287eccaddab27a272efd0dfe38526_hd.jpg" alt></p><p>用文字描述执行流程如下：</p><ol><li>用户发送请求到前端控制器DispatcherServlet,</li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器</li><li>处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器（如果有则生成），一并返回DispatcherServlet.</li><li>DispatcherServlet通过HandlerAdapter处理器适配器调用处理器。</li><li>HandlerAdapter执行处理器（handler,也叫后端控制器）</li><li>Controller执行完成返回ModelAndView</li><li>HandlerAdapter将handler执行结果ModelAndView返回至DispatcherServlet.</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li><li>ViewReslover解析后返回具体View对象</li><li>DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）</li><li>DispatcherServlet响应用户</li></ol><h1 id="Spring-MVC框架的启动"><a href="#Spring-MVC框架的启动" class="headerlink" title="Spring MVC框架的启动"></a>Spring MVC框架的启动</h1><p>SpringMVC的核心是DispatchServlet，它是前端控制器，负责拦截客户端发过来的请求，然后解析请求进行分发。<br>DispatchServlet持有一个以自己的Servlet名称命名的IOC容器，它是一个WebApplicationContext对象。<br>Web容器启动时会加载DispatchServlet,每个Servlet在第一次加载时都会调用init()方法，但是DispatcherServlet本身没有这个方法，所以系统会去它父类寻找init()方法，最后在HttpServletBean中找到，调用。<br><code>HttpServletBean的init()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Initializing servlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取Servlet的初始化参数，对Bean属性进行配置</span></span><br><span class="line">   <span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">  PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line"> <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">  ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">  bw.registerCustomEditor(Resource.class, <span class="keyword">new</span> ResourceEditor(resourceLoader, getEnvironment()));</span><br><span class="line">  initBeanWrapper(bw);</span><br><span class="line">  bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">            logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line">  &#125;</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">   <span class="comment">//调用子类的initServletBean进行具体的初始化，在该类中它是有一个空方法，没有具体的实现。</span></span><br><span class="line">   <span class="comment">//该处调用的是FrameworkServlet类的</span></span><br><span class="line">  initServletBean();   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Servlet '"</span> + getServletName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//子类可以重写此项来执行自定义的初始化</span></span><br><span class="line"><span class="comment">//在调用此方法之前，将设置此servlet的所有bean属性。</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subclasses may override this to perform custom initialization. * All bean properties of this servlet will have been set before this * method is invoked. * &lt;p&gt;This default implementation is empty.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> ServletException if subclass initialization fails</span></span><br><span class="line"><span class="comment"> */</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FrameworkServlet的initServletBean（）</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">   getServletContext().log(<span class="string">"Initializing Spring FrameworkServlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line"> <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization started"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">long</span> startTime = System.currentTimeMillis();   </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//初始化上下文</span></span><br><span class="line">      <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">  initFrameworkServlet();</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ServletException | RuntimeException ex) &#123;</span><br><span class="line">      logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line"> <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">  logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization completed in "</span> +</span><br><span class="line">            elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>this.webApplicationContext = initWebApplicationContext();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//首先通过ServletContext获得Spring容器，因为子容器SpringMvc要和父容器进行关联</span></span><br><span class="line">   WebApplicationContext rootContext =</span><br><span class="line">         WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">  <span class="comment">//定义Springmvc容器wac       </span></span><br><span class="line">  WebApplicationContext wac = <span class="keyword">null</span>;  </span><br><span class="line">  <span class="comment">//判断容器是否由编程式传入（即是否已经存在了容器实例），存在的话直接赋值给wac. </span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">  wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line"> <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">         ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line"> <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">            <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line"> <span class="comment">// setting the parent context, setting the application context id, etc  if (cwac.getParent() == null) &#123;</span></span><br><span class="line">               <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line"> <span class="comment">// the root application context (if any; may be null) as the parent  cwac.setParent(rootContext);</span></span><br><span class="line">  &#125;</span><br><span class="line">            configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="comment">//在ServletContext中寻找是否有SpringMVC容器，初次运行是没有的</span></span><br><span class="line">      <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line"> <span class="comment">// has been registered in the servlet context. If one exists, it is assumed // that the parent context (if any) has already been set and that the // user has performed any initialization such as setting the context id  wac = findWebApplicationContext();</span></span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">   <span class="comment">//当war即没有被编程式注册到容器中，也没有在ServletContext找到，此时就要新建一个。</span></span><br><span class="line">  wac = createWebApplicationContext(rootContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line">      <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line"> <span class="comment">// support or the context injected at construction time had already been // refreshed -&gt; trigger initial onRefresh manually here.  synchronized (this.onRefreshMonitor) &#123;</span></span><br><span class="line">        <span class="comment">//到这里mvc的容器已经创建完毕，接着才是真正调用DispatcherServlet的初始化方法onRefresh</span></span><br><span class="line">          onRefresh(wac);</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line">      <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">   <span class="comment">//将SpringMVC容器存放到ServletContext中去，方便下次取出来。</span></span><br><span class="line">  String attrName = getServletContextAttributeName();</span><br><span class="line">  getServletContext().setAttribute(attrName, wac);</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">         <span class="keyword">this</span>.logger.debug(<span class="string">"Published WebApplicationContext of servlet '"</span> + getServletName() +</span><br><span class="line">               <span class="string">"' as ServletContext attribute with name ["</span> + attrName + <span class="string">"]"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> wac; &#125;</span><br></pre></td></tr></table></figure><p><code>DispatcherServlet的refresh（）</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//文件上传解析</span></span><br><span class="line">   initMultipartResolver(context);</span><br><span class="line">  <span class="comment">//本地解析</span></span><br><span class="line">  initLocaleResolver(context);</span><br><span class="line">  <span class="comment">//主题解析</span></span><br><span class="line">  initThemeResolver(context);</span><br><span class="line">  <span class="comment">//url请求解析</span></span><br><span class="line">  initHandlerMappings(context);</span><br><span class="line">  <span class="comment">//初始化真正调用controller方法的类</span></span><br><span class="line">  initHandlerAdapters(context);</span><br><span class="line">  <span class="comment">//异常解析</span></span><br><span class="line">  initHandlerExceptionResolvers(context);</span><br><span class="line">  <span class="comment">//视图解析</span></span><br><span class="line">  initRequestToViewNameTranslator(context);</span><br><span class="line">  initViewResolvers(context);</span><br><span class="line">  initFlashMapManager(context); &#125;</span><br></pre></td></tr></table></figure><p>其中，initHandlerMappings中把在Bean配置文字中配置好的handlerMapping从Ioc容器中取得。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initHandlerMappings</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.handlerMappings = <span class="keyword">null</span>;   <span class="keyword">if</span> (<span class="keyword">this</span>.detectAllHandlerMappings) &#123;</span><br><span class="line">      <span class="comment">// Find all HandlerMappings in the ApplicationContext, including ancestor contexts.</span></span><br><span class="line">   <span class="comment">//这里导入所有的HandlerMapping Bean,这些Bean可以在当前的DispatcherServlet的IOC容器中，也可能在其双亲上下文</span></span><br><span class="line">  Map&lt;String, HandlerMapping&gt; matchingBeans =</span><br><span class="line">            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"> <span class="keyword">if</span> (!matchingBeans.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">this</span>.handlerMappings = <span class="keyword">new</span> ArrayList&lt;&gt;(matchingBeans.values());</span><br><span class="line">  <span class="comment">// We keep HandlerMappings in sorted order.</span></span><br><span class="line">  AnnotationAwareOrderComparator.sort(<span class="keyword">this</span>.handlerMappings);</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//可以根据名称从当前的IOC容器中通过getBean</span></span><br><span class="line">         HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);</span><br><span class="line"> <span class="keyword">this</span>.handlerMappings = Collections.singletonList(hm);</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">         <span class="comment">// Ignore, we'll add a default HandlerMapping later.</span></span><br><span class="line">  &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有找到handermappings,那么需要为Servlet设定默认的handerMappings,这些默认的值可以设置在DispatcherServlet.properties中</span></span><br><span class="line">   <span class="comment">// Ensure we have at least one HandlerMapping, by registering</span></span><br><span class="line"> <span class="comment">// a default HandlerMapping if no other mappings are found.  if (this.handlerMappings == null) &#123;</span></span><br><span class="line">      <span class="keyword">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);</span><br><span class="line"> <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"No HandlerMappings found in servlet '"</span> + getServletName() + <span class="string">"': using default"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>整体流程简介：<br>web应用启动时扫描web.xml文件，扫描到DispatcherServlet,对其进行初始化调用DispatcherServlet父类的父类HttpServletBean的init()方法，把配置DispatcherServlet的初始化参数设置到DispatcherServlet中，调用子类FrameworkServlet中的initServletBean()方法，该方法创建SpringMVC容器实例并初始化容器，并且与spring父容器进行关联，使得mvc容器能访问Spring容器里的bean,之后调用子类DispatcherServlet的onRefresh()方法。<br>。</p><h1 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h1><p>Spring MVC的Control主要由HandlerMapping和HandlerAdapter两个组件提供。<br>HandlerMapping负责映射用户的URL和对应的处理类，HandlerMapping并没有规定这个URL与应用的处理类如何映射，在HandlerMapping接口中只定义了根据一个URL必须返回由HandlerExecutionChain代表的处理链，我们可以在这个处理链上添加任意的HandlerAdapter实例来处理这个URL对用的请求。<br>简单的说，HandlerMapping的作用就是根据当前请求找到对应的Handler,并将Handler（执行程序）与一堆HandlerInterceptor(拦截器)封装到HandlerExecutionChain对象中。<br>HandlerMapping是由DispatcherServlet调用， DispatcherServlet会从容器中取出所有HandlerMapping实例进行遍历，让HandlerMapping实例根据自己实现类的方式去尝试查找Handler。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring MVC是Spring的一个重要模块，在使用Spring MVC的时候，需要在web.xml中配置DispatcherServlet,可以把它看成一个前端控制器的具体实现，还需要在Bean定义中配置Web请求和Controller(控制器)的对应关系，以及各种视
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring AOP之AopProxy代理对象</title>
    <link href="https://github.com/spurstong/2019/09/04/Spring%20AOP%E7%9A%84AopProxy%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1/"/>
    <id>https://github.com/spurstong/2019/09/04/Spring AOP的AopProxy代理对象/</id>
    <published>2019-09-04T15:10:21.925Z</published>
    <updated>2019-09-07T08:00:18.794Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring的AOP模块，一个主要的部分是代理对象的生成，可以通过ProxyFactoryBean来完成，它封装了主要代理对象的生成过程。在这个生成过程中，可以使用JDK的Proxy和CGLIB两种生成情况。</p><a id="more"></a><h1 id="JDK动态代理与CGLIB区别"><a href="#JDK动态代理与CGLIB区别" class="headerlink" title="JDK动态代理与CGLIB区别"></a>JDK动态代理与CGLIB区别</h1><ol><li>jdk动态代理是利用反射机制生成的一个实现代理接口的<em>匿名类</em>，在调用具体方法前调用InvokeHandler来处理。</li><li>CGLIB动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</li><li>如果目标对象实现了接口，默认情况下采用JDK的动态代理实现AOP,但可以强制性使用CGLIB实现AOP</li><li>如果目标对象没有实现接口，必须采用cglib库，</li></ol><p>Tip: 什么是匿名类<br>即没有名称的类，其名称由Java编译器给出，一般为：外部类名称+$+匿名类顺序，名称也就是其他地方不能引用，不能实例化，只用一次，当然也就不能有构造器。</p><ul><li>匿名类可以继承父类的方法，也可以重写父类的方法。</li><li>匿名类可以访问外部类的成员变量和方法，匿名类的类体不可以声明为static成员变量和static方法。</li><li>匿名类由于是一个new的结果，所以其实可以赋值给一个父类对象。</li></ul><h1 id="配置ProxyFactoryBean"><a href="#配置ProxyFactoryBean" class="headerlink" title="配置ProxyFactoryBean"></a>配置ProxyFactoryBean</h1><ol><li>定义通知器Advisor,这个通知器应该作为一个Bean来定义，定义了需要对目标对象进行增强的切面行为，也就是Advice通知。</li><li>定义ProxyFactoryBean,作为另一个Bean来定义，它是封装AOP功能的主要类。需要设定相关属性。</li></ol><ul><li>interceptorNames: 设置为需要定义的通知器，要通过使用代理对象的拦截器机制起作用的。</li><li>target: 是需要用AOP通知器中的切面应用来增强的对象。</li></ul><h1 id="生成AopProxy代理对象"><a href="#生成AopProxy代理对象" class="headerlink" title="生成AopProxy代理对象"></a>生成AopProxy代理对象</h1><p>在ProxyFactoryBean中，需要为target目标对象生成Proxy代理对象，从而为AOP横切面的编织做好准备。从FactoryBean中获取对象，是以getObject()方法作为入口完成的。在该方法中，首先对通知器链进行初始化，封装了一系列的拦截器，这些拦截器都要从配置中读取，然后为代理对象的生成做好准备。在生成代理对象时，因为Spring中有singleton类型和prototype类型这两种不同的Bean,所以要对代理对象的生成做一个区分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">initializeAdvisorChain();</span><br><span class="line"><span class="keyword">if</span> (isSingleton()) &#123;</span><br><span class="line"><span class="keyword">return</span> getSingletonInstance();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.targetName == <span class="keyword">null</span>) &#123;</span><br><span class="line">logger.warn(<span class="string">"Using non-singleton proxies with singleton targets is often undesirable. "</span> +</span><br><span class="line"><span class="string">"Enable prototype proxies by setting the 'targetName' property."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newPrototypeInstance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先为Proxy代理对象配置Advisor链，在initializeAdvisorChain()方法中执行。<br>在该方法中它会首先通过this.advisorChainInitialized来判断通知器链是否已经初始化了，如果已经初始化了，就直接返回。其他情况下，通过<code>this.interceptorNames</code>来要添加的通知器名，然后通过该名从IOC容器中取得的通知器加入到拦截器链中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initializeAdvisorChain</span><span class="params">()</span> <span class="keyword">throws</span> AopConfigException, BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.advisorChainInitialized) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="keyword">this</span>.interceptorNames)) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No BeanFactory available anymore (probably due to serialization) "</span> +</span><br><span class="line"><span class="string">"- cannot resolve interceptor names "</span> + Arrays.asList(<span class="keyword">this</span>.interceptorNames));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Globals can't be last unless we specified a targetSource using the property...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.interceptorNames[<span class="keyword">this</span>.interceptorNames.length - <span class="number">1</span>].endsWith(GLOBAL_SUFFIX) &amp;&amp;</span><br><span class="line"><span class="keyword">this</span>.targetName == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSource == EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Target required after globals"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Materialize interceptor chain from bean names.</span></span><br><span class="line"><span class="keyword">for</span> (String name : <span class="keyword">this</span>.interceptorNames) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Configuring advisor or advice '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (name.endsWith(GLOBAL_SUFFIX)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!(<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ListableBeanFactory)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(</span><br><span class="line"><span class="string">"Can only use global advisors or interceptors with a ListableBeanFactory"</span>);</span><br><span class="line">&#125;</span><br><span class="line">addGlobalAdvisor((ListableBeanFactory) <span class="keyword">this</span>.beanFactory,</span><br><span class="line">name.substring(<span class="number">0</span>, name.length() - GLOBAL_SUFFIX.length()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// If we get here, we need to add a named interceptor.</span></span><br><span class="line"><span class="comment">// We must check if it's a singleton or prototype.</span></span><br><span class="line">Object advice;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.singleton || <span class="keyword">this</span>.beanFactory.isSingleton(name)) &#123;</span><br><span class="line"><span class="comment">// Add the real Advisor/Advice to the chain.</span></span><br><span class="line">advice = <span class="keyword">this</span>.beanFactory.getBean(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// It's a prototype Advice or Advisor: replace with a prototype.</span></span><br><span class="line"><span class="comment">// Avoid unnecessary creation of prototype bean just for advisor chain initialization.</span></span><br><span class="line">advice = <span class="keyword">new</span> PrototypePlaceholderAdvisor(name);</span><br><span class="line">&#125;</span><br><span class="line">addAdvisorOnChainCreation(advice, name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.advisorChainInitialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成singleton的代理对象在getSingletonInstance()中完成<br>如果它还没有被创建，则lazily creating</p><p>在Spring代理目标target时，其实并不是直接创建一个目标target的对象实例的，而是通过一个TargetSource类型的对象对目标target进行封装，Spring Aop获取目标对象始终是通过<code>TargetSource.getTarget()</code>方法进行的。</p><p>proxy（代理对象）代理的不是target,而是TargetSource</p><p>那么问题来了:为什么SpringAOP代理不直接代理target,而需要通过代理TargetSource(target的来源,其内部持有target),间接代理target呢?</p><p>通常情况下,一个proxy(代理对象)只能代理一个target,每次方法调用的目标也是唯一固定的target。但是,如果让proxy代理TargetSource,可以使得每次方法调用的target实例都不同(当然也可以相同,这取决于TargetSource实现)。这种机制使得方法调用变得灵活,可以扩展出很多高级功能,如:target pool(目标对象池)、hot swap(运行时目标对象热替换),等等。</p><p>Spring内置了多种TargetSource</p><ul><li>SingletonTargetSource<br>从这个目标源取得的目标对象是单例的，成员变量target缓存了目标对象，每次getTarget()都是返回这个对象。</li><li>PrototypeTargetSource<br>每次getTarget()将生成prototype类型的bean，即其生成的bean并不是单例的，因而使用这个类型的TargetSource时需要注意，封装的目标bean必须是prototype类型的。PrototypeTargetSource继承了AbstractBeanFactoryBasedTargetSource拥有了创建bean的能力。</li><li>CommonsPool2TargetSource<br>里CommonsPool2TargetSource也就是池化的TargetSource，其基本具有平常所使用的“池”的概念的所有属性，比如：最小空闲数，最大空闲数，最大等待时间等等.</li><li>ThreadLocalTargetSource<br>ThreadLocalTargetSource也就是和线程绑定的TargetSource，可以理解，其底层实现必然使用的是ThreadLocal</li></ul><blockquote><p>在上面简单介绍了有关TargetSource的有关知识，接下来将对<em>getSingletonInstance()</em>方法的有关步骤进行解释。</p></blockquote><ul><li><code>this.targetSource = freshTargetSource()</code>   返回要在创建代理时使用的TargetSource.<br>如果在interceptorNames列表的末尾没有指定目标，TargetSource将是该类的TargetSource成员。<br>否则，我们将获得目标bean，并在必要时将其封装在TargetSource中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TargetSource <span class="title">freshTargetSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.targetName == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"Not refreshing target: Bean name not specified in 'interceptorNames'."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.targetSource;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No BeanFactory available anymore (probably due to serialization) "</span> +</span><br><span class="line">               <span class="string">"- cannot resolve target with name '"</span> + <span class="keyword">this</span>.targetName + <span class="string">"'"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Refreshing target with name '"</span> + <span class="keyword">this</span>.targetName + <span class="string">"'"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">      Object target = <span class="keyword">this</span>.beanFactory.getBean(<span class="keyword">this</span>.targetName);</span><br><span class="line"> <span class="keyword">return</span> (target <span class="keyword">instanceof</span> TargetSource ? (TargetSource) target : <span class="keyword">new</span> SingletonTargetSource(target));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Class&lt;?&gt; targetClass = getTargetClass(); 根据AOP框架来判断需要代理的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="meta">@Nullable</span> <span class="keyword">public</span> Class&lt;?&gt; getTargetClass() &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.targetSource.getTargetClass(); &#125;</span><br></pre></td></tr></table></figure></li><li><p>setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader)); 这里设置代理对象的接口</p></li><li><p>super.setFrozen(this.freezeProxy); 初始化共享单例实例 ，当一个配置被冻结时，不能对advice进行更改</p></li><li><p>this.singletonInstance = getProxy(createAopProxy()); 通过createAopProxy返回的AopProxy来生成需要的Proxy</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getProxy</span><span class="params">(AopProxy aopProxy)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> aopProxy.getProxy(<span class="keyword">this</span>.proxyClassLoader); &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      activate();</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>); &#125;</span><br></pre></td></tr></table></figure><p>监听调用AdvisedSupportListener实现类的activated方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">activate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.active = <span class="keyword">true</span>;</span><br><span class="line"> <span class="keyword">for</span> (AdvisedSupportListener listener : <span class="keyword">this</span>.listeners) &#123;</span><br><span class="line">      listener.activated(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的代理对象的生成，是在ProxyFactoryBean的基类AdvisedSupport的实现中借助AopProxyFactory完成的，这个代理对象要么从JDK中生成，要么借助CGLIB获得。</p><p>这个AopProxyFactory是在初始化函数中定义的，使用的是DefaultAopProxyFactor。</p><ul><li>createAopProxy(AdvisedSupport config)<br>在该方法中会判断采用不同的策略来生成AopProxy</li></ul><p>如果targetClass是接口类，使用JDK来生成Proxy<br>如果不是接口类要生成Proxy,那么使用CGLIB来生成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">      Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"> <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">               <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来分别介绍两种不同的方式来产生AopProxy代理对象</p><ol><li>JdkDynamicAopProxy<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">  &#125;</span><br><span class="line">  # 获取AdvisedSupport类型对象的所有接口</span><br><span class="line">   Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">   # 接口是否定义了 equals和hashcode方法 正常是没有的</span><br><span class="line">  findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line"> <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>); &#125;</span><br></pre></td></tr></table></figure></li></ol><p>首先从advised对象中取得代理对象的代理接口配置，然后调用Proxy的newProxyInstance方法，得到最终的Proxy代理对象。</p><p>在生成代理对象时，需要指明三个参数，类加载器，代理接口和Proxy回调方法所在的对象。<br>在回调方法所在对象中，需要实现InvocationHandler接口，它定义了invoke方法，<br>对于JdkDynamimcAopProxy，它本身实现了InvocationHandler接口和invoke方法，这个invoke方法是Proxy代理对象的回调方法。</p><ol start="2"><li>CGLIB生成代理对象</li></ol><p>在该篇文章中就不讲解了，感兴趣的可以百度搜索。</p><p>注：本文大多数是对《Spring技术内幕》的阅读整理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Spring的AOP模块，一个主要的部分是代理对象的生成，可以通过ProxyFactoryBean来完成，它封装了主要代理对象的生成过程。在这个生成过程中，可以使用JDK的Proxy和CGLIB两种生成情况。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring之bean的生命周期及一些关于bean的知识总结</title>
    <link href="https://github.com/spurstong/2019/08/26/Spring%E4%B9%8Bbean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8AInitializingBean%E7%AD%89%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>https://github.com/spurstong/2019/08/26/Spring之bean的生命周期及InitializingBean等接口的作用/</id>
    <published>2019-08-26T15:06:29.952Z</published>
    <updated>2019-08-29T11:14:08.642Z</updated>
    
    <content type="html"><![CDATA[<p>首先介绍一下BeanFacory和ApplicationContext的区别。<br>它们都能创建IOC容器，但还有有些区别。</p><h1 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h1><p>BeanFactory是Spring中最底层的接口，提供了最简单的容器的功能，它有很多具体的实现类，例如：<br>DefaultListableBeanFactory、XmlBeanFactory和ApplicationContext。没错，ApplicationContext也是它的子类，继承了它的所有功能，并额外扩展了其他功能。</p><p>BeanFactory接口设计了getBean方法，可以取得Ioc容器中管理的bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Used to dereference a &#123;<span class="doctag">@link</span> FactoryBean&#125; instance and distinguish it from</span></span><br><span class="line"><span class="comment"> * beans &lt;i&gt;created&lt;/i&gt; by the FactoryBean. For example, if the bean named</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> myJndiObject&#125; is a FactoryBean, getting &#123;<span class="doctag">@code</span> &amp;myJndiObject&#125;</span></span><br><span class="line"><span class="comment"> * will return the factory, not the instance returned by the factory.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String FACTORY_BEAN_PREFIX = <span class="string">"&amp;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, @Nullable Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, @Nullable Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">String[] getAliases(String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从接口定义的方法可以看出，它主要可以做下面几件事：</p><ul><li>通过接口方法containsBean让用户能够判断容器是否含有指定名字的Bean</li><li>通过接口方法isSingleton来查询指定名字的Bean是否是Singleton类型的Bean。</li><li>通过接口方法isPrototype来查询指定名字的bean是否是prototype类型</li><li>通过接口方法getTpye来查询指定名字的bean的class类型</li><li>通过接口方法getAliases来查询指定了名字的Bean的所有别名</li></ul><p>BeanFactory在启动的时候不会去实例化bean, 等需要的时候才会到容器中去实例化。</p><h1 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h1><p>ApplicationContext是一个高级形态意义的IOC容器，是在BeanFactory的基础上添加额外功能。</p><ul><li>支持不同的信息源。因为它扩展了MessageSource接口，可以支持国际化的实现。</li><li>访问资源，这一特性体现在对ResourceLoader和Resource的支持上，可以从不同的地方得到Bean定义资源。</li><li>支持应用事件，消息发送，响应机制。</li><li>AOP（拦截器）</li><li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层</li></ul><p>ApplicationContext在启动的时候会加载非懒加载的单例bean,其它的类型只有在需要的时候才会被加载。</p><h1 id="bean的一生"><a href="#bean的一生" class="headerlink" title="bean的一生"></a>bean的一生</h1><p>bean的生命周期可以分为下面几步：</p><ol><li>实例化bean对象（通过构造方法或工厂方法）</li><li>设置对象属性（setter等）（依赖注入）</li><li>如果bean实现了BeanNameAware接口，工厂调用Bean的setBeanName方法传递Bean的ID,就是让实现这个接口的bean知道自己在Spring容器的名字。</li><li>如果bean实现了BeanFactoryAware接口，工厂调用setBeanFactory方法传入工厂自身，让bean获取配置自己的工厂。</li><li>将Bean实例传递给Bean的前置处理器的postProcessBeforeInitialization(Object bean, String beanname)方法。</li><li>调用Bean的初始化方法</li><li>将Bean实例传递给Bean的后置处理器的postProcessAfterInitialization(Object bean, String beanname)方法</li><li>使用bean</li><li>是否实现DisposableBean接口</li><li>容器关闭之前，调用Bean的销毁方法。</li></ol><h1 id="InitializingBean"><a href="#InitializingBean" class="headerlink" title="InitializingBean"></a>InitializingBean</h1><p>InitializingBean的作用是在bean初始化后执行定制化的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口只有一个方法<code>afterPropertiesSet</code>，此方法的调用入口是负责加载 spring bean 的<code>AbstractAutowireCapableBeanFactory</code>，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, @Nullable RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line"><span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">"afterPropertiesSet"</span>))) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Invoking afterPropertiesSet() on bean with name '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedExceptionAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line"><span class="keyword">throw</span> pae.getException();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;</span><br><span class="line">String initMethodName = mbd.getInitMethodName();</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">!(isInitializingBean &amp;&amp; <span class="string">"afterPropertiesSet"</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">!mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这段源码可以得出以下结论：</p><ol><li>spring为bean提供了两种初始化bean的方式，实现InitializingBean接口，实现afterPropertiesSet方法，或者在配置文件中通过init-method指定，两种方式可以同时使用</li><li>实现InitializingBean接口是直接调用afterPropertiesSet方法，比通过反射调用init-method指定的方法效率相对来说要高点。但是init-method方式消除了对spring的依赖</li><li>先调用afterPropertiesSet，再执行 init-method 方法，如果调用afterPropertiesSet方法时出错，则不调用init-method指定的方法。</li></ol><p>该方法较适用分布式项目数据库</p><h1 id="DisposableBean"><a href="#DisposableBean" class="headerlink" title="DisposableBean"></a>DisposableBean</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只定义了一个方法，destroy，看名字应该是对象在销毁时执行的。</p><p>在对象销毁的时候，会去调用<code>DisposableBean</code>的<code>destroy</code>方法。<br>同样，在对象销毁有一个参数配置<code>destroy-method</code>，和<code>init-method</code>相同，在调用销毁的时候，先执行 <code>DisposableBean</code>的<code>destroy</code>方法，后执行 <code>destroy-method</code>声明的方法。</p><h1 id="BeanFactoryPostProcessor与BeanPostProcessor的区别"><a href="#BeanFactoryPostProcessor与BeanPostProcessor的区别" class="headerlink" title="BeanFactoryPostProcessor与BeanPostProcessor的区别"></a>BeanFactoryPostProcessor与BeanPostProcessor的区别</h1><ul><li><p>BeanFactoryPostProcessor： BeanFactory后置处理器，是对BeanDefinition对象进行修改<br>BeanFactoryPostProcessor接口是针对bean容器的，它的实现类可以在当前BeanFactory初始化后，bean实例化之前修改bean的定义属性。<br>Spring允许BeanFactoryPostProcessor在容器实例化其他bean之前读取配置元数据，并可以根据需要进行修改，例如把bean的scope从singleton改为prototype,也可以把property的值修改掉。</p></li><li><p>BeanPostProcessor: Bean后置处理器，是对生成的bean对象进行修改</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//bean初始化之前调用</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//bean初始化之后调用</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanPostProcessor能在spring容器实例化bean之后，在执行bean的初始化方法前后，添加一些自己的处理逻辑。初始化方法包括以下两种：</p><ol><li>实现InitializingBean接口的bean,对应方法为afterPropertiesSet</li><li>xml定义中，通过init-method设置的方法</li></ol><p>BeanPostProcessor是BeanFactoryProcessor之后执行的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;首先介绍一下BeanFacory和ApplicationContext的区别。&lt;br&gt;它们都能创建IOC容器，但还有有些区别。&lt;/p&gt;
&lt;h1 id=&quot;BeanFactory&quot;&gt;&lt;a href=&quot;#BeanFactory&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring源码分析之lazy-init属性</title>
    <link href="https://github.com/spurstong/2019/08/26/Spring%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8Blazy-init/"/>
    <id>https://github.com/spurstong/2019/08/26/Spring源码分析之lazy-init/</id>
    <published>2019-08-26T14:43:00.000Z</published>
    <updated>2019-08-26T14:44:20.615Z</updated>
    
    <content type="html"><![CDATA[<p>在IOC容器的初始化过程中，主要的工作是对BeanDefinition的定位、载入、解析和注册。此时，也会对非懒加载的单例bean进行加载初始化，其他情况下，只有用户需要时才会被调用。</p><a id="more"></a><p>简单介绍一下IOC容器的初始化和依赖过程。</p><ol><li>资源定位：定位容器配置信息（xml,注解）</li><li>将定位到的资源保存到BeanDefinition中，这时并不创建Bean实例</li><li>将BeanDefinition注册到容器（BeanFactory具体实现类中）这时候还是有可能不创建Bean实例</li><li>第三步是否创建Bean实例依赖于lazy-init属性，该属性若为false则完成第三步时创建Bean实例然后进行依赖注入，若该属性为true则只有用到Bean实例时创建和完成依赖注入。</li></ol><p>现在开始进入正题，lazy-init是怎么实现的。</p><p>当IOC容器初始化时，首先要选择具体的ApplicationContext或 beanFactory,但现在一般选择ApplicationContext的子类，现在选择的是ClassPathXmlApplicationContext类。</p><p>先查看构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">String[] configLocations, <span class="keyword">boolean</span> refresh, @Nullable ApplicationContext parent)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(parent);</span><br><span class="line">setConfigLocations(configLocations);</span><br><span class="line"><span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">refresh();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后查看refresh()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个方法<code>finishBeanFactoryInitialization(beanFactory);</code>, 与lazy-init有关，<br>它会加载lazy-init为false且为单例的bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line"><span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line"><span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">getBean(weaverAwareName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中的beanFactory.preInstantiateSingletons()会初始化非懒加载的单例beans。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line"><span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">       # 触发开始加载所有非懒加载的单例beans</span><br><span class="line"><span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    # 获取bean定义</span><br><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"># 该bean不是抽象的，并且是单例的，不是懒加载的</span><br><span class="line"><span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">    # 判断是否是FactoryBean</span><br><span class="line"><span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line"><span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line"><span class="keyword">boolean</span> isEagerInit;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"># 如果是普通bean则进行bean初始化，依赖注入</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">       # 触发所有应用bean的post-initialization的回调</span><br><span class="line"><span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">Object singletonInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line"><span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在IOC容器的初始化过程中，主要的工作是对BeanDefinition的定位、载入、解析和注册。此时，也会对非懒加载的单例bean进行加载初始化，其他情况下，只有用户需要时才会被调用。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring的循环依赖问题</title>
    <link href="https://github.com/spurstong/2019/08/24/Spring%E7%9A%84%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/"/>
    <id>https://github.com/spurstong/2019/08/24/Spring的循环依赖问题/</id>
    <published>2019-08-24T09:17:32.806Z</published>
    <updated>2019-08-24T11:01:46.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是循环依赖"><a href="#什么是循环依赖" class="headerlink" title="什么是循环依赖"></a>什么是循环依赖</h1><p>循环依赖也是循环引用，就是两个或多个Bean之间存在依赖关系，形成闭环<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/Spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96/1.png" alt="1.png"><br>当Spring容器在创建A时，会发现其引用了B,从而会去创建B。同样的，在创建B时，会先创建C,而在创建C时，又先去创建A。最后A、B和C之间相互等待，谁都没有创建成功。</p><h1 id="如何检测到存在循环依赖"><a href="#如何检测到存在循环依赖" class="headerlink" title="如何检测到存在循环依赖"></a>如何检测到存在循环依赖</h1><p>可以Bean在创建的时候给其打个标记，如果递归调用回来发现正在创建的话，即可说明循环依赖</p><h1 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h1><p>Spring的循环依赖的理论实际上是基于Java的引用传递，当我们获取到对象的引用时，对象的field属性是可以延后设置的（但是构造器必须是在获取引用之前）</p><p>在上篇文章讲解Bean的加载时，就使用到了循环依赖问题，但没有细讲。<br>在上文中也提到在依赖注入时有两个重要的方法。</p><ul><li>createBeanInstance: 实例化，其实也就是调用对象的构造方法实例化对象</li><li>populateBean: 填充属性，这一步主要是多bean的依赖属性进行填充</li></ul><p>Spring 仅为单例模式下的Bean进行循环依赖的解决，但没有为原型模式下的Bean提供解决方法，会直接报错。</p><p>要解决循环依赖问题应该从初始化过程入手，对于单例而言，在Spring整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存放在Cache中，Spirng为了解决单例模式下的循环依赖问题，使用了<em>三级缓存</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultSingletonBeanRegistry</span> <span class="keyword">extends</span> <span class="title">SimpleAliasRegistry</span> <span class="keyword">implements</span> <span class="title">SingletonBeanRegistry</span> </span>&#123;</span><br><span class="line">   <span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line">   <span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);          </span><br><span class="line">  <span class="comment">/** Cache of early singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><ul><li>singletonFactories:  一级缓存，用于存放完全初始化好的bean</li><li>earlySingletonObjects：二级缓存，存放原始的bean对象（还没有填充属性），用于解决循环依赖</li><li>singletonFactories:  三级缓存，存放bean工厂对象，用于解决循环依赖</li></ul><p>在getSingleton()中对单例bean的获取时就考虑到循环问题的解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先解释一下中间代码的一个判别方法 isSingletonCurrentlyInCreation(beanName)</p><p>它会判断当前的单例bean是否正字创建中，也就是还没有初始化完成。<br>比如：A的构造器依赖了B对象所以要先去创建B对象，或者在Ade populateBean过程中依赖了B对象，也要先去创建B对象，此时的A就是处于创建中的状态。</p><p>在整个过程中，Spring会先从一级缓存singletonObjects中尝试获取缓存的bean,如果没有，<br>则从二级缓存earlySingletonObjects中获取。<br>如果还没有且允许可以从singletonFactories中通过getObjects获取对象时，<br>则从三级缓存singletonFactories中获得该bean的工厂类，并通过getObjects（）方法获取到。</p><p>如果从第三缓存中获取到，则需要将该bean从singletonFactories移除，并加入到earlySingletonObjects中，也就说该bean从第三缓存降到了第二缓存。</p><p>此时，可能会有疑问，那个第三缓存中的bean的factory类是什么时候创建存储的呢，实际上在上面文章中也有提到，在本文中再仔细讲解一下，加强前后的逻辑性。</p><p>在创建bean时会调用<code>AbstractAutowireCapableBeanFactory.doCreateBean()</code>：<br>中间这一一步：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">        isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">                <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为避免后期循环依赖，可以在bean初始化完成前将创建实例的ObjectFactory加入工厂</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * getEarlyBeanReference(beanName, mbd, bean)方法：</span></span><br><span class="line"><span class="comment">     * 对bean再一次依赖引用，主要应用SmartInstantiationAwareBeanPostProcessor</span></span><br><span class="line"><span class="comment">     * 其中我们熟知的AOP就是在这里将advice动态织入bean中，若没有则直接返回bean，不做任何处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 getEarlyBeanReference 函数中并没有太多的逻辑处理，或者说除了后处理器的调用外没有别的处理工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是循环依赖&quot;&gt;&lt;a href=&quot;#什么是循环依赖&quot; class=&quot;headerlink&quot; title=&quot;什么是循环依赖&quot;&gt;&lt;/a&gt;什么是循环依赖&lt;/h1&gt;&lt;p&gt;循环依赖也是循环引用，就是两个或多个Bean之间存在依赖关系，形成闭环&lt;br&gt;&lt;img src=&quot;h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring源码之Bean加载</title>
    <link href="https://github.com/spurstong/2019/08/24/Spring%E6%BA%90%E7%A0%81%E4%B9%8BBean%E5%8A%A0%E8%BD%BD/"/>
    <id>https://github.com/spurstong/2019/08/24/Spring源码之Bean加载/</id>
    <published>2019-08-24T07:29:00.000Z</published>
    <updated>2019-08-25T15:08:34.392Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的文章中已经讲解了IOC容器的创建和Bean的注册，将XML文件中的信息封装成了BeanDefinition类型存储起来，但现在还不能正常使用，此时就需要进行Bean的加载，将BeanDefinition转化成可用的Object。<br>实际上这也是个依赖注入的过程，在IOC初始化过程中，会初始化单例bean，但当lazy-init=“true”或者bean为原型bean时，只有在需要时，才会被依赖注入。即当应用程序需要依赖的bean时，它就会向IOC容器进行索要，然后IOC容器就会将该Bean注入到应用程序中。</p><a id="more"></a><h1 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h1><p>本文以ClassPathXmlApplicationContext为例，进行源码分析。<br>它继承了AbstractApplicationContext,并调用getBean,它实际上就是触发依赖注入的地方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">assertBeanFactoryActive();</span><br><span class="line"><span class="keyword">return</span> getBeanFactory().getBean(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根据name查找bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对doGetBean方法进行分层解读。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br></pre></td></tr></table></figure><p>首先对传入的name进行判断处理，如果名字开头是‘&amp;’,则需要去掉。<br>经过处理之后，获取到bean的真正名字。<br>然后调用 <code>Object sharedInstance = getSingleton(beanName);</code>来获取对象。<br>在该方法中主要有这几个重要的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">缓存当前已经实例化的单例对象</span><br><span class="line"><span class="comment">/** Cache of singleton objects: bean name --&gt; bean instance */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">当前正在创建的bean</span><br><span class="line"><span class="comment">/** Names of beans that are currently in creation */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; singletonsCurrentlyInCreation =</span><br><span class="line">Collections.newSetFromMap(<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">16</span>));</span><br><span class="line">缓存每个Bean的创建工厂实例</span><br><span class="line"><span class="comment">/** Cache of singleton factories: bean name --&gt; ObjectFactory */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">singletonObject = singletonFactory.getObject();</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先从缓存map中查询已经初始化的单例对象，如果查询到了，就直接返回该对象。</li><li>然后在缓存的map中没有该对象，并且是在正在创建的bean的map中，则执行下一步</li><li>再一次尝试从正在创建的bean的map中获取该实例，如果还是为null,就要进行创建了</li><li>先获取创建该Bean的工厂类，然后调用工厂类的getObject方法获取Bean实例，并将该bean实例缓存到map中，并将创建该Bean的工厂类从singletonFactories中移除。</li></ol><p>从上面可以看出Bean的创建和获取实际上是在另一个地方执行的</p><p>note: 实例化bean和依赖注入是在AbstractBeanFactory中进入，但实际的操作是在<em>AbstractAutowireCapableBeanFactory</em>中实现的。</p><p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/Spring%E6%BA%90%E7%A0%81%E4%B9%8BBean%E5%88%9D%E5%A7%8B%E5%8C%96/1.png" alt="1.png"></p><p>上图中是Bean实例化的时序图<br>在AbstractAutowireCapableBeanFactory中调用createBean,createBean不但生成了需要的Bean,还对Bean初始化进行了处理，比如实现了在BeanDefinition中的init-method属性定义，Bean后置处理器。</p><p>上述代码中最重要的一步就是<code>singletonFactory.getObject();</code>,通过这步来获取初始化的Object对象。<br>singletonFactory保存的是每个bean的工厂方法，那么是什么时候创建这个的呢？</p><h2 id="AbstractAutowireCapableBeanFactory中-bean的创建"><a href="#AbstractAutowireCapableBeanFactory中-bean的创建" class="headerlink" title="AbstractAutowireCapableBeanFactory中 bean的创建"></a>AbstractAutowireCapableBeanFactory中 bean的创建</h2><p>addSingletonFactory方法，在这里添加了每个Bean的工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addSingletonFactory</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">Assert.notNull(singletonFactory, <span class="string">"Singleton factory must not be null"</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">this</span>.singletonObjects.containsKey(beanName)) &#123;</span><br><span class="line"><span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br><span class="line"><span class="keyword">this</span>.earlySingletonObjects.remove(beanName);</span><br><span class="line"><span class="keyword">this</span>.registeredSingletons.add(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并在<em>AbstractAutowireCapableBeanFactory</em>中的doCreateBean方法中有该逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate the bean.</span></span><br><span class="line">BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"><span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line"><span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">&#125;</span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>从上面可以看出，与依赖注入关系最密切的是两个方法，createBeanInstance和populateBean</strong></p><p>下面分别介绍这两个方法。</p><h2 id="createBeanInstance"><a href="#createBeanInstance" class="headerlink" title="createBeanInstance"></a>createBeanInstance</h2><p>如果是Singleton,先把缓存中的同名Bean清楚，否则，需要执行<code>createBeanInstance(beanName, mbd, args)</code>来创建新的实例。</p><p>在createBeanInstance中生成了Bean所包含的Java对象，这个对象的生成有很多不同的方式，可以通过方法生成，也可以通过容器的autowire特性生成，这些生成方式都是由相关的BeanDefinition来指定的。</p><p>Bean依赖注入的方法主要有三种：</p><ul><li>构造方法注入</li><li>stetter方法注入</li><li>注解方式注入<br>但从代码中也能看到也有工厂方法注入</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Supplier&lt;?&gt; instanceSupplier = mbd.getInstanceSupplier();</span><br><span class="line"><span class="keyword">if</span> (instanceSupplier != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> obtainFromSupplier(instanceSupplier, beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line"><span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">resolved = <span class="keyword">true</span>;</span><br><span class="line">autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (resolved) &#123;</span><br><span class="line"><span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Candidate constructors for autowiring?</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line"><span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line"><span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先执行resolveBeanClass(mbd, beanName)来确认需要创建的Bean实例的类可以实例化</li><li>然后判断该类的权限</li><li>return instantiateUsingFactoryMethod(beanName, mbd, args);  使用工厂方法对Bean进行实例化</li><li>根据是否有构造参数来选择实例化方法<ul><li>采用默认的构造函数      instantiateBean(beanName, mbd)</li><li>采用有参数的构造函数   autowireConstructor(beanName, mbd, ctors, args)</li></ul></li></ul><p>最常见的实例化过程</p><h2 id="instantiateBean-beanName-mbd"><a href="#instantiateBean-beanName-mbd" class="headerlink" title="instantiateBean(beanName, mbd)"></a>instantiateBean(beanName, mbd)</h2><p>接下来分析用默认构造函数的实例方法<code>instantiateBean(beanName, mbd)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object beanInstance;</span><br><span class="line"><span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">beanInstance = AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt;</span><br><span class="line">getInstantiationStrategy().instantiate(mbd, beanName, parent),</span><br><span class="line">getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">&#125;</span><br><span class="line">BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">initBeanWrapper(bw);</span><br><span class="line"><span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Instantiation of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中有一个重要的一个步骤<code>getInstantiationStrategy().instantiate(mbd, beanName, parent);</code><br>采用默认的实例化策略对Bean进行实例化，默认的实例化策略是CglibSubclassingInstantiationStrategy,也讲就是使用CGLIB对Bean进行实例化，它提供了一系列的API来提供生成和转换Java的字节码的字节码的功能。</p><p>在Ioc容器中，要了解怎么使用CGLIB来生成Bean对象，需要看一下SimpleInstantiationStrategy类。这个Strategy是Spring用来生成Bean对象的默认类。</p><h2 id="SimpleInstantiationStrategy"><a href="#SimpleInstantiationStrategy" class="headerlink" title="SimpleInstantiationStrategy"></a>SimpleInstantiationStrategy</h2><p>它提供了两种实例化Java对象的方法，一种是通过BeanUtils,它使用了JVM的反射功能，一种是通过前面提到的CGLIb来生成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, @Nullable String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line"><span class="comment">// Don't override the class with CGLIB if no overrides.</span></span><br><span class="line"><span class="keyword">if</span> (!bd.hasMethodOverrides()) &#123;</span><br><span class="line">Constructor&lt;?&gt; constructorToUse;</span><br><span class="line"><span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line"><span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line"><span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"Specified class is an interface"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">constructorToUse = AccessController.doPrivileged(</span><br><span class="line">(PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;) clazz::getDeclaredConstructor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">constructorToUse = clazz.getDeclaredConstructor();</span><br><span class="line">&#125;</span><br><span class="line">bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"No default constructor found"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Must generate CGLIB subclass.</span></span><br><span class="line"><span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述部分是创建一个Bean实例，为后面的添加具体工厂时创造条件。</p><h2 id="addSingletonFactory-beanName-gt-getEarlyBeanReference-beanName-mbd-bean"><a href="#addSingletonFactory-beanName-gt-getEarlyBeanReference-beanName-mbd-bean" class="headerlink" title="addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));"></a>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</h2><p>在具体添加什么类型的工厂类时，是通过<code>getEarlyBeanReference(beanName, mbd, bean)</code>方法来进行创建的。<br>上面参数的bean就是上述部分所创建的。<br>从官方文档注释中可以看出这个方法很重要。<br>它获取对指定bean的早期访问的引用。<br>通常用于解决循环引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* Obtain a reference <span class="keyword">for</span> early access to the specified bean, </span><br><span class="line">* typically <span class="keyword">for</span> the purpose of resolving a circular reference.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;</span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>mbd.isSynthetic()   –&gt;  此bean的定义是否为合成的，即，没有被应用本身定义。</li><li>hasInstantiationAwareBeanPostProcessors() -&gt;  该工厂是否持有一个InstantiationAwareBeanPostProcessor类</li></ul><p>note: InstantiationAwareBeanPostProcessor接口继承了beanPostProcessor接口，主要用于在于目标对象的实例化过程中需要处理的事情，包括实例化对象的前后过程以及实例的属性设置。</p><h2 id="doCreateBean中的populateBean方法"><a href="#doCreateBean中的populateBean方法" class="headerlink" title="doCreateBean中的populateBean方法"></a>doCreateBean中的populateBean方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line">Object exposedObject = bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是对Bean的初始化，依赖注入往往在这里发生，这个exposedObject在初始化处理完成后会返回作为依赖注入完成后的Bean。<br>前面Bean对象已经实例化了，怎么对这些对象进行处理，将这些Bean对象的依赖关系设置好，完成整个依赖注入过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable BeanWrapper bw)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (mbd.hasPropertyValues()) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line"><span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line"><span class="comment">// to support styles of field injection.</span></span><br><span class="line"><span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line"><span class="comment">//如果属性没有注入，返回false,执行里面的代码</span></span><br><span class="line"><span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//开始进行依赖注入过程，先处理autowire的注入</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line">根据Bean的名字或者类型来完成Bean的autowire</span><br><span class="line"><span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.getResolvedAutowireMode() == AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">&#125;</span><br><span class="line">pvs = newPvs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line"><span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != AbstractBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">pvs = mbd.getPropertyValues();</span><br><span class="line">&#125;</span><br><span class="line">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line"><span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pvs != <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="comment">//对属性进行注入</span></span><br><span class="line">   </span><br><span class="line">applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>!mbd.isSynthetic()</em>默认是true, mbd.isSynthetic()对于Pointcut 的bean来说是true的。</p><p>在applyPropertyValues方法中会调用BeanDefinitionValueReslover，来完成对BeanDefinition的解析，<br>之后的解析部分就不再讲解了，感兴趣的话可以再去看看。</p><h1 id="bean-getObjectForBeanInstance-sharedInstance-name-beanName-null"><a href="#bean-getObjectForBeanInstance-sharedInstance-name-beanName-null" class="headerlink" title="bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);"></a>bean = getObjectForBeanInstance(sharedInstance, name, beanName, null);</h1><p>这一步是完成FactoryBean的相关处理，以取得FactoryBean的生产结果。<br>BeanFacotry和FactoryBean的区别将在另一篇中进行介绍。</p><h1 id="最初步方法doGetBean的另一判断分支"><a href="#最初步方法doGetBean的另一判断分支" class="headerlink" title="最初步方法doGetBean的另一判断分支"></a>最初步方法doGetBean的另一判断分支</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Fail if we're already creating this bean instance:</span></span><br><span class="line"><span class="comment">// We're assumably within a circular reference.</span></span><br><span class="line"><span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里对IOC容器中的BeanDefinition是否存在进行检查，检查是否能在当前的BeanFactory中取得需要的Bean,如果在当前的工厂中取不到，则到双亲BeanFactory中去取，如果当前的双亲工厂取不到，就顺着双亲BeanFactory链一直向上查找。</span></span><br><span class="line">BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line"><span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">String nameToLookup = originalBeanName(name);</span><br><span class="line"><span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123;</span><br><span class="line"><span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line"><span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line"><span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">markBeanAsCreated(beanName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Guarantee initialization of beans that the current bean depends on.             //获取当前Bean的所有依赖Bean,这样会触发getBean的递归调用，一直取到一个没有任何依赖的Bean为止</span></span><br><span class="line">String[] dependsOn = mbd.getDependsOn();</span><br><span class="line"><span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line"><span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">registerDependentBean(dep, beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">getBean(dep);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create bean instance.</span></span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line"><span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line"><span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">destroySingleton(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line">                <span class="comment">//创建protitype bean </span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line"><span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line">prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">String scopeName = mbd.getScope();</span><br><span class="line"><span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line"><span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">beforePrototypeCreation(beanName);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">afterPrototypeCreation(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line"><span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line"><span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前面的文章中已经讲解了IOC容器的创建和Bean的注册，将XML文件中的信息封装成了BeanDefinition类型存储起来，但现在还不能正常使用，此时就需要进行Bean的加载，将BeanDefinition转化成可用的Object。&lt;br&gt;实际上这也是个依赖注入的过程，在IOC初始化过程中，会初始化单例bean，但当lazy-init=“true”或者bean为原型bean时，只有在需要时，才会被依赖注入。即当应用程序需要依赖的bean时，它就会向IOC容器进行索要，然后IOC容器就会将该Bean注入到应用程序中。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring源码之bean标签的解析与注册</title>
    <link href="https://github.com/spurstong/2019/08/23/Spring%E6%BA%90%E7%A0%81%E4%B9%8Bbean%E6%A0%87%E7%AD%BE%E7%9A%84%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%B3%A8%E5%86%8C/"/>
    <id>https://github.com/spurstong/2019/08/23/Spring源码之bean标签的解析与注册/</id>
    <published>2019-08-23T07:35:00.000Z</published>
    <updated>2019-08-23T07:57:43.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在上一篇中，最后讲到了parseDefaultElement方法和parseCustomElement方法，对标签进行解析。先讲一下对bean标签的解析。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">            BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">            <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">                bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">                    BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">                    getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">                            bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Send registration event.</span></span><br><span class="line">                getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>首先委托BeanDefinitionDelegate类的parseBeanDefinitionElement方法进行元素解析，返回BeanDefinitionHolder类型的实例bdHolder,此时，bdHolder就已经包含配置文件中的配置的各种属性了，例如：class、name、id</li><li>当返回的bdHolder不为空时若存在默认标签的子节点下再有自定义属性，还需要对自定义标签进行解析。</li><li>解析完成后，需要对解析后的bdHolder进行注册，同样，注册操作委托给了BeanDefinitionReaderUtils的registerDefinition方法。</li><li>最后发出响应事件，通知相关的监听器，这个bean已经加载完成了。<br>下面依次解释每个步骤的含义。</li></ol><h1 id="解析BeanDefinition"><a href="#解析BeanDefinition" class="headerlink" title="解析BeanDefinition"></a>解析BeanDefinition</h1><p>先解释一个类BeanDefinitionHolder，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionHolder</span> <span class="keyword">implements</span> <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> BeanDefinition beanDefinition;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Nullable</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String[] aliases;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BeanDefinitionHolder</span><span class="params">(BeanDefinition beanDefinition, String beanName, @Nullable String[] aliases)</span> </span>&#123;</span><br><span class="line">                Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line">                Assert.notNull(beanName, <span class="string">"Bean name must not be null"</span>);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinition = beanDefinition;</span><br><span class="line">                <span class="keyword">this</span>.beanName = beanName;</span><br><span class="line">                <span class="keyword">this</span>.aliases = aliases;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看出，BeanDefinition是BeanDefinition的一个持有者，并存储bean的姓名和别名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, @Nullable BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//解析id属性</span></span><br><span class="line">            String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">         <span class="comment">//解析name属性</span></span><br><span class="line">            String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">         <span class="comment">//分割name属性</span></span><br><span class="line">            List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">                String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">                aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String beanName = id;</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">                beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"No XML 'id' specified - using '"</span> + beanName +</span><br><span class="line">                            <span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">            <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                                    beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                            <span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">                            <span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">                            <span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">                            String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                            <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                    beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                                    !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                                aliases.add(beanClassName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                            logger.debug(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +</span><br><span class="line">                                    <span class="string">"using generated bean name ["</span> + beanName + <span class="string">"]"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                        error(ex.getMessage(), ele);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要步骤：</p><ol><li>提取元素中的id以及name属性</li><li>进一步解析其他所有属性并统一封装至GenericBeanDefinition类型中的实例中。</li><li>如果监测到bean没有指定的beanName,那儿使用默认规则为此Bean生成beanName</li><li>将获取到的信息封装到BeanDefinitionHolder的实例中。</li></ol><p>先简单介绍BeanDefinition这个接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A BeanDefinition describes a bean instance, which has property values,</span></span><br><span class="line"><span class="comment"> * constructor argument values, and further information supplied by</span></span><br><span class="line"><span class="comment"> * concrete implementations.</span></span><br><span class="line"><span class="comment"> *</span></span><br></pre></td></tr></table></figure><p>上面是源码文档解释，从上可以看出，它描述了一个bean实例，有属性值和构造函数参数值，具体的信息由具体的子类来实现。<br>在配置文件中&lt;bean&gt;元素拥有class、scope、lazy-init等配置属性，BeanDefinition则提供了相应的beanClass、Scope、lazyInit属性，BeanDefinition和&lt;bean&gt;中的元素一一对应。<br>具体的类RootBeanDefinition、GenericBeanDefinition和ChildBeanDefinition。<br>其中RootBeanDefinition是最常用的类，在配置文件中可以配置父&lt;bean&gt;和子&lt;bean&gt;,子&lt;bean&gt;用childBeanDefinition表示，没有子类时，直接用RootBeanDefinition表示。</p><p>Spring通过BeanDefinition将配置文件中的&lt;bean&gt;配置信息转化为容器的内部表示，并将这些BeanDefinition注册到BeanDefinitionRegistry中。Spring容器中的BeanDefinitionRegistry就像是Spring配置信息的内存数据库，主要是以map的形式保存，后续操作直接从BeanDefinitionRegistry中读取配置信息。</p><p><em>BeanDefinitionParserDelegate</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* Stateful delegate <span class="class"><span class="keyword">class</span> <span class="title">used</span> <span class="title">to</span> <span class="title">parse</span> <span class="title">XML</span> <span class="title">bean</span> <span class="title">definitions</span>.</span></span><br><span class="line"><span class="class"> * <span class="title">Intended</span> <span class="title">for</span> <span class="title">use</span> <span class="title">by</span> <span class="title">both</span> <span class="title">the</span> <span class="title">main</span> <span class="title">parser</span> <span class="title">and</span> <span class="title">any</span> <span class="title">extension</span></span></span><br></pre></td></tr></table></figure><p>从上面的定义中可以看出它是代表类，用于处理XML Bean定义的类，干的都是脏活累活。<br> import/alias/bean等element以及element的子节点以及属性都是它解析并且填充到BeanDefinition中然后使用ReaderContext中的Registry(实际就是DefaultListableBeanFactory)来将该BeanDefinition注册。</p><h1 id="Bean的注册"><a href="#Bean的注册" class="headerlink" title="Bean的注册"></a>Bean的注册</h1><p>Spring提供了BeanFactory对Bean进行获取，但Bean的注册和管理并不是在BeanFactory中进行，而是在BeanDefinitionRegistry中进行，这里BeanFactory只提供了查阅的功能。<br>Spring的Bean信息注册保存在一个个BeanDefinition中的。</p><p>我们以ClassPathXmlApplicationContext为例</p><ol><li>在它的构造函数中主要的逻辑方法有两个。<br>首先调用<em>setConfigLocations()</em>来设置配置文件路径并可以修改配置文件中的属性值。<br>然后调用<code>refresh()</code>方法。它是代码的核心，用来对Bean进行注册和初始化。</li><li>在refresh()方法中,主要有下面几个步骤</li></ol><ul><li>BeanFactory的初始化，并且加载配置文件中相关的bean信息。</li><li>调用<em>postProcessBeanFactory(beanFactory)</em>抽象方法，用于供给子类对已经生成的BeanFactory的一些信息进行定制，<em>registerBeanPostProcessors</em>对BeanPostProcessor进行注册。<br>BeanPostProcessor是一个扩展点，有两个方法，分别对应IOC容器对对象初始化前的操作和初始化后的操作。</li><li>初始化国际化信息</li><li>注册和调用相关的监听器</li><li>实例化注册的bean信息</li></ul><ol start="3"><li>对于bean的注册，我们需要关注<em>refreshBeanFactory()</em>方法，<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123; <span class="comment">// 如果BeanFactory已经创建则对其进行销毁</span></span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建BeanFactory实例</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId()); <span class="comment">// 为当前BeanFactory设置一个标识id</span></span><br><span class="line">        customizeBeanFactory(beanFactory); <span class="comment">// 设置BeanFacotry的定制化属性信息</span></span><br><span class="line">        loadBeanDefinitions(beanFactory); <span class="comment">// 加载xml文件信息</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>从中可以看出中间最重要的方法是<em>loadBeanDefinitions</em><br>将加载XML文件中的bean信息交给<strong>XmlBeanDefinitionReader</strong>来处理。<br>它会依次读取每个xml配置文件中的bean信息，<br>将xml文件转化为一个InputStream,再转化为InputSource,进而转化为一个Document对象，该对象保存着各个XML文件中各个节点和子节点的相关信息，然后获取到Document的根节点信息，调用<code>BeanDefinitionDocumentReader.registerBeanDefinitions(root)</code>进行注册。<br>然后开始解析xml文件，封装成BeanDefinition并完成注册，该点在文章开头已经讲解。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在上一篇中，最后讲到了parseDefaultElement方法和parseCustomElement方法，对标签进行解析。先讲一下对bea
      
    
    </summary>
    
    
  </entry>
  
</feed>
