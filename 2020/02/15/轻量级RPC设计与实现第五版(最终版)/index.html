<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 轻量级RPC设计与实现第五版(最终版) · 房东的小黑</title><meta name="description" content="轻量级RPC设计与实现第五版(最终版) - Mara Tong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/spurstong/atom.xml" title="房东的小黑"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/black.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">JIANSHU</a></li><li class="nav-list-item"><a href="https://github.com/spurstong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">房东的小黑黑</a></li></ul><div class="mySign">路途虽遥远，将来更美好</div></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">轻量级RPC设计与实现第五版(最终版)</h1><div class="post-info">2020年2月15日</div><div class="post-content"><p>在最近一段时间里，通过搜集有关资料加上自己的理解，设计了一款轻量级RPC,起了一个名字<strong>lightWeightRPC</strong>。它拥有一个RPC常见的基本功能。主要功能和特点如下：</p>
<ul>
<li>利用Spring实现依赖注入与参数配置</li>
<li>利用Netty来实现客户端与服务端的远程通信</li>
<li>利用Hessian来实现序列化</li>
<li>设置Zookeeper作为注册中心</li>
<li>新设监控器，通过心跳机制来判断服务端与监控器的网络连接状况，当出现不稳定时，认为服务端出现了问题，在注册中心删除相关的服务信息。</li>
<li>利用Netty的Promise来实现异步的传送</li>
<li>构建线程池来管理发送的请求线程</li>
<li>添加服务缓存机制，在注册中心宕机的情况下仍能进行服务消费。</li>
<li>支持服务扩展点发现机制（SPI）,对Spring的SPI机制进行改进，解决了依赖注入问题。</li>
<li>在客户端从注册中心获取服务时，添加监听器，当注册中心对应节点发生变化时通知客户端修改本地缓存信息。</li>
</ul>
<p>以上是<strong>lightWeightRPC</strong>的全部功能，本版本添加的内容就是最后一个功能，为服务节点添加监听器。<br>因为之前在本地添加了持久化的缓存，当服务消费时会先从缓存中查找信息，查不到再到注册中心查找，但是当服务地址等信息发生变化时，如果不对缓存信息进行修改就可能会发生错误。所以在本版本中为服务节点添加了监听器。</p>
<h1 id="如何添加监听器"><a href="#如何添加监听器" class="headerlink" title="如何添加监听器"></a>如何添加监听器</h1><p>当客户端首次从注册中心获取服务信息时，会对有关服务节点添加监听器,具体方法在<code>addListenerForService</code>，设置完监听后，再获取相关服务节点信息，并封装在URL类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;URL&gt; <span class="title">getServiceInfo</span><span class="params">(String interfaceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            addListenerForService(interfaceName);</span><br><span class="line">            System.out.println(<span class="string">"开始查找服务节点："</span> + getPath(interfaceName));</span><br><span class="line">            List&lt;String&gt; urlList = client.getChildren().forPath(<span class="string">"/"</span> + interfaceName);</span><br><span class="line">            System.out.println(<span class="string">"结果："</span> + urlList);</span><br><span class="line">            List&lt;URL&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(String serviceUrl : urlList) &#123;</span><br><span class="line">                String[] urls = serviceUrl.split(<span class="string">":"</span>);</span><br><span class="line">                String implClassName = get(interfaceName, serviceUrl);</span><br><span class="line">                System.out.println(implClassName);</span><br><span class="line">                result.add(<span class="keyword">new</span> URL(urls[<span class="number">0</span>], Integer.valueOf(urls[<span class="number">1</span>]), interfaceName, implClassName));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在添加监听器时主要是<code>PathChildrenCache</code>类，当节点发生变化时会触发<code>childEvent</code>事件，根据不同的状态采取不同的策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> PathChildrenCache childrenCache = <span class="keyword">new</span> PathChildrenCache(client, getPath(serviceName), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//同步初始监听点childrenCache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);</span></span><br><span class="line">childrenCache.getListenable().addListener(<span class="keyword">new</span> PathChildrenCacheListener()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">childEvent</span><span class="params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="keyword">throws</span> Exception </span>&#123;          <span class="keyword">if</span>(event.getType().equals(PathChildrenCacheEvent.Type.INITIALIZED)) &#123;</span><br><span class="line">                    <span class="comment">//建立完监听</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="comment">//删除远程服务节点</span></span><br><span class="line">  <span class="keyword">if</span> (event.getType().equals(PathChildrenCacheEvent.Type.CHILD_REMOVED)) &#123;</span><br><span class="line">                    String path = event.getData().getPath();</span><br><span class="line">                    FileUtil fileUtil = <span class="keyword">new</span> FileUtil(<span class="keyword">true</span>);</span><br><span class="line">                    fileUtil.alterServiceCache(serviceName, path);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>至此，一个RPC设计完成了，有一些不足，希望大家多多指正。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/02/20/ConcurrentHashMap源码分析/" class="prev">上一篇</a><a href="/2020/02/04/Dubbo之服务引用/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2020/02/15/轻量级RPC设计与实现第五版(最终版)/';
var disqus_title = '轻量级RPC设计与实现第五版(最终版)';
var disqus_url = 'https://github.com/spurstong/2020/02/15/轻量级RPC设计与实现第五版(最终版)/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2018 - 2020 <a href="https://github.com/spurstong">Mara Tong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>