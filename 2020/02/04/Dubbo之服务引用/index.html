<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Dubbo之服务消费 · 房东的小黑</title><meta name="description" content="Dubbo之服务消费 - Mara Tong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/spurstong/atom.xml" title="房东的小黑"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/black.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">JIANSHU</a></li><li class="nav-list-item"><a href="https://github.com/spurstong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">房东的小黑黑</a></li></ul><div class="mySign">路途虽遥远，将来更美好</div></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Dubbo之服务消费</h1><div class="post-info">2020年2月4日</div><div class="post-content"><p>Dubbo的服务消费主要包括两个部分。第一大步是<code>ReferenceConfig</code>类的<code>init</code>方法调用<code>Protocol</code>的<code>refer</code>方法生成<code>Invoker</code>实例，这是服务消息的关键。第二大步是把Invoker通过动态代理转换成实现用户接口的动态代理引用。这里的Invoker承载了网络连接、服务调用和重试等功能。</p>
<h1 id="服务暴露起点"><a href="#服务暴露起点" class="headerlink" title="服务暴露起点"></a>服务暴露起点</h1><p>在消费者的配置文件中存在这个代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;</span><br><span class="line">&lt;dubbo:reference id=<span class="string">"demoService"</span> <span class="class"><span class="keyword">interface</span></span>=<span class="string">"org.apache.dubbo.demo.DemoService"</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>它会生成一个<code>ReferenceBean</code>,实现了FactoryBean接口，继承了ReferenceConfig,所以ReferenceBean作为dubbo中能够生产对象的工厂Bean,而我们要引用服务，也就要有一个该服务的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ReferenceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">FactoryBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br></pre></td></tr></table></figure>

<p>服务引用被触发有两个时机：</p>
<ul>
<li>Spring容器调用ReferenceBean的afterPropertiesSet方法时引用服务（饿汉式）</li>
<li>在ReferenceBean对应的服务被注入到其他类中时引用（懒汉式）</li>
</ul>
<p>默认情况下，Dubbo使用懒汉式引用服务。如果需要使用饿汉式，可通过配置<a href="dubbo:reference" target="_blank" rel="noopener">dubbo:reference</a>的init属性开启。</p>
<p>因为ReferenceBean实现了FactoryBean接口的getObject()方法，所以在加载bean的时候，会调用ReferenceBean的getObject()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReferenceBean.getObject()  ---&gt;  ReferenceConfig.get()   --&gt; ReferenceConfig.init()</span><br></pre></td></tr></table></figure>

<p>在init()方法中主要有这几步：<br>(1) 检测本地存根和mock合法性<br>(2) 添加协议版本、发布版本、时间戳、application、module、consumer、protocol等所有信息到map中。<br>(3) 单独处理方法配置，设置重试次数配置以及设置该方法对异步配置信息。<br>(4) 添加消费者ip地址到map<br>(5)创建代理对象,调用<code>ReferenceConfig.createProxy()</code>方法。<br>(6) 生成ConsumerMpdel存入到ApplicationModel中。</p>
<p>之后介绍<code>ReferenceConfig.createProxy()</code>方法。主要有下面几步：</p>
<ul>
<li>如果是本地调用，则直接使用InjvmProtocol的refer方法生成Invoker实例。</li>
<li>如果不是本地调用，但是选择直连的方式进行调用，则分割配置的多个url。如果协议是配置registry,则表明用户想使用指定的注册中心，配置url后将url保存到urls里面，否则就合并url,并且保存到urls。</li>
<li>如果是通过注册中心来进行调用，则先校验所有的注册中心，然后假加载注册中心的url,遍历每个url,加入监控中心url配置，最后把每个url保存到urls。</li>
<li>如果urls的个数是1，是单注册中心，直接引用RegistryProtocol的refer构建Invoker实例；如果urls的数量大于1，说明是多注册中心，则对每个url都生成Invoker,利用<code>cluster.join()</code>方法将多个Invoker进行合并成一个Invoker。</li>
<li>最后调用<code>proxyFactory.getProxy(invoker)</code>方法。</li>
</ul>
<p>然后介绍<code>RegistryProtocol.refer(Class&lt;T&gt; type, URL url)</code>方法生成invoker。</p>
<p>如果是注册中心服务，则直接返回注册中心服务的invoker;如果不是，则先处理组配置，根据组配置来决定Cluster的实现方式，如果有多个组，则使用MergeableCluster,然后调用doRefer(Cluster, Registry, Class, URL)方法。</p>
<p>然后介绍<code>doRefer()</code>方法。<br>(1) 创建一个RegistryDirectory实例，设置注册中心、协议等信息<br>(2) 生成服务消费者链接。<br>(3) 注册消费信息到注册中心。<br>(4) 订阅该服务下的providers、configurators、routers等节点下的数据。完成订阅后，RegistryDirectory会受到这几个节点下的子节点信息。<br>(5) 由于一个服务可能部署在多台服务器上，这样就会在providers产生多个节点，这个时候就需要Cluster将多个服务节点合并成一个，并生成一个Invoker.</p>
<p>在RegistryDirectory实现了NotifyListener接口，服务变更会触发这个类回调notify方法，用于重新引用服务。当发起订阅请求时会进行一次数据拉取操作，同时触发<code>RegistryDirectory.nofity()</code>方法。这是会执行<code>toInvokers()</code>方法进行Invoker转换。<br>(1) 根据消费者protocol配置过滤不匹配的协议。<br>(2) 合并provider端配置数据，比如服务端IP和port等。<br>(3) 忽略重复推送的服务列表<br>(4) 使用具体协议创建远程连接,<code>new InvokerDelegate&lt;T&gt;(protocol.refer(serviceType, url), url, providerUrl)</code>。</p>
<p>具体的Invoker创建是在<code>DubboProtocol.refer()</code>中实现。Dubbo协议在返回DubboInvoker对象之前会初始化客户端连接对象。<br>调用DubboProtocol.initClient()方法 -&gt; Exchangers.connect()方法，根据SPI机制加载HeaderExchangeClent，调用connect()方法。然后调用Transporter类的connect()方法，默认是NettyTransporter类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExchangeClient[] clients;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicPositiveInteger index = <span class="keyword">new</span> AtomicPositiveInteger();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String version;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock destroyLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Invoker&lt;?&gt;&gt; invokers;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Invoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; attachment;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> available = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">private</span> AtomicBoolean destroyed = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

</div></article></div></main><footer><div class="paginator"><a href="/2020/02/15/轻量级RPC设计与实现第五版(最终版)/" class="prev">上一篇</a><a href="/2020/02/04/Dubbo之服务注册/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2020/02/04/Dubbo之服务引用/';
var disqus_title = 'Dubbo之服务消费';
var disqus_url = 'https://github.com/spurstong/2020/02/04/Dubbo之服务引用/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2018 - 2020 <a href="https://github.com/spurstong">Mara Tong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>