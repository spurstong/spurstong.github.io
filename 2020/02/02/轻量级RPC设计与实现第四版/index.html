<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 轻量级RPC设计与实现第四版 · 房东的小黑</title><meta name="description" content="轻量级RPC设计与实现第四版 - Mara Tong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/spurstong/atom.xml" title="房东的小黑"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/black.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">JIANSHU</a></li><li class="nav-list-item"><a href="https://github.com/spurstong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">房东的小黑黑</a></li></ul><div class="mySign">路途虽遥远，将来更美好</div></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">轻量级RPC设计与实现第四版</h1><div class="post-info">2020年2月2日</div><div class="post-content"><p>在本版本中引入了SPI机制，关于Java的SPI机制与Dubbo的SPI机制在以前的文章中介绍过。<br>传送门：<a href="https://www.jianshu.com/p/cb9407a6e7e3" target="_blank" rel="noopener">Dubbo的SPI机制与JDK机制的不同及原理分析</a><br>因为设计的RPC框架是基于Spring的，时常会遇到依赖注入问题。Spring中也有SPI机制，但是它有有个缺点，就是在利用SPI机制实例化具体的服务类时，如果具体的服务类中调用其他的bean,就会实例化失败。主要因为该具体的服务类并没有放入到Spring容器中。本项目将有效解决这个问题。<br>在设计的RPC框架中加入了该机制，来实现不同序列化方式的切换。</p>
<h1 id="Spring的SPI机制"><a href="#Spring的SPI机制" class="headerlink" title="Spring的SPI机制"></a>Spring的SPI机制</h1><p>我们知道在SprngBoot中好多的配置和实现都有默认的实现，我们只需要修改部分配置，比如数据库配置，我们只要在配置文件中写上对应的url，username，password就可以使用了。其实他这边用的就是SPI的方式实现的。Spring的SPI机制原理与Java的SPI原理是一致的。<br>SpringBoot会利用<code>SpringFactoriesLoader</code>加载META-INF/spring.factories文件，从CLASSPATH下的每个Jar包中搜寻所有META-INF/spring.factories配置文件，然后将解析properties文件，找到指定名称的配置后返回。需要注意的是，其实这里不仅仅是会去ClassPath路径下查找，会扫描所有路径下的Jar包，只不过这个文件只会在Classpath下的jar包中。</p>
<p><strong>调用方式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;AService&gt; services = SpringFactoriesLoader.loadFactories(AService.class, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">for</span> (AService service : services) &#123;</span><br><span class="line">            service.info();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>相关源码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">loadFactories</span><span class="params">(Class&lt;T&gt; factoryClass, @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(factoryClass, <span class="string">"'factoryClass' must not be null"</span>);</span><br><span class="line">		ClassLoader classLoaderToUse = classLoader;</span><br><span class="line">		<span class="keyword">if</span> (classLoaderToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">			classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;String&gt; factoryNames = loadFactoryNames(factoryClass, classLoaderToUse);</span><br><span class="line">		<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">			logger.trace(<span class="string">"Loaded ["</span> + factoryClass.getName() + <span class="string">"] names: "</span> + factoryNames);</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(factoryNames.size());</span><br><span class="line">		<span class="keyword">for</span> (String factoryName : factoryNames) &#123;</span><br><span class="line">			result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse));</span><br><span class="line">		&#125;</span><br><span class="line">		AnnotationAwareOrderComparator.sort(result);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">"META-INF/spring.factories"</span>;</span><br><span class="line"><span class="comment">// spring.factories文件的格式为：key=value1,value2,value3</span></span><br><span class="line"><span class="comment">// 从所有的jar包中找到META-INF/spring.factories文件</span></span><br><span class="line"><span class="comment">// 然后从文件中解析出key=factoryClass类名称的所有value值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line">    <span class="comment">// 取得资源文件的URL</span></span><br><span class="line">    Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">    List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 遍历所有的URL</span></span><br><span class="line">    <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">        URL url = urls.nextElement();</span><br><span class="line">        <span class="comment">// 根据资源文件URL解析properties文件，得到对应的一组@Configuration类</span></span><br><span class="line">        Properties properties = PropertiesLoaderUtils.loadProperties(<span class="keyword">new</span> UrlResource(url));</span><br><span class="line">        String factoryClassNames = properties.getProperty(factoryClassName);</span><br><span class="line">        <span class="comment">// 组装数据，并返回</span></span><br><span class="line">        result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="改进的SPI机制"><a href="#改进的SPI机制" class="headerlink" title="改进的SPI机制"></a>改进的SPI机制</h1><p>该机制有两个缓存变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Map&lt;String, Class&lt;?&gt;&gt;&gt; cacheClasses= <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Class&lt;?&gt;, Map&lt;String, Object&gt;&gt; cacheIntances = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>两个Map的key都是扩展服务的接口类的Class对象<br><code>cacheClasses</code>的value也是一个Map,这个map的key是定义的扩展名，即<code>META-INF/roadspi/</code>目录下文件中的key,value是具体的扩展类的Class对象。<br><code>cacheIntances</code>变量的value也是一个Map,该map的key是定义的扩展名，value是扩展类的具体实例化对象。<br>该机制的主要逻辑是先获取要实现扩展的接口类Class对象，然后从<code>cacheIntances</code>变量中根据key查找是否有缓存的实例，如果有直接返回。如果没有，然后根据接口类Class对象和key在<code>cacheClasses</code>变量中进行查找具体扩展类的Class对象，如果存在，就直接获取对用的Class对象，然后利用<code>BeanDefinitionBuilder</code>生成bean,并注册到Spring容器中；如果找不到对应的Class对象，则到<code>META-INF/roadspi/扩展接口类全称</code>文件下进行资源加载。<br>支持自定义的<code>RoadSpi</code>注解，来定义默认的具体服务类实现。<br>[整体流程]（<a href="https://raw.githubusercontent.com/spurstong/img_data/master/轻量级RPC设计与实现第四版/1.png）" target="_blank" rel="noopener">https://raw.githubusercontent.com/spurstong/img_data/master/轻量级RPC设计与实现第四版/1.png）</a><br><strong>最主要部分实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createService</span><span class="params">(Map&lt;String, Object&gt; extensionInstanceMap, Map&lt;String, Class&lt;?&gt;&gt; serviceClass, String serviceName, Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">       Class&lt;?&gt; obj = serviceClass.get(serviceName);</span><br><span class="line">       <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">           log.error(<span class="string">"serviceClass is null!"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       String beanName = obj.getSimpleName().concat(serviceName);</span><br><span class="line">       BeanDefinitionBuilder builder = BeanDefinitionBuilder.genericBeanDefinition(obj);</span><br><span class="line">       GenericBeanDefinition definition = (GenericBeanDefinition)builder.getRawBeanDefinition();</span><br><span class="line">       definition.setAutowireMode(GenericBeanDefinition.AUTOWIRE_BY_NAME);</span><br><span class="line">       ConfigurableApplicationContext configurableApplicationContext = (ConfigurableApplicationContext)context;</span><br><span class="line">       DefaultListableBeanFactory register = (DefaultListableBeanFactory)configurableApplicationContext.getBeanFactory();</span><br><span class="line">       register.registerBeanDefinition(beanName, definition);</span><br><span class="line">       extensionInstanceMap.put(serviceName, context.getBean(beanName));</span><br><span class="line">       cacheIntances.put(type, extensionInstanceMap);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>具体详细代码地址：<a href="https://github.com/spurstong/RoadSPI">RoadSPI</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/01/30/轻量级RPC设计与实现第三版/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2020/02/02/轻量级RPC设计与实现第四版/';
var disqus_title = '轻量级RPC设计与实现第四版';
var disqus_url = 'https://github.com/spurstong/2020/02/02/轻量级RPC设计与实现第四版/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2018 - 2020 <a href="https://github.com/spurstong">Mara Tong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>