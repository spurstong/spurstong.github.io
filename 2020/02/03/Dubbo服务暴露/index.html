<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Dubbo服务暴露分析 · 房东的小黑</title><meta name="description" content="Dubbo服务暴露分析 - Mara Tong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/spurstong/atom.xml" title="房东的小黑"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/black.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">JIANSHU</a></li><li class="nav-list-item"><a href="https://github.com/spurstong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">房东的小黑黑</a></li></ul><div class="mySign">路途虽遥远，将来更美好</div></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Dubbo服务暴露分析</h1><div class="post-info">2020年2月3日</div><div class="post-content"><p>Dubbo的服务暴露是一个重要的特性，了解其机制很重要。之前有很多人写了有关的源代码分析，在本文中不再重新分析。官方文档中的一篇写的就很好，本文主要是有关内容进行补充与总结。<br>传送门：<a href="http://dubbo.apache.org/zh-cn/docs/source_code_guide/export-service.html" target="_blank" rel="noopener">服务导出</a></p>
<h1 id="为什么要服务暴露"><a href="#为什么要服务暴露" class="headerlink" title="为什么要服务暴露"></a>为什么要服务暴露</h1><p>服务暴露分为远程暴露和本地暴露。在远程服务暴露中会将服务信息上传到注册中心。这时客户端要调用某个服务时会从注册中心找到该服务的远程地址等信息。然后客户端根据这个地址进行远程调用。服务端接收到远程调用请求后会最终调用<code>getInvoker()</code>方法进行查找对用的<code>invoker</code>。在<code>getInvoker()</code>方法中会从一个HashMap中进行查找，如果在这个Map中查找不到就会抛出异常。在远程服务暴露中，会按照规则将实例Invoker存储在HashMap中，其中Key名包含端口、接口名、接口版本和接口分组。所以进行服务暴露很重要。<br>本地服务暴露是暴露在JVM中，不需要远程通信。Dubbo会默认把远程服务用injvm协议再暴露一份。<br><strong>为什么会有本地服务暴露</strong><br>在Dubbo中，一个服务可以即是provider,又是Consumer,因此就存在它自己调用自己服务的时候，如果再通过网络去访问，那么就是舍近求远，因此有了本地暴露服务这个设计。消费者可以直接消费同一个JVM内部的服务，避免了跨网络进行远程通信。</p>
<h1 id="服务暴露起点"><a href="#服务暴露起点" class="headerlink" title="服务暴露起点"></a>服务暴露起点</h1><p>我们会通过XML或注解的方式来指定要暴露的服务。l例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=“xxxService” <span class="class"><span class="keyword">class</span></span>=“com.xxx.XxxServiceImpl” /&gt; </span><br><span class="line">&lt;!-- 增加暴露远程服务配置 --&gt;</span><br><span class="line">&lt;dubbo:service <span class="class"><span class="keyword">interface</span></span>=“com.xxx.XxxService” ref=“xxxService” /&gt;</span><br></pre></td></tr></table></figure>

<p>这时会创建出一个<code>ServiceBean</code>对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationContextAware</span>, <span class="title">BeanNameAware</span>,</span></span><br><span class="line"><span class="class">        <span class="title">ApplicationEventPublisherAware</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfig</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ServiceConfigBase</span>&lt;<span class="title">T</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceConfigBase</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractServiceConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3033787999037024738L</span>;</span><br><span class="line">    <span class="keyword">protected</span> String interfaceName;</span><br><span class="line">    <span class="comment">//要暴露服务类的接口类</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; interfaceClass;</span><br><span class="line">    <span class="comment">//实现类引用</span></span><br><span class="line">    <span class="keyword">protected</span> T ref;</span><br><span class="line">    <span class="comment">//服务名 </span></span><br><span class="line">    <span class="keyword">protected</span> String path;</span><br><span class="line">    <span class="keyword">protected</span> ProviderConfig provider;</span><br><span class="line">    <span class="keyword">protected</span> String providerIds;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> String generic;</span><br><span class="line">    <span class="keyword">protected</span> ServiceMetadata serviceMetadata;</span><br></pre></td></tr></table></figure>

<p>ServiceBean和Spring有关，它继承了InitializingBean和ApplicationEvent。在Bean初始化完成后会调用InitializingBean.afterPropertiesSet方法来执行服务暴露的准备工作。在Spring的context完成初始化后，会触发ApplicationEventListener事件进行服务暴露,会执行<code>onApplicationEvent</code>方法。这时服务服务暴露就开始了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否有延迟导出 &amp;&amp; 是否已导出 &amp;&amp; 是不是已被取消导出</span></span><br><span class="line">    <span class="keyword">if</span> (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123;</span><br><span class="line">        <span class="comment">// 导出服务</span></span><br><span class="line">        export();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p>Dubbo真正的服务暴露入口是<code>ServiceConfig#doExport()</code>方法。首先ServiceConfig类拿到对外提供服务的实际类ref,然后通过<code>ProxyFactory</code>类的<code>getInvoker</code>方法使用ref生成一个<code>AbstractProxyInvoker</code>实例，到这一步就完成具体服务到<code>Invoker</code>的转化。然后就是把<code>Invoker</code>通过具体的协议（比如Bubbo）转化成<code>Exporter</code>。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/Dubbo%E4%B9%8B%E6%9C%8D%E5%8A%A1%E6%9A%B4%E9%9C%B2%E5%88%86%E6%9E%90/1.png" alt="整体流程"><br>参考了简书肥朝的一篇文章:  <a href="[https://www.jianshu.com/p/60a9263f2ee2](https://www.jianshu.com/p/60a9263f2ee2)">dubbo源码解析-服务暴露原理</a></p>
<ul>
<li>调用ServiceConfig中的<code>export</code>方法，对配置进行检查与更新，例如provider是否为空，注册中心是否为空，protocols是否为空。然后检测是否应该暴露，如果不应该暴露，则直接结束；然后检测是否配置了延迟加载，如果是，则使用定时器来实现延迟加载的目的。</li>
<li>调用<code>expoer</code>方法里面的<code>doExport()</code>方法。通过<code>exported</code>变量判断是否暴露，如果为true，直接返回；否则先设置为true,然后执行<code>doExportUrls()</code>方法。</li>
<li>调用<code>doExportUrls()</code>方法，先通过<code>loadRegistries</code>加载注册中心链接，然后遍历ProtocolConfig集合，它是用户指定的协议集合（比如Dubbo、REST），在里面执行<code>doExportUrlsFor1Protocol(protocolConfig, registryURLs)</code>方法。</li>
<li>执行<code>doExportUrlsFor1Protocol(protocolConfig, registryURLs)</code>方法，刚开始是组装URL。（1）它把metrices、application、module、provider、protocol等所有配置都放入到map中，(2) 通过反射获取interfaceClass的方法列表，先做签名校验，判断该服务是否有配置的方法存在，然后该方法签名是否有这个参数存在，都核对成功才将method的配置加入到map中；(3)将范化调用、版本号、method或者methods、token等信息加入到map；（4）获取服务暴露地址和端口号，利用map内数据组装成URL。</li>
<li>然后根据url中的scope参数决定服务导出方式。<code>scope=none</code>，不导出服务；<code>scope!=remote</code>，导出到本地；<code>scope!=local</code>，导出到远程。</li>
<li>执行<code>proxyFactory.getInvoker(ref, (Class)interfaceClass, url)</code>方法，来获取invoker，Dubbo默认的ProxyFactory实现类是<code>JavasistProxyFacoty</code>方法。</li>
</ul>
<p>这时，第一大步<strong>服务转化成Invoker</strong>已经完成，然后执行第二大步<code>Invoker转化成Exporter</code>。<br><strong>先介绍本地服务的暴露机制</strong></p>
<ul>
<li>调用<code>exportLocal(url)</code>。首先判断URL的协议头如果等于injvm,说明已经导出到本地了，无需再次导出。如果不是，则创建一个新的URL并将协议头设置为injvm,并另外设置主机名和端口。然后创建invoker,并调用<code>InjvmProtocal</code>的<code>export()</code>方法暴露服务。</li>
<li><code>InjvmProtocol</code>的<code>export</code>方法仅创建一个<code>InjvmExporter</code>，无其他逻辑。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InjvmExporter&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);</span><br><span class="line">&#125;</span><br><span class="line">InjvmExporter(Invoker&lt;T&gt; invoker, String key, Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap) &#123;</span><br><span class="line">	<span class="keyword">super</span>(invoker);</span><br><span class="line">	<span class="keyword">this</span>.key = key;</span><br><span class="line">	<span class="keyword">this</span>.exporterMap = exporterMap;</span><br><span class="line">	exporterMap.put(key, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>然后介绍远程服务暴露</strong><br>如果有注册中心，服务暴露后需要向注册中心注册服务信息<br>如果没有注册中心，直接暴露服务。</p>
<h1 id="有注册中心的暴露"><a href="#有注册中心的暴露" class="headerlink" title="有注册中心的暴露"></a>有注册中心的暴露</h1><ol>
<li>调用<code>doLocalExport()</code>方法暴露服务。</li>
<li>向注册中心注册服务</li>
<li>向注册中心进行订阅ovrride数据</li>
<li>创建并返回<code>DestroyableExporter</code>。</li>
</ol>
<p><strong>调用<code>doLocalExport()</code>方法暴露服务</strong></p>
<ul>
<li><p>首先根据<code>invoker</code>得到key,从<code>bounds</code>缓存变量中尝试获取<code>exporter</code>,如果获取不到，则调用Protocal的<code>export</code>方法,默认的协议是dubbo,所以调用的DubboProtocol的export方法。</p>
</li>
<li><p>调用DubboProtocol的export方法，首先从invoker中获取对用的URL,然后根据服务组名、服务名、服务版本号和端口组成key,然后创建一个DubboExporter。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demoGroup/com.alibaba.dubbo.demo.DemoService:1.0.1:20880</span></span><br><span class="line">String key = serviceKey(url);</span><br><span class="line"><span class="comment">// 创建 DubboExporter</span></span><br><span class="line">DubboExporter&lt;T&gt; exporter = <span class="keyword">new</span> DubboExporter&lt;T&gt;(invoker, key, exporterMap);</span><br><span class="line"><span class="comment">// 将 &lt;key, exporter&gt; 键值对放入缓存中</span></span><br><span class="line">exporterMap.put(key, exporter);</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用<code>openServer(url)</code>方法。首先根据url获取<code>host:port</code>,用于标识当前的服务器实例。在同一台机器上，同一个端口仅允许启动一个服务器实例。若某个端口上已有服务器实例，此时调用<code>reset</code>方法重置一些服务器的配置；如果没有则调用<code>createServer(url)</code>方法创建一个服务器实例。</p>
</li>
<li><p>调用<code>createServer(url)</code>方法，有三个核心的逻辑，首先检测是否存在server参数所代表的Transporter拓展，即网络传输方式（如Netty, Mina），如果没有，则抛出异常；然后通过<code>Exchangers.bind(url, requestHandler)</code>方法创建服务器实例；最后是检测是否支持client参数所表示的Transporter拓展，不存在也是抛出异常。</p>
</li>
<li><p>调用<code>Exchangers.bind(url, requestHandler)</code>方法,里面又调用了下面几个方法。只保留了主要逻辑部分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getExchanger(url).bind(url, handler);</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Exchanger <span class="title">getExchanger</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);</span><br><span class="line">        <span class="keyword">return</span> getExchanger(type);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Exchanger <span class="title">getExchanger</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ExtensionLoader.getExtensionLoader(Exchanger.class).getExtension(type);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Exchange层是为了封装请求/响应模式，例如：把同步请求转化为异步请求。默认的扩展点实现类是<code>HeaderExchanger</code>。</p>
<ul>
<li><p>调用HeaderExchanger的bind方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Server <span class="title">bind</span><span class="params">(URL url, ChannelHandler... handlers)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (handlers == <span class="keyword">null</span> || handlers.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handlers == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ChannelHandler handler;</span><br><span class="line">    <span class="keyword">if</span> (handlers.length == <span class="number">1</span>) &#123;</span><br><span class="line">        handler = handlers[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	<span class="comment">// 如果 handlers 元素数量大于1，则创建 ChannelHandler 分发器</span></span><br><span class="line">        handler = <span class="keyword">new</span> ChannelHandlerDispatcher(handlers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取自适应 Transporter 实例，并调用实例方法</span></span><br><span class="line">    <span class="keyword">return</span> getTransporter().bind(url, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据自适应扩展机制动态创建一个Transporter,Dubbo默认是NettyTransporter。</p>
</li>
<li><p>调用<code>NettyTransporter.bind(URL, ChannelHandler)</code>方法。创建一个<code>NettyServer</code>实例。</p>
</li>
<li><p>调用<code>NettyServer.doOPen()</code>方法，服务器被开启，服务也被暴露出来了。</p>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2020/02/02/轻量级RPC设计与实现第四版/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2020/02/03/Dubbo服务暴露/';
var disqus_title = 'Dubbo服务暴露分析';
var disqus_url = 'https://github.com/spurstong/2020/02/03/Dubbo服务暴露/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2018 - 2020 <a href="https://github.com/spurstong">Mara Tong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>