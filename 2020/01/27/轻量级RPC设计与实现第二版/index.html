<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 轻量级RPC设计与实现第二版 · 房东的小黑</title><meta name="description" content="轻量级RPC设计与实现第二版 - Mara Tong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/spurstong/atom.xml" title="房东的小黑"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/black.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">JIANSHU</a></li><li class="nav-list-item"><a href="https://github.com/spurstong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">房东的小黑黑</a></li></ul><div class="mySign">路途虽遥远，将来更美好</div></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">轻量级RPC设计与实现第二版</h1><div class="post-info">2020年1月27日</div><div class="post-content"><p>在上一个版本中利用netty实现了简单的一对一的RPC，需要手动设置服务地址，限制性较大。<br>在本文中，利用zookeeper作为服务注册中心，在服务端启动时将本地的服务信息注册到zookeeper中，当客户端发起远程服务调用时，先从zookeeper中获取该服务的地址，然后根据获得的这个地址来利用netty进行网络传送。<br>在服务端和注册中心之间需要建立监听，当服务信息发生变化或网络连接等问题时需要对注册中心的服务信息进行修改。在本文中创建了服务注册监控中心，利用<strong>心跳机制</strong>来判断与服务端是否有较稳定的连接，当出现网络不稳定时，则从注册中心中删除属于该服务端的服务信息。在本项目中设定在5分钟内3次以上没有发送心跳包为不稳定状态。</p>
<h1 id="zookeeper注册中心"><a href="#zookeeper注册中心" class="headerlink" title="zookeeper注册中心"></a>zookeeper注册中心</h1><p>zookeeper是hadoop中的一个重要组件，其主要是作为<strong>分布式协调服务</strong><br>zookeeper采用节点树的数据模型，类似linux文件系统。<br>每个节点称做一个ZNode,每个ZNode都可以通过路径唯一标识，同时每个节点还可以存储少量数据。<br>本项目借鉴dubbo的注册中心模型来设计本文的注册中心。<br>总体上设计了四级节点，在一个节点是一个持久节点<code>/register</code>，表示是记录注册服务的区域。二级节点是服务接口名，三级节点是远程服务ip地址，该节点是临时节点，节点存储的数据是具体的实现类名。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/%E8%BD%BB%E9%87%8F%E7%BA%A7RPC%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%AC%E4%BA%8C%E7%89%88/1.png" alt="整体流程"><br>在客户端会根据服务接口名在注册中心进行查找，得到远程服务ip地址，并根据节点中存储的具体实现类名进行反射。</p>
<p>首先进行zookeeper初始化,利用了<code>CuratorFramework</code>有关类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        RetryPolicy retryPolicy = <span class="keyword">new</span> RetryNTimes(ZKConsts.RETRYTIME, ZKConsts.SLEEP_MS_BEWTEENR_RETRY);</span><br><span class="line">        client = CuratorFrameworkFactory.builder().connectString(ZKConsts.ZK_SERVER_PATH)</span><br><span class="line">                .sessionTimeoutMs(ZKConsts.SESSION_TIMEOUT_MS).retryPolicy(retryPolicy)</span><br><span class="line">                .namespace(ZKConsts.WORK_SPACE).build();</span><br><span class="line">        client.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>服务的注册代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(URL url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String interfaceName = url.getInterfaceName();</span><br><span class="line">            String implClassName = url.getImplClassName();</span><br><span class="line">            Stat stat = client.checkExists().forPath(getPath(interfaceName, url.toString()));</span><br><span class="line">            <span class="keyword">if</span> (stat != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"该节点已存在！"</span>);</span><br><span class="line">                client.delete().forPath(getPath(interfaceName, url.toString()));</span><br><span class="line">            &#125;</span><br><span class="line">            client.create()</span><br><span class="line">                    .creatingParentsIfNeeded()</span><br><span class="line">                    .withMode(CreateMode.EPHEMERAL)</span><br><span class="line">                    <span class="comment">//权限控制，任何连接的客户端都可以操作该属性znode</span></span><br><span class="line">                    .withACL(ZooDefs.Ids.OPEN_ACL_UNSAFE)</span><br><span class="line">                    .forPath(getPath(interfaceName, url.toString()), implClassName.getBytes());</span><br><span class="line">            System.out.println(getPath(interfaceName, url.toString()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据服务接口名来获取远程服务连接地址</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> URL <span class="title">random</span><span class="params">(String interfaceName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"开始查找服务节点："</span> + getPath(interfaceName));</span><br><span class="line">            List&lt;String&gt; urlList = client.getChildren().forPath(<span class="string">"/"</span> + interfaceName);</span><br><span class="line">            System.out.println(<span class="string">"结果："</span> + urlList);</span><br><span class="line">            String serviceUrl = urlList.get(<span class="number">0</span>);</span><br><span class="line">            String[] urls = serviceUrl.split(<span class="string">":"</span>);</span><br><span class="line">            String implClassName = get(interfaceName, serviceUrl);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> URL(urls[<span class="number">0</span>], Integer.valueOf(urls[<span class="number">1</span>]), interfaceName, implClassName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(e);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>注册中心与服务端进行连接时需要判断是否维持了稳定的连接，如果服务端出现宕机等情况时需要从注册中心中删除这些服务。<br>以前的一些处理机制，有<strong>session</strong>机制和<strong>wacher</strong>机制。<br><strong>session机制</strong><br>每个zookeeper注册中心与服务端进行连接时会创建一个session,在设置的sessionTimeout内，服务端会与注册中心进行心跳包的定时发送，从而感知每个客户端是否宕机，如果创建某个临时Znode节点对应的session销毁时，相应的临时节点也会被注册中心删除。<br><strong>watcher机制</strong><br>针对每个节点的操作，都有要给监督者进行watcher,当监控的某个节点发生了变化，则会触发watcher事件。注册中心的watcher是一次性的，触发后会被销毁。父节点，子节点增删改都能够触发watcher。触发销毁后，下次需要监听时还需要再注册一次。<br><strong>本文心跳机制</strong><br>服务端定时向注册中心发送本机地址，看作心跳数据包，而注册中心监控则维持一个channelId和具体地址的map,并且通过IdleHandler监听空闲事件，到达一定的空闲次数则认为不活跃，当不活跃时，zookeeper删除对应的url节点。该版本实现了上面的内容，后续的步骤在以后的版本实现。<br>如果10s内没有触发读，就会执行<code>userEventTriggered</code>方法。如果5分钟中出现两次不活跃次数，就认定该连接不稳定，注册中心会移除属于该服务端的服务。你也可以根据实际情况设定不稳定标准。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">service.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">               <span class="keyword">if</span> (future.channel().isActive()) &#123;</span><br><span class="line">                   <span class="keyword">int</span> time = <span class="keyword">new</span> Random().nextInt(<span class="number">5</span>);</span><br><span class="line">                   log.info(<span class="string">"本次定时任务获取的随机数:&#123;&#125;"</span>, time);</span><br><span class="line">                   <span class="keyword">if</span> (time &gt; <span class="number">3</span>) &#123;</span><br><span class="line">                       log.info(<span class="string">"发送本地地址到注册中心：&#123;&#125;"</span>, url);</span><br><span class="line">                       future.channel().writeAndFlush(url);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;, <span class="number">60</span>, <span class="number">60</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">           IdleStateEvent state = (IdleStateEvent)evt;</span><br><span class="line">           <span class="keyword">if</span> (state.state().equals(IdleState.READER_IDLE)) &#123;</span><br><span class="line">               log.info(<span class="string">"读空闲"</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.state().equals(IdleState.WRITER_IDLE)) &#123;</span><br><span class="line">               log.info(<span class="string">"写空闲"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//在一定时间内读写空闲才会关闭链接</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (state.state().equals(IdleState.ALL_IDLE)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (++inActiveCount == <span class="number">1</span>) &#123;</span><br><span class="line">                   start = System.currentTimeMillis();</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">int</span> minute = (<span class="keyword">int</span>)((System.currentTimeMillis() - start) / (<span class="number">60</span> * <span class="number">1000</span>)) + <span class="number">1</span>;</span><br><span class="line">               log.info(<span class="string">"第&#123;&#125;次读写都空闲，计时分钟数&#123;&#125;"</span>, inActiveCount, minute);</span><br><span class="line">               <span class="keyword">if</span> (inActiveCount &gt; <span class="number">2</span> &amp;&amp; minute &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                   log.info(<span class="string">"移除不活跃ip"</span>);</span><br><span class="line">                   removeAndClose(ctx);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (minute &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">                       log.info(<span class="string">"新周期开始"</span>);</span><br><span class="line">                       start = <span class="number">0</span>;</span><br><span class="line">                       inActiveCount = <span class="number">0</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>具体实现代码：<a href="https://github.com/spurstong/lightWeightRpc/tree/lightweightrpcv2">RPC第二版</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/01/30/轻量级RPC设计与实现第三版/" class="prev">上一篇</a><a href="/2020/01/24/轻量级RPC设计与实现第一版/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2020/01/27/轻量级RPC设计与实现第二版/';
var disqus_title = '轻量级RPC设计与实现第二版';
var disqus_url = 'https://github.com/spurstong/2020/01/27/轻量级RPC设计与实现第二版/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2018 - 2020 <a href="https://github.com/spurstong">Mara Tong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>