<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 轻量级分布式锁的设计原理分析与实现 · 房东的小黑</title><meta name="description" content="轻量级分布式锁的设计原理分析与实现 - Mara Tong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/spurstong/atom.xml" title="房东的小黑"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/black.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">JIANSHU</a></li><li class="nav-list-item"><a href="https://github.com/spurstong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">房东的小黑黑</a></li></ul><div class="mySign">路途虽遥远，将来更美好</div></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">轻量级分布式锁的设计原理分析与实现</h1><div class="post-info">2020年1月17日</div><div class="post-content"><h1 id="为什么要设计分布式锁"><a href="#为什么要设计分布式锁" class="headerlink" title="为什么要设计分布式锁"></a>为什么要设计分布式锁</h1><p>  在简单的单机系统中，当存在多个线程同时要修改某个共享变量时，为了数据的操作安全，往往需要通过加锁的方法，在同一时刻同一代码块只能有一个进程执行操作，存在很多加锁的方式，比如在java中有synchronize或Lock子类等。<br>  但是在分布式中，会存在多个主机，即会存在多个jvm, 在jvm之间数据是不能共享的，上面的方法只能在一个jvm中执行有效，在多个jvm中同一变量可能会有不同的值。所以我们要设计一种跨jvm的共享互斥机制来控制共享变量资源的访问，这也是提出分布式锁的初衷。</p>
<h1 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h1><p>为了将分布式锁实现较好的性能，我们需要解决下面几个重要的问题：</p>
<ul>
<li>一个方法或代码片段在同一时刻只能被一个进程所执行。</li>
<li>高可用的获取锁与释放锁功能。</li>
<li>避免死锁</li>
<li>锁只能被持有该锁的客户端删除或者释放。</li>
<li>容错，在服务器宕机时，锁依然能得到释放或者其他服务器可以进行加锁。</li>
</ul>
<p>下面分别利用redis和zookeeper来实现加锁和解锁机制。</p>
<h1 id="基于Redis的加锁第一版"><a href="#基于Redis的加锁第一版" class="headerlink" title="基于Redis的加锁第一版"></a>基于Redis的加锁第一版</h1><p>本版本通过变量sign设置锁的唯一标识，确保只有拥有该锁的客户端才能删除它，其他客户端不能删除。<br>利用阻塞锁的思想， 通过<code>while(System.currentTimeMillis() &lt; endTime)</code>和<code>Thread.sleep()</code>相结合，在设置的规定时间内进行多次尝试。<br>但是<code>setnx</code>操作和<code>expire</code>分割开了，不具有<strong>原子性</strong>，可能会出现问题。<br>比如说，在执行到<code>jedis.expire</code>时，可能系统发生了崩溃，导致锁没有设置过期时间，导致发生死锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addLockVersion1</span><span class="params">(String key, <span class="keyword">int</span> blockTime, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (blockTime &lt;=<span class="number">0</span> || expireTime &lt;= <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           jedis = jedisPool.getResource();</span><br><span class="line">           String sign = UUID.randomUUID().toString();</span><br><span class="line">           String token = <span class="keyword">null</span>;</span><br><span class="line">           <span class="comment">//设置阻塞尝试时间</span></span><br><span class="line">           <span class="keyword">long</span> endTime = System.currentTimeMillis() + blockTime;</span><br><span class="line">           <span class="keyword">while</span> (System.currentTimeMillis() &lt; endTime) &#123;</span><br><span class="line">               <span class="keyword">if</span> (jedis.setnx(key, sign) == <span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="comment">// 添加成功，设置锁的过期时间，防止死锁</span></span><br><span class="line">                   jedis.expire(key, expireTime);</span><br><span class="line">                   <span class="comment">// 在释放锁时用于验证</span></span><br><span class="line">                   token = sign;</span><br><span class="line">                   <span class="keyword">return</span> token;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//加锁失败，休眠一段时间，再进行尝试。</span></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(DEFAULT_SLEEP_TIME);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   Thread.currentThread().interrupt();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">               jedis.close();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="基于Redis的加锁第二版"><a href="#基于Redis的加锁第二版" class="headerlink" title="基于Redis的加锁第二版"></a>基于Redis的加锁第二版</h1><p>通过设置key对应的value值为锁的过期时间，当遇到系统崩溃，致使利用<code>expire</code>设置锁过期时间失败时，通过获取value值，来判断当前锁是否过期，如果该锁已经过期了，则进行重新获取。</p>
<p>但是它也存在一些问题。当锁过期时，如果多个进程同时执行<code>jedis.getSet</code>方法，虽然只有一个进程可以获得该锁，但是这个进程的锁的过期时间可能被其他进程的锁所覆盖。<br>该锁没有设置唯一标识，也会被其他客户端锁释放，不满足只能被锁的拥有者锁释放的条件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addLockVersion2</span><span class="params">(String key, <span class="keyword">int</span> blockTime, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (blockTime &lt;=<span class="number">0</span> || expireTime &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            <span class="keyword">long</span> endTime = System.currentTimeMillis() + blockTime;</span><br><span class="line">            <span class="keyword">while</span> (System.currentTimeMillis() &lt; endTime) &#123;</span><br><span class="line">                <span class="keyword">long</span> redisExpierTime = System.currentTimeMillis() + expireTime;</span><br><span class="line">                <span class="keyword">if</span> (jedis.setnx(key, redisExpierTime + <span class="string">""</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                    jedis.expire(key, expireTime);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    String oldRedisExpierTime = jedis.get(key);</span><br><span class="line">                    <span class="comment">// 当锁设置成功，但是没有通过expire成功设置过期时间，但是根据存的值判断出它实际上已经过期了</span></span><br><span class="line">                    <span class="keyword">if</span> (oldRedisExpierTime != <span class="keyword">null</span> &amp;&amp; Long.parseLong(oldRedisExpierTime) &lt; System.currentTimeMillis()) &#123;</span><br><span class="line">                        String lastRedisExpierTime = jedis.getSet(key, System.currentTimeMillis() + blockTime + <span class="string">""</span>);</span><br><span class="line">                        <span class="comment">//获取到该锁，没有被其他线程所修改</span></span><br><span class="line">                        <span class="keyword">if</span> (lastRedisExpierTime.equals(oldRedisExpierTime)) &#123;</span><br><span class="line">                            jedis.expire(key, expireTime);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//加锁失败，休眠一段时间，再进行尝试。</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(DEFAULT_SLEEP_TIME);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="基于Redis的加锁第三版"><a href="#基于Redis的加锁第三版" class="headerlink" title="基于Redis的加锁第三版"></a>基于Redis的加锁第三版</h1><p>具体通过<code>set</code>方法来实现<code>setnx</code>和<code>expire</code>的相加功能，实现了原子操作。<br>如果key不存在时，就进行加锁操作，并对锁设置一个有效期，同时uniqueId表示加锁的客户端；如果key存在，不做任何操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addLockVersion3</span><span class="params">(String key, String uniqueId, <span class="keyword">int</span> blockTime, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> endTime = System.currentTimeMillis() + blockTime;</span><br><span class="line">            <span class="keyword">while</span> (System.currentTimeMillis() &lt; endTime) &#123;</span><br><span class="line">                jedis = jedisPool.getResource();</span><br><span class="line">                String result = jedis.set(key, uniqueId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">                <span class="keyword">if</span> (LOCK_STATE.equals(result))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(DEFAULT_SLEEP_TIME);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="基于Redis的加锁第四版"><a href="#基于Redis的加锁第四版" class="headerlink" title="基于Redis的加锁第四版"></a>基于Redis的加锁第四版</h1><p>为了使对同一个对象添加多次锁，并且不发生阻塞，即实现类似可重入锁，我们借鉴了<code>ReetrantLock</code>的思想，添加了变量<code>states</code>来控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addLockVersion4</span><span class="params">(String key, String uniqueId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> state = states.get();</span><br><span class="line">        <span class="keyword">if</span> (state &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            states.set(state+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> doLock(key, uniqueId, expireTime);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doLock</span><span class="params">(String key, String uniqueId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (expireTime &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            String result = jedis.set(key, uniqueId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line">            <span class="keyword">if</span> (LOCK_STATE.equals(result))</span><br><span class="line">                states.set(states.get() + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="基于Redis的加锁第五版"><a href="#基于Redis的加锁第五版" class="headerlink" title="基于Redis的加锁第五版"></a>基于Redis的加锁第五版</h1><p>从上面可知，利用<code>setnx</code>和<code>expire</code>实现加锁机制时因为不是原子操作，会产生一些问题，我们可用lua脚本来实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addLockVersion5</span><span class="params">(String key, String uniqueId, <span class="keyword">int</span> expireTime)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            String luaScript = <span class="string">"if redis.call('setnx',KEYS[1],ARGV[1]) == 1 then"</span> +</span><br><span class="line">                    <span class="string">"redis.call('expire',KEYS[1],ARGV[2]) return 1 else return 0 end"</span>;</span><br><span class="line">            List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            keys.add(key);</span><br><span class="line">            values.add(uniqueId);</span><br><span class="line">            values.add(String.valueOf(expireTime));</span><br><span class="line">            Object result = jedis.eval(luaScript, keys, values);</span><br><span class="line">            <span class="keyword">if</span> ((Long)result == <span class="number">1L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                jedis.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="基于Redis的释放锁第一版"><a href="#基于Redis的释放锁第一版" class="headerlink" title="基于Redis的释放锁第一版"></a>基于Redis的释放锁第一版</h1><p>在解锁时首先判断加速与解锁是否是同一个客户端，然后利用<code>del</code>方法进行删除。<br>但是会出现一些问题。<br>当方法执行到判断内部时，即将要执行<code>del</code>方法时，该锁已经过期了，并被其他的客户端所请求应有，此时执行<code>del</code>会造成锁的误删。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLockVersion1</span><span class="params">(String key, String uniqueId)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            <span class="comment">//加锁与解锁是否是同一个客户端</span></span><br><span class="line">            String lockId = jedis.get(key);</span><br><span class="line">            <span class="keyword">if</span> (lockId != <span class="keyword">null</span> &amp;&amp; lockId.equals(uniqueId)) &#123;</span><br><span class="line">                jedis.del(key);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="基于Redis的释放锁第二版"><a href="#基于Redis的释放锁第二版" class="headerlink" title="基于Redis的释放锁第二版"></a>基于Redis的释放锁第二版</h1><p>从上面的分析来看，我们要确保删除的原子性，利用lua脚本可以保证一点。<br>在脚本语言里，KEYS[1]和ARGV[1]分别表示传入的key名和唯一标识符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLockVersion2</span><span class="params">(String key, String uniqueId)</span> </span>&#123;</span><br><span class="line">        String luaScript = <span class="string">"if  redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            result = jedis.eval(luaScript, Collections.singletonList(key), Collections.singletonList(uniqueId));</span><br><span class="line">            <span class="keyword">if</span> ((Long)result == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="基于Redis的释放锁第三版"><a href="#基于Redis的释放锁第三版" class="headerlink" title="基于Redis的释放锁第三版"></a>基于Redis的释放锁第三版</h1><p>在利用可重入锁思想时，只有当<code>states=1</code>时才能被释放，大于0时，只能进行减1操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLockVersion3</span><span class="params">(String key, String uniqueId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> state = states.get();</span><br><span class="line">        <span class="keyword">if</span> (state &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            states.set(states.get() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.doRelease(key, uniqueId);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doRelease</span><span class="params">(String key, String uniqueId)</span> </span>&#123;</span><br><span class="line">        String luaScript = <span class="string">"if  redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jedis = jedisPool.getResource();</span><br><span class="line">            result = jedis.eval(luaScript, Collections.singletonList(key), Collections.singletonList(uniqueId));</span><br><span class="line">            <span class="keyword">if</span> ((Long)result == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JedisException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            states.set(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (jedis != <span class="keyword">null</span>)</span><br><span class="line">                jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="利用Zookeeper实现分布式锁"><a href="#利用Zookeeper实现分布式锁" class="headerlink" title="利用Zookeeper实现分布式锁"></a>利用Zookeeper实现分布式锁</h1><p>Zookeeper提供一个多层次的节点命名空间，每个节点都用一个以斜杠（/）分割的路径表示，<br>而且每个节点都有父节点（根节点除外），非常类似于文件系统。</p>
<p><strong>基本思想流程</strong></p>
<ul>
<li>在某父节点下添加创建一个节点，</li>
<li>获取该父节点下的所有子节点，并进行排序，获得有个有序序列</li>
<li>如果当前添加的节点是序列中序号最小的节点，表示获取锁成功</li>
<li>如果不是最小的节点，则对在有序列表中的它的前一个节点进行监听，当被监听的节点被删除后，会通知该节点获取锁。</li>
<li>解锁的时候删除当前节点。</li>
</ul>
<p><strong>实现代码</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">zklock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ZkClient zkClient;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String currentLockPath;</span><br><span class="line">    <span class="keyword">private</span> CountDownLatch countDownLatch;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATENT_LOCK_PATH = <span class="string">"distribute_lock"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_RETEY_TIMES = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_WAIT_TIME = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">zklock</span><span class="params">(ZkClient zkClient, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zkClient = zkClient;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!zkClient.exists(PATENT_LOCK_PATH)) &#123;</span><br><span class="line">            zkClient.createPersistent(PATENT_LOCK_PATH);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> iscompleted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (!iscompleted) &#123;</span><br><span class="line">            iscompleted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//创建当前目录下的临时有序节点</span></span><br><span class="line">                currentLockPath = zkClient.createEphemeralSequential(PATENT_LOCK_PATH + <span class="string">"/"</span>, System.currentTimeMillis());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count++ &lt; MAX_RETEY_TIMES) &#123;</span><br><span class="line">                    iscompleted = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">throw</span>  e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        zkClient.delete(currentLockPath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检查是否是最小的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkMinNode</span><span class="params">(String localPath)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; children = zkClient.getChildren(PATENT_LOCK_PATH);</span><br><span class="line">        Collections.sort(children);</span><br><span class="line">        <span class="keyword">int</span> index = children.indexOf(localPath.substring(PATENT_LOCK_PATH.length()+<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (countDownLatch != <span class="keyword">null</span>) &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String waitPath = PATENT_LOCK_PATH + <span class="string">"/"</span> + children.get(index-<span class="number">1</span>);</span><br><span class="line">            waitForLock(waitPath, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//监听有序序列中的前一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">waitForLock</span><span class="params">(String waitPath, <span class="keyword">boolean</span> useTime)</span> </span>&#123;</span><br><span class="line">        countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        zkClient.subscribeDataChanges(waitPath, <span class="keyword">new</span> IZkDataListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataChange</span><span class="params">(String s, Object o)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataDeleted</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                 checkMinNode(currentLockPath);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">if</span> (!zkClient.exists(waitPath)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (useTime == <span class="keyword">true</span>)</span><br><span class="line">                countDownLatch.await(DEFAULT_WAIT_TIME, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="基于Redis和Zookeeper的分布式锁的优劣"><a href="#基于Redis和Zookeeper的分布式锁的优劣" class="headerlink" title="基于Redis和Zookeeper的分布式锁的优劣"></a>基于Redis和Zookeeper的分布式锁的优劣</h1><ul>
<li>Redis是nosql数据库，主要特点是缓存；</li>
<li>Zookeeper是分布式协调工具，主要用于分布式解决方案。</li>
</ul>
<p><strong>加锁机制</strong></p>
<ul>
<li>Redis: 通过<code>set</code>方法创建key， 因为Redis的key是唯一的，谁先创建成功，谁能够先获得锁。</li>
<li>Zookeeper: 会在Zookeeper上创建一个临时节点，因为Zookeeper节点命名路径保证唯一，只要谁先创建成功，谁能够获取到锁。</li>
</ul>
<p><strong>释放锁</strong></p>
<ul>
<li>Redis: 为了确保锁的一致性问题，在删除的redis的key时，需要判断是否是之前拥有该锁的客户端；通过设置有效期解决死锁。</li>
<li>Zookeeper: 直接关闭临时节点session会话连接，因为临时节点生命周期与session会话绑定在一块，如果session会话连接关闭的话，该临时节点也会被删除。</li>
</ul>
<p>就性能而言，redis是Nosql数据库，性能优于zookeeper;就健壮性而言，zookeeper明显优于redis。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/01/11/redo日志、undo日志、binlog日志与doulewrite操作/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2020/01/17/轻量级分布式锁的设计原理分析及实现/';
var disqus_title = '轻量级分布式锁的设计原理分析与实现';
var disqus_url = 'https://github.com/spurstong/2020/01/17/轻量级分布式锁的设计原理分析及实现/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2018 - 2020 <a href="https://github.com/spurstong">Mara Tong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>