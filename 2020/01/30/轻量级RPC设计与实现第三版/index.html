<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 轻量级RPC设计与实现第三版 · 房东的小黑</title><meta name="description" content="轻量级RPC设计与实现第三版 - Mara Tong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/spurstong/atom.xml" title="房东的小黑"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/black.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">JIANSHU</a></li><li class="nav-list-item"><a href="https://github.com/spurstong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">房东的小黑黑</a></li></ul><div class="mySign">路途虽遥远，将来更美好</div></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">轻量级RPC设计与实现第三版</h1><div class="post-info">2020年1月30日</div><div class="post-content"><p>在前两个版本中，每次发起请求一次就新建一个netty的channel连接，如果在高并发情况下就会造成资源的浪费，这时实现<strong>异步请求</strong>就十分重要，当有多个请求线程时，需要设计一个<strong>线程池</strong>来进行管理。除此之外，当前方法过于依赖注册中心，在高并发情况下对注册中心造成了压力；另外如果注册中心出现宕机等情况，那么整合系统就崩溃了，为了解决这个问题，添加了一个<strong>适合高并发的服务缓存机制</strong>。以上为该版本的新增内容。</p>
<h1 id="异步请求和线程池"><a href="#异步请求和线程池" class="headerlink" title="异步请求和线程池"></a>异步请求和线程池</h1><p>这里就不具体介绍异步请求的概念了。用一个通俗的例子解释，如你在饭店点餐，当你点好餐后，会得到一个点餐号，但是饭菜并不会立即做好送过，需要你等待一段时间，在这个时间段中，你可以做其他的事情，当饭菜做好后，会根据点餐号进行广播，通知你去拿饭菜。这就是一个典型的异步处理。<br>在项目中涉及到异步的主要有三个自定义类，即<code>ChannelHolder</code>,<code>LwRequestPool</code>和<code>LwRequestManager</code>。<br>在<code>ChannelHolder</code>中定义的变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Channel channel;</span><br><span class="line">    <span class="keyword">private</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>LwRequestManager</code>中的变量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, ChannelHolder&gt; channelHolderMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService requestExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">30</span>, <span class="number">100</span>, <span class="number">0</span>, TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">30</span>),</span><br><span class="line">            <span class="keyword">new</span> BasicThreadFactory.Builder().namingPattern(<span class="string">"request-service-connector-%d"</span>).build());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LwRequestPool requestPool = SpringBeanFactory.getBean(LwRequestPool.class);</span><br></pre></td></tr></table></figure>

<p>在<code>LwRequestPool</code>中定义的变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Promise&lt;LwResponse&gt;&gt; requestPool = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>

<p>刚开始在动态代理中会调用<code>send()</code>方法，开始了有关异步调用的内容。通过requestId来确定是哪个请求，利用线程池执行netty客户端的运行，并利用<code>CountDownLatch</code>来先暂停下面代码的运行，如果latch执行了countDown()方法，会再返回这里执行下面的步骤。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(LwRequest request, URL url)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">      String requestId = request.getRequestId();</span><br><span class="line">      CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">      requestExecutor.execute(<span class="keyword">new</span> NettyClient(requestId, url, latch));</span><br><span class="line">      latch.await();</span><br><span class="line">      ChannelHolder channelHolder = channelHolderMap.get(requestId);</span><br><span class="line">      channelHolder.getChannel().writeAndFlush(request);</span><br><span class="line">      log.info(<span class="string">"客户端发送消息：&#123;&#125;"</span>, channelHolder);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>之后运行Netty客户端中的run()方法，如果与服务端连接成功，将该请求id和对应的channel注册到<code>channelHolderMap</code>变量中，并执行<code>submitRequest</code>方法，将请求id和eventLoop注册到变量<code>requestPool</code>中。最后执行了<code>countDown()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">5000</span>)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> LengthFieldBasedFrameDecoder(<span class="number">65535</span>, <span class="number">0</span>, <span class="number">4</span>));</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> LwRpcEncoder(LwRequest.class, <span class="keyword">new</span> HessianSerializer()));</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> LwRpcDecoder(LwResponse.class, <span class="keyword">new</span> HessianSerializer()));</span><br><span class="line">                        pipeline.addLast(clientHandler);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ChannelFuture future = bootstrap.connect(url.getHostname(), url.getPort()).sync();</span><br><span class="line">            <span class="comment">//连接成功</span></span><br><span class="line">            <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                ChannelHolder channelHolder = ChannelHolder.builder()</span><br><span class="line">                        .channel(future.channel())</span><br><span class="line">                        .eventLoopGroup(group).build();</span><br><span class="line">                LwRequestManager.registerChannelHolder(requestId, channelHolder);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">requestPool.submitRequest(requestId, channelHolder.getChannel().eventLoop());</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submitRequest</span><span class="params">(String requestId, EventExecutor executor)</span> </span>&#123;</span><br><span class="line">        requestPool.put(requestId, <span class="keyword">new</span> DefaultPromise&lt;&gt;(executor));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>当执行了<code>countDown()</code>方法，会跳转到原来最初的地方，执行剩下的代码部分，进行请求发送。等待服务端的响应。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelHolder channelHolder = channelHolderMap.get(requestId);</span><br><span class="line">        channelHolder.getChannel().writeAndFlush(request);</span><br></pre></td></tr></table></figure>

<p>当客户端接收到服务端发回的结果信息时，会执行<code>notifyRequest</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, LwResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        lwRequestPool.notifyRequest(response.getRequestId(), response);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>notifyRequest</code>方法中，会从变量<code>requestPool</code>中获取到返回的<code>LwResponse</code>变量，并封装在<code>Promise</code>中,最后调用setsuccess()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyRequest</span><span class="params">(String requestId, LwResponse response)</span> </span>&#123;</span><br><span class="line">        Promise&lt;LwResponse&gt; promise = requestPool.get(requestId);</span><br><span class="line">        <span class="keyword">if</span> (promise != <span class="keyword">null</span>) &#123;</span><br><span class="line">            promise.setSuccess(response);</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><code>setsuccess()</code>方法是netty的Promise中的方法。它会通知所有的监听器。在官方解释如下：<br><code>Marks this future as a success and notifies all</code><br>此时就可以通过<code>fetchResponse</code>根据请求id获取到了服务端发送过来的消息，此时已经执行完毕，需要从<code>requestpool</code>中删除该请求信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LwResponse response = lwRequestPool.fetchResponse(requestId);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> LwResponse <span class="title">fetchResponse</span><span class="params">(String requestId)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       Promise&lt;LwResponse&gt; promise = requestPool.get(requestId);</span><br><span class="line">       <span class="keyword">if</span> (promise == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       LwResponse response = promise.get(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">       requestPool.remove(requestId);</span><br><span class="line"></span><br><span class="line">       LwRequestManager.destroyChannelHolder(requestId);</span><br><span class="line">       <span class="keyword">return</span> response;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h1 id="高并发下的缓存机制"><a href="#高并发下的缓存机制" class="headerlink" title="高并发下的缓存机制"></a>高并发下的缓存机制</h1><p>在原来的版本中，每次请求远程服务时，都需要从注册中心获取服务地址，在高并发情况下，会对注册中心造成一定的影响；或者如果注册中心突然宕机，那么就无法获取待服务地址，整个系统就崩溃了。所以设计一个缓存机制，将请求到的服务地址持久化到本地，当下次请求时，就无须再需要注册中心了，直接从持久化文件中获取，减轻了注册中心的压力。</p>
<p>在进行本地缓存时，会先调用<code>saveServices</code>方法，将URL数组信息保存到<code>Properties</code>中，并获取当前<code>version</code>版本号，然后执行<code>doSaveProperties</code>方法来保存到本地。这个步骤支持同步和异步两种方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveServices</span><span class="params">(String serviceName, List&lt;URL&gt; urlList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (file == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(URL url : urlList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (buf.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    buf.append(<span class="string">";"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                buf.append(url.getAllInformation());</span><br><span class="line">            &#125;</span><br><span class="line">            properties.setProperty(serviceName, buf.toString());</span><br><span class="line">            <span class="keyword">long</span> version = lastCacheChanged.incrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (syncSaveFile) &#123;</span><br><span class="line">                doSaveProperties(version);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                registerCacheExecutor.execute(<span class="keyword">new</span> SaveProperties(version));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable  t) &#123;</span><br><span class="line">            log.warn(t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>doSaveProperties</code>方法中，如果传入的版本号不是最新的版本号，说明其他线程已经修改了，内容发生了变化，直接退出。在写入到文件时会添加锁，进一步保证信息的准确性。如果添加失败，会进行重试操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSaveProperties</span><span class="params">(<span class="keyword">long</span> version)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (version &lt; lastCacheChanged.get())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (file == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File lockfile = <span class="keyword">new</span> File(file.getAbsolutePath() + <span class="string">".lock"</span>);</span><br><span class="line">            <span class="keyword">if</span> (!lockfile.exists()) &#123;</span><br><span class="line">                lockfile.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>(RandomAccessFile raf = <span class="keyword">new</span> RandomAccessFile(lockfile, <span class="string">"rw"</span>);</span><br><span class="line">            FileChannel channel = raf.getChannel();) &#123;</span><br><span class="line">                FileLock lock = channel.tryLock();</span><br><span class="line">                <span class="keyword">if</span> (lock == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"不能锁住注册的缓存文件"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">                        file.createNewFile();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> (FileOutputStream outputFile = <span class="keyword">new</span> FileOutputStream(file)) &#123;</span><br><span class="line">                        properties.store(outputFile, <span class="string">"RPC Server Cache"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            savePropertiesRetryTimes.incrementAndGet();</span><br><span class="line">            <span class="keyword">if</span> (savePropertiesRetryTimes.get() &gt; SAVE_MAX_RETRY) &#123;</span><br><span class="line">                log.warn(<span class="string">"超过最大重试次数，缓存失败！"</span>);</span><br><span class="line">                savePropertiesRetryTimes.set(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (version &lt; lastCacheChanged.get()) &#123;</span><br><span class="line">                savePropertiesRetryTimes.set(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>具体详细代码可以到我的项目中进行查看<a href="https://github.com/spurstong/lightWeightRpc/tree/lightweightrpcv3">轻量级RPC第三版</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/02/02/轻量级RPC设计与实现第四版/" class="prev">上一篇</a><a href="/2020/01/27/轻量级RPC设计与实现第二版/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2020/01/30/轻量级RPC设计与实现第三版/';
var disqus_title = '轻量级RPC设计与实现第三版';
var disqus_url = 'https://github.com/spurstong/2020/01/30/轻量级RPC设计与实现第三版/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2018 - 2020 <a href="https://github.com/spurstong">Mara Tong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>