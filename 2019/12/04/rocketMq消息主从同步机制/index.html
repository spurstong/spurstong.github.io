<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> rocketMq消息主从同步机制 · 房东的小黑</title><meta name="description" content="rocketMq消息主从同步机制 - Mara Tong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/spurstong/atom.xml" title="房东的小黑"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/black.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">JIANSHU</a></li><li class="nav-list-item"><a href="https://github.com/spurstong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">房东的小黑黑</a></li></ul><div class="mySign">路途虽遥远，将来更美好</div></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">rocketMq消息主从同步机制</h1><div class="post-info">2019年12月4日</div><div class="post-content"><p>RocketMQ具有高可用性，消息消费到达主服务器Master后需要将消息同步到消息从服务器Slave,如果主服务器Master宕机后，消息消费者可以向Slave拉取消息。</p>
<h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p>主服务器Master启动，监听从服务器Slave的监听；从服务器Slave启动，主动向主服务器建立Tcp长连接，然后获取从服务器Slave的commitlog的最大偏移量，以此偏移量向主服务器Master主动拉取消息（间隔5s发送一次），主服务器根据偏移量，与自身commitlog文件的最大偏移量进行比较，如果大于Slave的最大偏移量，主服务器Master将向从服务器Slave返回一定数量的消息，将消息写入到Slave的commitlog文件中，该过程循环进行，如果从服务器Slave的最大偏移量大于等于主服务器Master的最大偏移量，说明主从服务器数据同步完成。</p>
<h1 id="相关类介绍"><a href="#相关类介绍" class="headerlink" title="相关类介绍"></a>相关类介绍</h1><p>HAservice: 主从同步核心实现类<br>AcceptSocketService： HA Master端监听客户端连接实现类<br>GroupTransferService: 主从同步通知实现类<br>HAClient: HA Client端实现类（从服务器）<br>HAConnection: HA Master服务端HA连接对象的封装，与Broker从服务器的网络读写实现类<br>ReadSocketService: HA Master网络读实现类<br>WriterSocketService: HA Master网络写实现类</p>
<h1 id="主从同步Slave端实现"><a href="#主从同步Slave端实现" class="headerlink" title="主从同步Slave端实现"></a>主从同步Slave端实现</h1><p>相关类是HAClient</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HAClient</span> <span class="keyword">extends</span> <span class="title">ServiceThread</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READ_MAX_BUFFER_SIZE = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>;</span><br><span class="line">        <span class="comment">// 主节点IP:PORT</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;String&gt; masterAddress = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">        <span class="comment">// 向Master汇报Slave最大Offset</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer reportOffset = ByteBuffer.allocate(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> lastWriteTimestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// Slave向Master汇报Offset，汇报到哪里</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> currentReportedOffset = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> dispatchPostion = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 从Master接收数据Buffer</span></span><br><span class="line">        <span class="keyword">private</span> ByteBuffer byteBufferRead = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);</span><br><span class="line">        <span class="keyword">private</span> ByteBuffer byteBufferBackup = ByteBuffer.allocate(READ_MAX_BUFFER_SIZE);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与Master进行连接</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">connectMaster</span><span class="params">()</span> <span class="keyword">throws</span> ClosedChannelException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == socketChannel) &#123;</span><br><span class="line">                String addr = <span class="keyword">this</span>.masterAddress.get();</span><br><span class="line">                <span class="keyword">if</span> (addr != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    SocketAddress socketAddress = RemotingUtil.string2SocketAddress(addr);</span><br><span class="line">                    <span class="keyword">if</span> (socketAddress != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.socketChannel = RemotingUtil.connect(socketAddress);</span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">this</span>.socketChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">this</span>.socketChannel.register(<span class="keyword">this</span>.selector, SelectionKey.OP_READ);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 每次连接时，要重新拿到最大的Offset</span></span><br><span class="line">                <span class="keyword">this</span>.currentReportedOffset = HAService.<span class="keyword">this</span>.defaultMessageStore.getMaxPhyOffset();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.lastWriteTimestamp = System.currentTimeMillis();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.socketChannel != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>Slave服务器连接Master服务器，获取当前文件的最大偏移量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isTimeToReportOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">long</span> interval =</span><br><span class="line">               HAService.<span class="keyword">this</span>.defaultMessageStore.getSystemClock().now() - <span class="keyword">this</span>.lastWriteTimestamp;</span><br><span class="line">           <span class="keyword">boolean</span> needHeart = interval &gt; HAService.<span class="keyword">this</span>.defaultMessageStore.getMessageStoreConfig()</span><br><span class="line">               .getHaSendHeartbeatInterval();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> needHeart;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>判断是否向Master反馈当前待拉取偏移量，默认间隔5s发送一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">reportSlaveMaxOffset</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> maxOffset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.reportOffset.position(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">this</span>.reportOffset.limit(<span class="number">8</span>);</span><br><span class="line">  <span class="keyword">this</span>.reportOffset.putLong(maxOffset);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.reportOffset.position(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">this</span>.reportOffset.limit(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送失败了试三次，成功就成功</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span> &amp;&amp; <span class="keyword">this</span>.reportOffset.hasRemaining(); i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.socketChannel.write(<span class="keyword">this</span>.reportOffset);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">log.error(<span class="keyword">this</span>.getServiceName()</span><br><span class="line">+ <span class="string">"reportSlaveMaxOffset this.socketChannel.write exception"</span>, e);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> !<span class="keyword">this</span>.reportOffset.hasRemaining();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>向Master服务器反馈拉取偏移量，如果发送失败，会再进行尝试，总共三次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">processReadEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> readSizeZeroTimes = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.byteBufferRead.hasRemaining()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> readSize = <span class="keyword">this</span>.socketChannel.read(<span class="keyword">this</span>.byteBufferRead);</span><br><span class="line">                    <span class="keyword">if</span> (readSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        lastWriteTimestamp = HAService.<span class="keyword">this</span>.defaultMessageStore.getSystemClock().now();</span><br><span class="line">                        readSizeZeroTimes = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">boolean</span> result = <span class="keyword">this</span>.dispatchReadRequest();</span><br><span class="line">                        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                            log.error(<span class="string">"HAClient, dispatchReadRequest error"</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readSize == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (++readSizeZeroTimes &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// TODO ERROR</span></span><br><span class="line">                        log.info(<span class="string">"HAClient, processReadEvent read socket &lt; 0"</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    log.info(<span class="string">"HAClient, processReadEvent read socket exception"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>处理网络请求，即处理从Master服务器传回的消息数据。循环判断readByteBuffer是否有剩余空间，如果存在剩余空间，则将通道里的数据读入到读缓存区中。<br> 1） 如果读取到的字节数大于0，重置读取到0字节的次数，并更新最后一次写入时间戳，然后将读取到的所有消息全部追加到消息内存映射文件中，然后再次反馈拉取进度给服务器。<br> 2） 如果连续3次从网络通道里读取到0个字节，则结束本次读，并返回true。<br> 3） 如果读取到的字节数小于0或发生IO异常，则返回false。</p>
<h1 id="主服务器Master处理请求"><a href="#主服务器Master处理请求" class="headerlink" title="主服务器Master处理请求"></a>主服务器Master处理请求</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HAConnection</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HAService haService;</span><br><span class="line">    <span class="comment">// 网络socket通道</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="comment">// 客户端连接地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String clientAddr;</span><br><span class="line">    <span class="comment">// 服务端向从服务器slave写数据服务类</span></span><br><span class="line">    <span class="keyword">private</span> WriteSocketService writeSocketService;</span><br><span class="line">    <span class="comment">// 服务端从从服务器slave读数据服务类</span></span><br><span class="line">    <span class="keyword">private</span> ReadSocketService readSocketService;</span><br><span class="line">    <span class="comment">// 从服务器slave请求拉取数据的偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> slaveRequestOffset = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从服务器slave反馈已拉取完成的数据偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> slaveAckOffset = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>Master服务器每隔1s处理一次slave发起的拉取请求。<br>首先会调用proccessReadEvent方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">processReadEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> readSizeZeroTimes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.byteBufferRead.hasRemaining()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.byteBufferRead.flip();</span><br><span class="line">                <span class="keyword">this</span>.processPostion = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.byteBufferRead.hasRemaining()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> readSize = <span class="keyword">this</span>.socketChannel.read(<span class="keyword">this</span>.byteBufferRead);</span><br><span class="line">                    <span class="keyword">if</span> (readSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        readSizeZeroTimes = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">this</span>.lastReadTimestamp = HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getSystemClock().now();</span><br><span class="line">                        <span class="keyword">if</span> ((<span class="keyword">this</span>.byteBufferRead.position() - <span class="keyword">this</span>.processPostion) &gt;= <span class="number">8</span>) &#123;</span><br><span class="line">                            <span class="keyword">int</span> pos = <span class="keyword">this</span>.byteBufferRead.position() - (<span class="keyword">this</span>.byteBufferRead.position() % <span class="number">8</span>);</span><br><span class="line">                            <span class="keyword">long</span> readOffset = <span class="keyword">this</span>.byteBufferRead.getLong(pos - <span class="number">8</span>);</span><br><span class="line">                            <span class="keyword">this</span>.processPostion = pos;</span><br><span class="line"></span><br><span class="line">                            HAConnection.<span class="keyword">this</span>.slaveAckOffset = readOffset;</span><br><span class="line">                            <span class="keyword">if</span> (HAConnection.<span class="keyword">this</span>.slaveRequestOffset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                                HAConnection.<span class="keyword">this</span>.slaveRequestOffset = readOffset;</span><br><span class="line">                                log.info(<span class="string">"slave["</span> + HAConnection.<span class="keyword">this</span>.clientAddr + <span class="string">"] request offset "</span> + readOffset);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            HAConnection.<span class="keyword">this</span>.haService.notifyTransferSome(HAConnection.<span class="keyword">this</span>.slaveAckOffset);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readSize == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (++readSizeZeroTimes &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        log.error(<span class="string">"read socket["</span> + HAConnection.<span class="keyword">this</span>.clientAddr + <span class="string">"] &lt; 0"</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    log.error(<span class="string">"processReadEvent exception"</span>, e);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>1) 如果byteBufferRead没有剩余空间，则调用byteBufferRead.flip()清空，并设置processPostion为0，表示从头开始处理。<br>2) 当byteBuffer有剩余空间时，先预设readSizeZeroTimes为0，如果读取的字节大于0并且本次读取到的内容大于8，则表明收到了从服务器Slave一条拉取消息的请求，并调用<strong>notifyTransferSome</strong>方法。<br>3) 如果读取到的字节数等于0，则判断readSizeZeroTimes，当小于3时需要再进行循环处理，如果大于3，说明该批次请求已成功处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyTransferSome</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">long</span> value = <span class="keyword">this</span>.push2SlaveMaxOffset.get(); offset &gt; value; ) &#123;</span><br><span class="line">           <span class="keyword">boolean</span> ok = <span class="keyword">this</span>.push2SlaveMaxOffset.compareAndSet(value, offset);</span><br><span class="line">           <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">               <span class="keyword">this</span>.groupTransferService.notifyTransferSome();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               value = <span class="keyword">this</span>.push2SlaveMaxOffset.get();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>该方法的参数offset记录的是从服务器slave反馈的已拉取完成的数据偏移量，<br>push2SlaveMaxOffset记录的是写入到Slave的最大偏移量。<br>如果从服务器slave确认的偏移量大于push2SlaveMaxOffset,说明该批次主从同步成功，并更新push2SlaveMaxOffset,<br>则唤醒GroupTransferService线程，各消息发送者线程再次判断自己</p>
<p>然后介绍WriteSocketService线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (-<span class="number">1</span> == HAConnection.<span class="keyword">this</span>.slaveRequestOffset) &#123;</span><br><span class="line">    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>

<p>如果<strong>slaveRequestOffset</strong>等于-1，说明Master还未收到从服务器的拉取请求，放弃本事件的处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (-<span class="number">1</span> == <span class="keyword">this</span>.nextTransferFromWhere) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (<span class="number">0</span> == HAConnection.<span class="keyword">this</span>.slaveRequestOffset) &#123;</span><br><span class="line">                           <span class="keyword">long</span> masterOffset = HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getCommitLog().getMaxOffset();</span><br><span class="line">                           masterOffset =</span><br><span class="line">                               masterOffset</span><br><span class="line">                                   - (masterOffset % HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig()</span><br><span class="line">                                   .getMapedFileSizeCommitLog());</span><br><span class="line"></span><br><span class="line">                           <span class="keyword">if</span> (masterOffset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                               masterOffset = <span class="number">0</span>;</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                           <span class="keyword">this</span>.nextTransferFromWhere = masterOffset;</span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="keyword">this</span>.nextTransferFromWhere = HAConnection.<span class="keyword">this</span>.slaveRequestOffset;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       log.info(<span class="string">"master transfer data from "</span> + <span class="keyword">this</span>.nextTransferFromWhere + <span class="string">" to slave["</span> + HAConnection.<span class="keyword">this</span>.clientAddr</span><br><span class="line">                           + <span class="string">"], and slave request "</span> + HAConnection.<span class="keyword">this</span>.slaveRequestOffset);</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure>

<p>如果<strong>nextTransferFromWhere</strong>等于-1，表示初次进行数据传输，计算待传输的物理偏移量，如果slaveRequestOffset为0，则从当前commitlog文件最大偏移量开始传输，否则根据从服务器的拉取请求偏移量开始传输。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.lastWriteOver) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">long</span> interval =</span><br><span class="line">                            HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getSystemClock().now() - <span class="keyword">this</span>.lastWriteTimestamp;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (interval &gt; HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig()</span><br><span class="line">                            .getHaSendHeartbeatInterval()) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// Build Header</span></span><br><span class="line">                            <span class="keyword">this</span>.byteBufferHeader.position(<span class="number">0</span>);</span><br><span class="line">                            <span class="keyword">this</span>.byteBufferHeader.limit(headerSize);</span><br><span class="line">                            <span class="keyword">this</span>.byteBufferHeader.putLong(<span class="keyword">this</span>.nextTransferFromWhere);</span><br><span class="line">                            <span class="keyword">this</span>.byteBufferHeader.putInt(<span class="number">0</span>);</span><br><span class="line">                            <span class="keyword">this</span>.byteBufferHeader.flip();</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">this</span>.lastWriteOver = <span class="keyword">this</span>.transferData();</span><br><span class="line">                            <span class="keyword">if</span> (!<span class="keyword">this</span>.lastWriteOver)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">this</span>.lastWriteOver = <span class="keyword">this</span>.transferData();</span><br><span class="line">                        <span class="keyword">if</span> (!<span class="keyword">this</span>.lastWriteOver)</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>

<p>判断上次写事件是否已将消息全部写入客户端，如果已全部写入，并且当前系统时间与上次最后写入的时间间隔大于HA心跳检测时间，则发送一个心跳包，避免长连接由于空闲被关闭；如果上次数据未写完，则先传输上一次的数据，如果消息还是未全部传输，则结束此次事件处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SelectMappedBufferResult selectResult =</span><br><span class="line">                        HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getCommitLogData(<span class="keyword">this</span>.nextTransferFromWhere);</span><br><span class="line">                    <span class="keyword">if</span> (selectResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> size = selectResult.getSize();</span><br><span class="line">                        <span class="keyword">if</span> (size &gt; HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize()) &#123;</span><br><span class="line">                            size = HAConnection.<span class="keyword">this</span>.haService.getDefaultMessageStore().getMessageStoreConfig().getHaTransferBatchSize();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">long</span> thisOffset = <span class="keyword">this</span>.nextTransferFromWhere;</span><br><span class="line">                        <span class="keyword">this</span>.nextTransferFromWhere += size;</span><br><span class="line"></span><br><span class="line">                        selectResult.getByteBuffer().limit(size);</span><br><span class="line">                        <span class="keyword">this</span>.selectMappedBufferResult = selectResult;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Build Header</span></span><br><span class="line">                        <span class="keyword">this</span>.byteBufferHeader.position(<span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">this</span>.byteBufferHeader.limit(headerSize);</span><br><span class="line">                        <span class="keyword">this</span>.byteBufferHeader.putLong(thisOffset);</span><br><span class="line">                        <span class="keyword">this</span>.byteBufferHeader.putInt(size);</span><br><span class="line">                        <span class="keyword">this</span>.byteBufferHeader.flip();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">this</span>.lastWriteOver = <span class="keyword">this</span>.transferData();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        HAConnection.<span class="keyword">this</span>.haService.getWaitNotifyObject().allWaitForRunning(<span class="number">100</span>);</span><br><span class="line">                    &#125;</span><br></pre></td></tr></table></figure>

<p>传输消息到从服务器slave<br>1) 根据消息从服务器slave请求的待拉取偏移量，查找该偏移量之后的所有的可读消息，如果未查到匹配的消息，通知所有等待线程继续等待100ms。<br>2) 如果匹配到消息，且查找到的消息总长度大于配置的一次传输最大字节数，则会进行截取，可能会包含不完整的消息。</p>
<p>主服务器Master会一直执行该线程，每次事件处理完成后等待1s。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWaitTransfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">synchronized</span> (<span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!<span class="keyword">this</span>.requestsRead.isEmpty()) &#123;</span><br><span class="line">                   <span class="keyword">for</span> (CommitLog.GroupCommitRequest req : <span class="keyword">this</span>.requestsRead) &#123;</span><br><span class="line">                       <span class="keyword">boolean</span> transferOK = HAService.<span class="keyword">this</span>.push2SlaveMaxOffset.get() &gt;= req.getNextOffset();</span><br><span class="line">                       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; !transferOK &amp;&amp; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                           <span class="keyword">this</span>.notifyTransferObject.waitForRunning(<span class="number">1000</span>);</span><br><span class="line">                           transferOK = HAService.<span class="keyword">this</span>.push2SlaveMaxOffset.get() &gt;= req.getNextOffset();</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">if</span> (!transferOK) &#123;</span><br><span class="line">                           log.warn(<span class="string">"transfer messsage to slave timeout, "</span> + req.getNextOffset());</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       req.wakeupCustomer(transferOK);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">this</span>.requestsRead.clear();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<p>GroupTransferService#doWaitTransfer()方法<br>该类是主从同步复制的实现类</p>
<p>在进行主从同步时，有同步主从模式和异步主从模式，当主服务器Master发送消息给从服务器Slave时，需要先判断上一次同步主从复制的结果，如果Slave中已成功复制的最大偏移量是否大于Master发送给Slave消息后返回的下一条消息的起始偏移量，如果大于，则说明上一个主从同步复制已经完成，则会唤醒阻塞等待的消息发送到Slave的命令。</p>
<p>RocketMq读写分离与其他中间件的实现方式完全不同，RoketMq是消息者首先向主服务器Master发起拉取消息请求，然后主服务器返回一批消息，然后会根据主服务器负载压力与主从同步情况，建议下次消息拉取是从主服务器还是从从服务器拉取。</p>
<p>决定消费者是否向从服务器拉取消息消费的值存在 GetMessageResult 类中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> suggestPullingFromSlave = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<p>其默认值为 false，即默认消费者不会消费从服务器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> diff = maxOffsetPy - maxPhyOffsetPulling;</span><br><span class="line"><span class="keyword">long</span> memory = (<span class="keyword">long</span>) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE</span><br><span class="line">    * (<span class="keyword">this</span>.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / <span class="number">100.0</span>));</span><br><span class="line">getResult.setSuggestPullingFromSlave(diff &gt; memory);</span><br></pre></td></tr></table></figure>

<p>其中 maxOffsetPy 为当前最大物理偏移量，maxPhyOffsetPulling 为本次消息拉取最大物理偏移量，他们的差即可表示消息堆积量，TOTAL_PHYSICAL_MEMORY_SIZE 表示当前系统物理内存，accessMessageInMemoryMaxRatio 的默认值为 40，以上逻辑即可算出当前消息堆积量是否大于物理内存的 40 %，如果大于则将 suggestPullingFromSlave 设置为 true。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/01/11/redo日志、undo日志、binlog日志与doulewrite操作/" class="prev">上一篇</a><a href="/2019/11/30/RocketMQ消费者消息队列负载均衡/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2019/12/04/rocketMq消息主从同步机制/';
var disqus_title = 'rocketMq消息主从同步机制';
var disqus_url = 'https://github.com/spurstong/2019/12/04/rocketMq消息主从同步机制/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2018 - 2020 <a href="https://github.com/spurstong">Mara Tong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>