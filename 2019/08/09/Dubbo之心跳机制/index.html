<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Dubbo之心跳机制 · 房东的小黑</title><meta name="description" content="Dubbo之心跳机制 - Mara Tong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/spurstong/atom.xml" title="房东的小黑"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/black.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">JIANSHU</a></li><li class="nav-list-item"><a href="https://github.com/spurstong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">房东的小黑黑</a></li></ul><div class="mySign">加油</div></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Dubbo之心跳机制</h1><div class="post-info">2019年8月9日</div><div class="post-content"><p>在网络传输中，怎么确保通道连接的可用性是一个很重要的问题，简单的说，在网络通信中有客户端和服务端，一个负责发送请求，一个负责接收请求，在保证连接有效性的背景下，这两个物体扮演了什么角色，心跳机制能有效的保证连接的可用性，那它的机制是什么，下文中将会详细讲解。</p>
<a id="more"></a>
<p>在网络传输中，怎么确保通道连接的可用性是一个很重要的问题，简单的说，在网络通信中有客户端和服务端，一个负责发送请求，一个负责接收请求，在保证连接有效性的背景下，这两个物体扮演了什么角色，心跳机制能有效的保证连接的可用性，那它的机制是什么，下文中将会详细讲解。</p>
<h1 id="网络层的可用性"><a href="#网络层的可用性" class="headerlink" title="网络层的可用性"></a>网络层的可用性</h1><p>首先讲一下TCP,在dubbo中的通信是基于TCP的，TCP本身并没有长短连接的区别，在短连接中，每次通信时，都会创建Socket,当该次通信结束后，就会调用socket.close()；而在长连接中，每次通信完毕后，不会关闭连接，这样就可以做到连接的复用，长连接的好处是省去了创建连接时的耗时。那么如何确保连接的有效性呢，在TCP中用到了<strong>KeepAlive机制</strong>，keepalive并不是TCP协议的一部分，但是大多数操作系统都实现了这个机制，在一定时间内，在链路上如果<strong>没有数据传送的情况下</strong>，TCP层将会发送相应的keepalive探针来确定连接可用性，探测失败后重试10次（<code>tcp_keepalive_probes</code>）,每次间隔时间为75s(<code>tcp_keepalive_intvl</code>),所有探测失败后，才认为当前连接已经不可用了。</p>
<p>KeepAlive机制是在网络层保证了连接的可用性，但在应用层我们认为这还是不够的。</p>
<ul>
<li>KeepAlive的报活机制只有在链路空闲的情况下才会起作用，假如此时有数据发送，且物理链路已经不通，操作系统这边的链路状态还是E    STABLISHED,这时会发生TCP重传机制，要知道默认的TCP超时重传，指数退避算法也是一个相当长的过程。</li>
<li>KeepAlive本身是面向网络的，并不是面向于应用的，可能是由于本身GC问题，系统load高等情况，但网络依然是通的，此时，应用已经失去了活性，所以连接自然认为是不可用的。<h1 id="应用层的连接可用性：心跳机制"><a href="#应用层的连接可用性：心跳机制" class="headerlink" title="应用层的连接可用性：心跳机制"></a>应用层的连接可用性：心跳机制</h1>如何理解应用层的心跳？简单的说，就是客户端会开启一个<strong>定时任务</strong>，定时对已经建立连接的对端应用发送请求，服务端则需要特殊处理该请求，返回响应。如果心跳持续多次没有收到响应，客户端会认为连接不可用，主动断开连接。</li>
</ul>
<h2 id="客户端如何得知请求失败了？"><a href="#客户端如何得知请求失败了？" class="headerlink" title="客户端如何得知请求失败了？"></a>客户端如何得知请求失败了？</h2><p>在失败的场景下，服务端是不会返回响应的，所以只能在客户端自身上设计了。<br>当客户端发起一个RPC请求时，会设置一个超时时间client_timeout,同时它也会开启一个延迟的client_timeout的定时器。当接收到正常响应时，会移除该定时器；而当计时器倒计时完毕后，还没有被移除，则会认为请求超时，构造一个失败的响应传递给客户端。</p>
<h2 id="连接建立时创建定时器"><a href="#连接建立时创建定时器" class="headerlink" title="连接建立时创建定时器"></a>连接建立时创建定时器</h2><p>HeaderExchangeClient类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HeaderExchangeClient</span><span class="params">(Client client, <span class="keyword">boolean</span> needHeartbeat)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"client == null"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">this</span>.client = client;</span><br><span class="line">       <span class="comment">// 创建信息交换通道</span></span><br><span class="line">       <span class="keyword">this</span>.channel = <span class="keyword">new</span> HeaderExchangeChannel(client);</span><br><span class="line">       <span class="comment">// 获得dubbo版本</span></span><br><span class="line">       String dubbo = client.getUrl().getParameter(Constants.DUBBO_VERSION_KEY);</span><br><span class="line">       <span class="comment">//获得心跳周期配置，如果没有配置，并且dubbo是1.0版本的，则这只为1分钟，否则设置为0</span></span><br><span class="line">       <span class="keyword">this</span>.heartbeat = client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo != <span class="keyword">null</span> &amp;&amp; dubbo.startsWith(<span class="string">"1.0."</span>) ? Constants.DEFAULT_HEARTBEAT : <span class="number">0</span>);</span><br><span class="line">       <span class="comment">// 获得心跳超时配置，默认是心跳周期的三倍</span></span><br><span class="line">       <span class="keyword">this</span>.heartbeatTimeout = client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * <span class="number">3</span>);</span><br><span class="line">  			     </span><br><span class="line">       <span class="keyword">if</span> (needHeartbeat) &#123;</span><br><span class="line">           <span class="comment">// 开启心跳</span></span><br><span class="line">         <span class="keyword">long</span> tickDuration = calculateLeastDuration(heartbeat);</span><br><span class="line">         heartbeatTimer = <span class="keyword">new</span> HashedWheelTimer(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"dubbo-client-heartbeat"</span>, <span class="keyword">true</span>) , tickDuration, TimeUnit.MILLISECONDS, Constants.TICKS_PER_WHEEL);</span><br><span class="line">         startHeartbeatTimer();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>创建了一个<code>HashedWheelTimer</code>开启心跳检测，这是 Netty 所提供的一个经典的时间轮定时器实现。</p>
<p><code>HeaderExchangeServer</code>也同时开启了定时器，代码逻辑和上述差不多。</p>
<h2 id="开启两个定时任务"><a href="#开启两个定时任务" class="headerlink" title="开启两个定时任务"></a>开启两个定时任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHeartbeatTimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		   <span class="keyword">long</span> heartbeatTick = calculateLeastDuration(heartbeat); </span><br><span class="line">   <span class="keyword">long</span> heartbeatTimeoutTick = calculateLeastDuration(heartbeatTimeout);</span><br><span class="line">   HeartbeatTimerTask heartBeatTimerTask =<span class="keyword">new</span>  HeartbeatTimerTask(cp, heartbeatTick, heartbeat);</span><br><span class="line">   ReconnectTimerTask reconnectTimerTask = <span class="keyword">new</span> ReconnectTimerTask(cp, heartbeatTimeoutTick, heartbeatTimeout);</span><br><span class="line">    </span><br><span class="line">  heartbeatTimer.newTimeout(heartBeatTimerTask, heartbeatTick, TimeUnit.MILLISECONDS); </span><br><span class="line">  heartbeatTimer.newTimeout(reconnectTimerTask, heartbeatTimeoutTick, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在该方法中主要开启了两个定时器</p>
<ul>
<li><em>HeartbeatTimerTask</em> 主要是定时发送心跳请求</li>
<li><em>ReconnectTimerTask</em> 主要是心跳失败后处理重连，断连的逻辑</li>
</ul>
<h1 id="旧版的心跳处理HeartBeatTask类"><a href="#旧版的心跳处理HeartBeatTask类" class="headerlink" title="旧版的心跳处理HeartBeatTask类"></a>旧版的心跳处理HeartBeatTask类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartBeatTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HeartBeatTask.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通道管理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> ChannelProvider channelProvider;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳间隔 单位：ms</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳超时时间 单位：ms</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> heartbeatTimeout;</span><br><span class="line"></span><br><span class="line">    HeartBeatTask(ChannelProvider provider, <span class="keyword">int</span> heartbeat, <span class="keyword">int</span> heartbeatTimeout) &#123;</span><br><span class="line">        <span class="keyword">this</span>.channelProvider = provider;</span><br><span class="line">        <span class="keyword">this</span>.heartbeat = heartbeat;</span><br><span class="line">        <span class="keyword">this</span>.heartbeatTimeout = heartbeatTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 遍历所有通道</span></span><br><span class="line">            <span class="keyword">for</span> (Channel channel : channelProvider.getChannels()) &#123;</span><br><span class="line">                <span class="comment">// 如果通道关闭了，则跳过</span></span><br><span class="line">                <span class="keyword">if</span> (channel.isClosed()) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 最后一次接收到消息的时间戳</span></span><br><span class="line">                    Long lastRead = (Long) channel.getAttribute(</span><br><span class="line">                            HeaderExchangeHandler.KEY_READ_TIMESTAMP);</span><br><span class="line">                    <span class="comment">// 最后一次发送消息的时间戳</span></span><br><span class="line">                    Long lastWrite = (Long) channel.getAttribute(</span><br><span class="line">                            HeaderExchangeHandler.KEY_WRITE_TIMESTAMP);</span><br><span class="line">                    <span class="comment">// 如果最后一次接收或者发送消息到时间到现在的时间间隔超过了心跳间隔时间</span></span><br><span class="line">                    <span class="keyword">if</span> ((lastRead != <span class="keyword">null</span> &amp;&amp; now - lastRead &gt; heartbeat)</span><br><span class="line">                            || (lastWrite != <span class="keyword">null</span> &amp;&amp; now - lastWrite &gt; heartbeat)) &#123;</span><br><span class="line">                        <span class="comment">// 创建一个request</span></span><br><span class="line">                        Request req = <span class="keyword">new</span> Request();</span><br><span class="line">                        <span class="comment">// 设置版本号</span></span><br><span class="line">                        req.setVersion(Version.getProtocolVersion());</span><br><span class="line">                        <span class="comment">// 设置需要得到响应</span></span><br><span class="line">                        req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="comment">// 设置事件类型，为心跳事件</span></span><br><span class="line">                        req.setEvent(Request.HEARTBEAT_EVENT);</span><br><span class="line">                        <span class="comment">// 发送心跳请求</span></span><br><span class="line">                        channel.send(req);</span><br><span class="line">                        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                            logger.debug(<span class="string">"Send heartbeat to remote channel "</span> + channel.getRemoteAddress()</span><br><span class="line">                                    + <span class="string">", cause: The channel has no data-transmission exceeds a heartbeat period: "</span> + heartbeat + <span class="string">"ms"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果最后一次接收消息的时间到现在已经超过了超时时间</span></span><br><span class="line">                    <span class="keyword">if</span> (lastRead != <span class="keyword">null</span> &amp;&amp; now - lastRead &gt; heartbeatTimeout) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"Close channel "</span> + channel</span><br><span class="line">                                + <span class="string">", because heartbeat read idle time out: "</span> + heartbeatTimeout + <span class="string">"ms"</span>);</span><br><span class="line">                        <span class="comment">// 如果该通道是客户端，也就是请求的服务器挂掉了，客户端尝试重连服务器</span></span><br><span class="line">                        <span class="keyword">if</span> (channel <span class="keyword">instanceof</span> Client) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 重新连接服务器</span></span><br><span class="line">                                ((Client) channel).reconnect();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                                <span class="comment">//do nothing</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 如果不是客户端，也就是是服务端返回响应给客户端，但是客户端挂掉了，则服务端关闭客户端连接</span></span><br><span class="line">                            channel.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Exception when heartbeat to remote channel "</span> + channel.getRemoteAddress(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Unhandled exception when heartbeat, cause: "</span> + t.getMessage(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ChannelProvider</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获得所有的通道集合，需要心跳的通道数组</span></span><br><span class="line">        <span class="function">Collection&lt;Channel&gt; <span class="title">getChannels</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它首先遍历所有的Channel,在服务端对用的是所有客户端连接，在客户端对应的是服务端连接，判断当前TCP连接是否空闲，如果<strong>空闲</strong>就发送心跳报文，判断是否空闲，根据Channel是否有读或写来决定，比如一分钟内没有读或写就发送心跳报文，然后是处理超时的问题，处理客户端超时重新建立TCP连接，目前的策略是检查是否在3分钟内都没有成功接受或发送报文，如果在服务端检测则就会主动关闭远程客户端连接。</p>
<h1 id="新版本的心跳机制"><a href="#新版本的心跳机制" class="headerlink" title="新版本的心跳机制"></a>新版本的心跳机制</h1><h2 id="定时任务一：-发送心跳请求"><a href="#定时任务一：-发送心跳请求" class="headerlink" title="定时任务一： 发送心跳请求"></a>定时任务一： 发送心跳请求</h2><p>在新版本下，去除了HeartBeatTask类,添加了HeartbeatTimerTask和ReconnectTimerTask类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeartbeatTimerTask</span> <span class="keyword">extends</span> <span class="title">AbstractTimerTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(HeartbeatTimerTask.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> heartbeat;</span><br><span class="line"></span><br><span class="line">    HeartbeatTimerTask(ChannelProvider channelProvider, Long heartbeatTick, <span class="keyword">int</span> heartbeat) &#123;</span><br><span class="line">        <span class="keyword">super</span>(channelProvider, heartbeatTick);</span><br><span class="line">        <span class="keyword">this</span>.heartbeat = heartbeat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long lastRead = lastRead(channel);</span><br><span class="line">            Long lastWrite = lastWrite(channel);</span><br><span class="line">            <span class="keyword">if</span> ((lastRead != <span class="keyword">null</span> &amp;&amp; now() - lastRead &gt; heartbeat)</span><br><span class="line">                    || (lastWrite != <span class="keyword">null</span> &amp;&amp; now() - lastWrite &gt; heartbeat)) &#123;</span><br><span class="line">                Request req = <span class="keyword">new</span> Request();</span><br><span class="line">                req.setVersion(Version.getProtocolVersion());</span><br><span class="line">                req.setTwoWay(<span class="keyword">true</span>);</span><br><span class="line">                req.setEvent(Request.HEARTBEAT_EVENT);</span><br><span class="line">                channel.send(req);</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Send heartbeat to remote channel "</span> + channel.getRemoteAddress()</span><br><span class="line">                            + <span class="string">", cause: The channel has no data-transmission exceeds a heartbeat period: "</span></span><br><span class="line">                            + heartbeat + <span class="string">"ms"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception when heartbeat to remote channel "</span> + channel.getRemoteAddress(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Dubbo采取的是双向心跳设计，即服务端会向客户端发送心跳，客户端也会向服务端发送心跳，接收的一方更新lastread字段，发送的一方更新lastWrite字段，超过心跳间隙的时间，便发送心跳请求给对端。</p>
<h2 id="定时任务二：-处理重连和断连"><a href="#定时任务二：-处理重连和断连" class="headerlink" title="定时任务二： 处理重连和断连"></a>定时任务二： 处理重连和断连</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReconnectTimerTask</span> <span class="keyword">extends</span> <span class="title">AbstractTimerTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(ReconnectTimerTask.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> idleTimeout;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReconnectTimerTask</span><span class="params">(ChannelProvider channelProvider, Long heartbeatTimeoutTick, <span class="keyword">int</span> idleTimeout)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(channelProvider, heartbeatTimeoutTick);</span><br><span class="line">        <span class="keyword">this</span>.idleTimeout = idleTimeout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Long lastRead = lastRead(channel);</span><br><span class="line">            Long now = now();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Rely on reconnect timer to reconnect when AbstractClient.doConnect fails to init the connection</span></span><br><span class="line">            <span class="keyword">if</span> (!channel.isConnected()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    logger.info(<span class="string">"Initial connection to "</span> + channel);</span><br><span class="line">                    ((Client) channel).reconnect();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.error(<span class="string">"Fail to connect to "</span> + channel, e);</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">// check pong at client</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastRead != <span class="keyword">null</span> &amp;&amp; now - lastRead &gt; idleTimeout) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Reconnect to channel "</span> + channel + <span class="string">", because heartbeat read idle time out: "</span></span><br><span class="line">                        + idleTimeout + <span class="string">"ms"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ((Client) channel).reconnect();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    logger.error(channel + <span class="string">"reconnect failed during idle time."</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception when reconnect to remote channel "</span> + channel.getRemoteAddress(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不同类型处理机制不同，当超过设置的心跳总时间后，客户端选择的是重新连接，服务端是选择直接断开连接。</p>
<h1 id="心跳改进方案"><a href="#心跳改进方案" class="headerlink" title="心跳改进方案"></a>心跳改进方案</h1><p>Netty对空闲连接的检测提供了天然的支持，使用IdleStateHandler可以很方便的实现空闲检测逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(<span class="keyword">long</span> readerIdleTime, <span class="keyword">long</span> writerIdleTime, <span class="keyword">long</span> allIdleTime, TimeUnit unit)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>readerIdleTime: 读超时的时间</li>
<li>writerIdleTime: 写超时的时间</li>
<li>allIdleTime: 所有类型的超时时间<br>客户端和服务端配置<br>客户端：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.handler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="string">"clientIdleHandler"</span>, <span class="keyword">new</span> IdleStateHandler(<span class="number">60</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ch.pipeline().addLast(<span class="string">"serverIdleHandler"</span>,<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面看出，客户端配置了read超时为60s，服务端配置了write/read超时未200s，</p>
<h2 id="空闲超时逻辑-客户端"><a href="#空闲超时逻辑-客户端" class="headerlink" title="空闲超时逻辑-客户端"></a>空闲超时逻辑-客户端</h2><p>对于空闲超时的处理逻辑，客户端和服务端是不同的，首先来看客户端的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        <span class="comment">// send heartbeat</span></span><br><span class="line">        sendHeartBeat();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检测到空闲超时后，采取的行为是向服务端发送心跳包，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendHeartBeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Invocation invocation = <span class="keyword">new</span> Invocation();</span><br><span class="line">    invocation.setInvocationType(InvocationType.HEART_BEAT);</span><br><span class="line">    channel.writeAndFlush(invocation).addListener(<span class="keyword">new</span> CallbackFuture() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(Future future)</span> </span>&#123;</span><br><span class="line">            RPCResult result = future.get();</span><br><span class="line">            <span class="comment">//超时 或者 写失败</span></span><br><span class="line">            <span class="keyword">if</span> (result.isError()) &#123;</span><br><span class="line">                channel.addFailedHeartBeatTimes();</span><br><span class="line">                <span class="keyword">if</span> (channel.getFailedHeartBeatTimes() &gt;= channel.getMaxHeartBeatFailedTimes()) &#123;</span><br><span class="line">                    channel.reconnect();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel.clearHeartBeatFailedTimes();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造一个心跳包发送到服务端，接受响应结果</p>
<ul>
<li>响应成功，清除请求失败标记</li>
<li>响应失败，心跳失败标记+1，如果超过配置的失败次数，则重新连接<h2 id="空闲超时逻辑-服务端"><a href="#空闲超时逻辑-服务端" class="headerlink" title="空闲超时逻辑 - 服务端"></a>空闲超时逻辑 - 服务端</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) &#123;</span><br><span class="line">        channel.close();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>服务端直接关闭连接。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/07/29/Dubbo-服务注册中心之AbstractRegistry/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2019/08/09/Dubbo之心跳机制/';
var disqus_title = 'Dubbo之心跳机制';
var disqus_url = 'https://github.com/spurstong/2019/08/09/Dubbo之心跳机制/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2018 - 2019 <a href="https://github.com/spurstong">Mara Tong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>