<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Dubbo之@Adaptive适配器类实现解析 · 房东的小黑</title><meta name="description" content="Dubbo之@Adaptive适配器类实现解析 - Mara Tong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/spurstong/atom.xml" title="房东的小黑"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/black.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">JIANSHU</a></li><li class="nav-list-item"><a href="https://github.com/spurstong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">房东的小黑黑</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Dubbo之@Adaptive适配器类实现解析</h1><div class="post-info">2019年7月26日</div><div class="post-content"><p>在上一篇中讲解了关于Dubbo的SPI机制，在其中有一个很重要的注解@Adaptive，这是一个装饰器，通过此类来获取实现扩展类的具体实现类的方法。因为用到了设计模式中的适配器模式，所以打算独立出来写一篇。</p>
<a id="more"></a>
<p>在上一篇中讲解了关于Dubbo的SPI机制，在其中有一个很重要的注解@Adaptive，这是一个装饰器，通过此类来获取实现扩展类的具体实现类的方法。因为用到了设计模式中的适配器模式，所以打算独立出来写一篇。</p>
<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>将一个类的转接口转换成客户希望的另一个接口，适配器模式使得原来由于接口不兼容的而不能的工作的哪些类可以工作，主要作用就是兼容。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/Dubbo%E4%B9%8B%40Adaptive%E9%80%82%E9%85%8D%E5%99%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90/1.png" alt="1.png"></p>
<h2 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h2><p>Adapter类继承了Adaptee(被适配类)，同时实现Target接口，在Client类中我们可以根据需要选择并创建任一种符合需求的子类，来实现具体功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已存在的、具有特殊功能、但不符合我们既有的标准接口的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">specificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"被适配类 具有特殊功能..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标接口，或称为标准接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体目标类，只提供普通功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteTarget</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"普通类 具有普通功能..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 适配器类，继承了被适配类，同时实现标准接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用普通功能类</span></span><br><span class="line">        Target concreteTarget = <span class="keyword">new</span> ConcreteTarget();<span class="comment">//实例化一个普通类</span></span><br><span class="line">        concreteTarget.request();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用特殊功能类，即适配类</span></span><br><span class="line">        Target adapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">        adapter.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h2><p>不使用多继承或继承的方式，而是使用直接关联，或者称为委托的方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/ 适配器类，直接关联被适配类，同时实现标准接口</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="comment">// 直接关联被适配类</span></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过构造函数传入具体需要适配的被适配类对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span> <span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里是使用委托的方式完成特殊功能</span></span><br><span class="line">        <span class="keyword">this</span>.adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用普通功能类</span></span><br><span class="line">        Target concreteTarget = <span class="keyword">new</span> ConcreteTarget();</span><br><span class="line">        concreteTarget.request();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用特殊功能类，即适配类，</span></span><br><span class="line">        <span class="comment">// 需要先创建一个被适配类的对象作为参数</span></span><br><span class="line">        Target adapter = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee());</span><br><span class="line">        adapter.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Dubbo中的适配器"><a href="#Dubbo中的适配器" class="headerlink" title="Dubbo中的适配器"></a>Dubbo中的适配器</h1><p>Dubbo通过注解@Adaptive作为标记实现了一个适配器类，并且这个类是动态生成的，因此在Dubbo的源码中是看不到代码的，但是我们还是可以看到其实现方式的。Dubbo提供一个动态的适配器类的原因就是可以通过配置文件来动态的使用想要的接口实现类，并且不用改变任何接口的代码，简单来说其也是通过代理来实现的。<br>在初始化ExtensionLoader时，有一个构造函数，创建对象工厂，获得扩展实现的实例。<br>获取的就是一个objectFactory 的值是<code>AdaptiveExtensionFactory</code>的实例化对象。</p>
<p>创建 AdaptiveExtensionFactory 实例时，首先获取 ExtensionLoader，此前已经初始化ok。然后依次实例化具体实现（放在ExtensionLoader类cachedClasses属性中，这个属性用于存放实现功能接口的类，即上面解析得到的extensionClasses），即依次实例化SpiExtensionFactory和SpringExtensionFactory，事实上AdaptiveExtensionFactory是通用扩展实现获取的入口，具体的获取方式分为两种，一种是通过Dubbo自己的SPI方式加载到的扩展，另一种是支持复用Spring的方式。以key为“spi”，value是 SpiExtensionFactory 为例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">        <span class="comment">//该类是否实现扩展接口</span></span><br><span class="line">        <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Error when load extension class(interface: "</span> +</span><br><span class="line">                    type + <span class="string">", class line: "</span> + clazz.getName() + <span class="string">"), class "</span></span><br><span class="line">                    + clazz.getName() + <span class="string">"is not subtype of interface."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断该类是否为扩展接口的适配器</span></span><br><span class="line">        <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cachedAdaptiveClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cachedAdaptiveClass = clazz;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!cachedAdaptiveClass.equals(clazz)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"More than 1 adaptive class found: "</span></span><br><span class="line">                        + cachedAdaptiveClass.getClass().getName()</span><br><span class="line">                        + <span class="string">", "</span> + clazz.getClass().getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">            Set&lt;Class&lt;?&gt;&gt; wrappers = cachedWrapperClasses;</span><br><span class="line">            <span class="keyword">if</span> (wrappers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cachedWrapperClasses = <span class="keyword">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">                wrappers = cachedWrapperClasses;</span><br><span class="line">            &#125;</span><br><span class="line">            wrappers.add(clazz);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//通过反射获得构造器对象</span></span><br><span class="line">            clazz.getConstructor();</span><br><span class="line">            <span class="comment">//未配置扩展名，自动生成，例如DemoFilter为 demo，主要用于兼容java SPI的配置。</span></span><br><span class="line">            <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                name = findAnnotationName(clazz);</span><br><span class="line">                <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No such extension name for the class "</span> + clazz.getName() + <span class="string">" in the config "</span> + resourceURL);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获得扩展名，可以是数组，有多个拓扩展名。</span></span><br><span class="line">            String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">            <span class="keyword">if</span> (names != <span class="keyword">null</span> &amp;&amp; names.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Activate activate = clazz.getAnnotation(Activate.class);</span><br><span class="line">                <span class="comment">//如果是自动激活的实现类，则加入到缓存</span></span><br><span class="line">                <span class="keyword">if</span> (activate != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cachedActivates.put(names[<span class="number">0</span>], activate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!cachedNames.containsKey(clazz)) &#123;</span><br><span class="line">                        cachedNames.put(clazz, n);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//缓存扩展实现类</span></span><br><span class="line">                    Class&lt;?&gt; c = extensionClasses.get(n);</span><br><span class="line">                    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        extensionClasses.put(n, clazz);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c != clazz) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Duplicate extension "</span> + type.getName() + <span class="string">" name "</span> + n + <span class="string">" on "</span> + c.getName() + <span class="string">" and "</span> + clazz.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码中可以看出，从配置文件中加载类时，会根据判断注解的不同而存放到不同的变量值中。<br>如果当前类的注解有@Adaptive,则将它存放到<code>cachedAdaptiveClass</code>中，然后将扩展点的具体实现类存放到<code>extensionClasses</code>中。<br><img src="https://raw.githubusercontent.com/spurstong/img_data/master/Dubbo%E4%B9%8B%40Adaptive%E9%80%82%E9%85%8D%E5%99%A8%E7%B1%BB%E5%AE%9E%E7%8E%B0%E8%A7%A3%E6%9E%90/2.png" alt="2.png"></p>
<p>在调用<strong>injectExtension</strong>向创建的扩展点注入依赖时，有这一句话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得属性，比如StubProxyFactoryWrapper类中有Protocol protocol属性，</span></span><br><span class="line">String property = method.getName().length() &gt; <span class="number">3</span> ? method.getName().substring(<span class="number">3</span>, <span class="number">4</span>).toLowerCase() + method.getName().substring(<span class="number">4</span>) : <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得属性值，比如Protocol对象，也可能是Bean对象</span></span><br><span class="line">Object object = objectFactory.getExtension(pt, property);</span><br><span class="line"><span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//注入依赖属性</span></span><br><span class="line">    method.invoke(instance, object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<strong>objectFactory.getExtension(pt, property);</strong> 实际上就是<em>AdaptiveExtensionFactory</em>实例去调用cachedClass中的某一个具体类的getExtension方法，因为 AdaptiveExtensionFactory和cachedClass中的类都继承了<em>ExtensionFactory</em>接口，但<code>AdaptiveExtensionFactory</code>没有实现getExtension方法的具体实现，但cacheedClass中的SpringExtensionFactory和spiExtensionFactory都有getExtension方法的具体实现，<code>AdaptiveExtensionFactory</code>承担着一个适配器的角色。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/07/29/Dubbo-服务注册中心之AbstractRegistry/" class="prev">上一篇</a><a href="/2019/07/26/Dubbo的SPI机制与JDK的SPI机制的不同及原理分析/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2019/07/26/Dubbo之@Adaptive适配器类实现解析机制/';
var disqus_title = 'Dubbo之@Adaptive适配器类实现解析';
var disqus_url = 'https://github.com/spurstong/2019/07/26/Dubbo之@Adaptive适配器类实现解析机制/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2018 - 2019 <a href="https://github.com/spurstong">Mara Tong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>