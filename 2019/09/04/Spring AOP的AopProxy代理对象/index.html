<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Spring AOP之AopProxy代理对象 · 房东的小黑</title><meta name="description" content="Spring AOP之AopProxy代理对象 - Mara Tong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/spurstong/atom.xml" title="房东的小黑"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/black.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">JIANSHU</a></li><li class="nav-list-item"><a href="https://github.com/spurstong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">房东的小黑黑</a></li></ul><div class="mySign">路途虽遥远，将来更美好</div></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Spring AOP之AopProxy代理对象</h1><div class="post-info">2019年9月4日</div><div class="post-content"><p>在Spring的AOP模块，一个主要的部分是代理对象的生成，可以通过ProxyFactoryBean来完成，它封装了主要代理对象的生成过程。在这个生成过程中，可以使用JDK的Proxy和CGLIB两种生成情况。</p>
<a id="more"></a>
<h1 id="JDK动态代理与CGLIB区别"><a href="#JDK动态代理与CGLIB区别" class="headerlink" title="JDK动态代理与CGLIB区别"></a>JDK动态代理与CGLIB区别</h1><ol>
<li>jdk动态代理是利用反射机制生成的一个实现代理接口的<em>匿名类</em>，在调用具体方法前调用InvokeHandler来处理。</li>
<li>CGLIB动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。</li>
<li>如果目标对象实现了接口，默认情况下采用JDK的动态代理实现AOP,但可以强制性使用CGLIB实现AOP</li>
<li>如果目标对象没有实现接口，必须采用cglib库，</li>
</ol>
<p>Tip: 什么是匿名类<br>即没有名称的类，其名称由Java编译器给出，一般为：外部类名称+$+匿名类顺序，名称也就是其他地方不能引用，不能实例化，只用一次，当然也就不能有构造器。</p>
<ul>
<li>匿名类可以继承父类的方法，也可以重写父类的方法。</li>
<li>匿名类可以访问外部类的成员变量和方法，匿名类的类体不可以声明为static成员变量和static方法。</li>
<li>匿名类由于是一个new的结果，所以其实可以赋值给一个父类对象。</li>
</ul>
<h1 id="配置ProxyFactoryBean"><a href="#配置ProxyFactoryBean" class="headerlink" title="配置ProxyFactoryBean"></a>配置ProxyFactoryBean</h1><ol>
<li>定义通知器Advisor,这个通知器应该作为一个Bean来定义，定义了需要对目标对象进行增强的切面行为，也就是Advice通知。</li>
<li>定义ProxyFactoryBean,作为另一个Bean来定义，它是封装AOP功能的主要类。需要设定相关属性。</li>
</ol>
<ul>
<li>interceptorNames: 设置为需要定义的通知器，要通过使用代理对象的拦截器机制起作用的。</li>
<li>target: 是需要用AOP通知器中的切面应用来增强的对象。</li>
</ul>
<h1 id="生成AopProxy代理对象"><a href="#生成AopProxy代理对象" class="headerlink" title="生成AopProxy代理对象"></a>生成AopProxy代理对象</h1><p>在ProxyFactoryBean中，需要为target目标对象生成Proxy代理对象，从而为AOP横切面的编织做好准备。从FactoryBean中获取对象，是以getObject()方法作为入口完成的。在该方法中，首先对通知器链进行初始化，封装了一系列的拦截器，这些拦截器都要从配置中读取，然后为代理对象的生成做好准备。在生成代理对象时，因为Spring中有singleton类型和prototype类型这两种不同的Bean,所以要对代理对象的生成做一个区分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		initializeAdvisorChain();</span><br><span class="line">		<span class="keyword">if</span> (isSingleton()) &#123;</span><br><span class="line">			<span class="keyword">return</span> getSingletonInstance();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.targetName == <span class="keyword">null</span>) &#123;</span><br><span class="line">				logger.warn(<span class="string">"Using non-singleton proxies with singleton targets is often undesirable. "</span> +</span><br><span class="line">						<span class="string">"Enable prototype proxies by setting the 'targetName' property."</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> newPrototypeInstance();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>首先为Proxy代理对象配置Advisor链，在initializeAdvisorChain()方法中执行。<br>在该方法中它会首先通过this.advisorChainInitialized来判断通知器链是否已经初始化了，如果已经初始化了，就直接返回。其他情况下，通过<code>this.interceptorNames</code>来要添加的通知器名，然后通过该名从IOC容器中取得的通知器加入到拦截器链中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initializeAdvisorChain</span><span class="params">()</span> <span class="keyword">throws</span> AopConfigException, BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.advisorChainInitialized) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!ObjectUtils.isEmpty(<span class="keyword">this</span>.interceptorNames)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No BeanFactory available anymore (probably due to serialization) "</span> +</span><br><span class="line">						<span class="string">"- cannot resolve interceptor names "</span> + Arrays.asList(<span class="keyword">this</span>.interceptorNames));</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Globals can't be last unless we specified a targetSource using the property...</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="keyword">this</span>.interceptorNames[<span class="keyword">this</span>.interceptorNames.length - <span class="number">1</span>].endsWith(GLOBAL_SUFFIX) &amp;&amp;</span><br><span class="line">					<span class="keyword">this</span>.targetName == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.targetSource == EMPTY_TARGET_SOURCE) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Target required after globals"</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Materialize interceptor chain from bean names.</span></span><br><span class="line">			<span class="keyword">for</span> (String name : <span class="keyword">this</span>.interceptorNames) &#123;</span><br><span class="line">				<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">					logger.trace(<span class="string">"Configuring advisor or advice '"</span> + name + <span class="string">"'"</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (name.endsWith(GLOBAL_SUFFIX)) &#123;</span><br><span class="line">					<span class="keyword">if</span> (!(<span class="keyword">this</span>.beanFactory <span class="keyword">instanceof</span> ListableBeanFactory)) &#123;</span><br><span class="line">						<span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(</span><br><span class="line">								<span class="string">"Can only use global advisors or interceptors with a ListableBeanFactory"</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					addGlobalAdvisor((ListableBeanFactory) <span class="keyword">this</span>.beanFactory,</span><br><span class="line">							name.substring(<span class="number">0</span>, name.length() - GLOBAL_SUFFIX.length()));</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// If we get here, we need to add a named interceptor.</span></span><br><span class="line">					<span class="comment">// We must check if it's a singleton or prototype.</span></span><br><span class="line">					Object advice;</span><br><span class="line">					<span class="keyword">if</span> (<span class="keyword">this</span>.singleton || <span class="keyword">this</span>.beanFactory.isSingleton(name)) &#123;</span><br><span class="line">						<span class="comment">// Add the real Advisor/Advice to the chain.</span></span><br><span class="line">						advice = <span class="keyword">this</span>.beanFactory.getBean(name);</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="comment">// It's a prototype Advice or Advisor: replace with a prototype.</span></span><br><span class="line">						<span class="comment">// Avoid unnecessary creation of prototype bean just for advisor chain initialization.</span></span><br><span class="line">						advice = <span class="keyword">new</span> PrototypePlaceholderAdvisor(name);</span><br><span class="line">					&#125;</span><br><span class="line">					addAdvisorOnChainCreation(advice, name);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">this</span>.advisorChainInitialized = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>生成singleton的代理对象在getSingletonInstance()中完成<br>如果它还没有被创建，则lazily creating</p>
<p>在Spring代理目标target时，其实并不是直接创建一个目标target的对象实例的，而是通过一个TargetSource类型的对象对目标target进行封装，Spring Aop获取目标对象始终是通过<code>TargetSource.getTarget()</code>方法进行的。</p>
<p>proxy（代理对象）代理的不是target,而是TargetSource</p>
<p>那么问题来了:为什么SpringAOP代理不直接代理target,而需要通过代理TargetSource(target的来源,其内部持有target),间接代理target呢?</p>
<p>通常情况下,一个proxy(代理对象)只能代理一个target,每次方法调用的目标也是唯一固定的target。但是,如果让proxy代理TargetSource,可以使得每次方法调用的target实例都不同(当然也可以相同,这取决于TargetSource实现)。这种机制使得方法调用变得灵活,可以扩展出很多高级功能,如:target pool(目标对象池)、hot swap(运行时目标对象热替换),等等。</p>
<p>Spring内置了多种TargetSource</p>
<ul>
<li>SingletonTargetSource<br>从这个目标源取得的目标对象是单例的，成员变量target缓存了目标对象，每次getTarget()都是返回这个对象。</li>
<li>PrototypeTargetSource<br>每次getTarget()将生成prototype类型的bean，即其生成的bean并不是单例的，因而使用这个类型的TargetSource时需要注意，封装的目标bean必须是prototype类型的。PrototypeTargetSource继承了AbstractBeanFactoryBasedTargetSource拥有了创建bean的能力。</li>
<li>CommonsPool2TargetSource<br>里CommonsPool2TargetSource也就是池化的TargetSource，其基本具有平常所使用的“池”的概念的所有属性，比如：最小空闲数，最大空闲数，最大等待时间等等.</li>
<li>ThreadLocalTargetSource<br>ThreadLocalTargetSource也就是和线程绑定的TargetSource，可以理解，其底层实现必然使用的是ThreadLocal</li>
</ul>
<blockquote>
<p>在上面简单介绍了有关TargetSource的有关知识，接下来将对<em>getSingletonInstance()</em>方法的有关步骤进行解释。</p>
</blockquote>
<ul>
<li><code>this.targetSource = freshTargetSource()</code>   返回要在创建代理时使用的TargetSource.<br>如果在interceptorNames列表的末尾没有指定目标，TargetSource将是该类的TargetSource成员。<br>否则，我们将获得目标bean，并在必要时将其封装在TargetSource中。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TargetSource <span class="title">freshTargetSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.targetName == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">         logger.trace(<span class="string">"Not refreshing target: Bean name not specified in 'interceptorNames'."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.targetSource;</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.beanFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No BeanFactory available anymore (probably due to serialization) "</span> +</span><br><span class="line">               <span class="string">"- cannot resolve target with name '"</span> + <span class="keyword">this</span>.targetName + <span class="string">"'"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Refreshing target with name '"</span> + <span class="keyword">this</span>.targetName + <span class="string">"'"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">      Object target = <span class="keyword">this</span>.beanFactory.getBean(<span class="keyword">this</span>.targetName);</span><br><span class="line"> <span class="keyword">return</span> (target <span class="keyword">instanceof</span> TargetSource ? (TargetSource) target : <span class="keyword">new</span> SingletonTargetSource(target));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Class&lt;?&gt; targetClass = getTargetClass(); 根据AOP框架来判断需要代理的接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="meta">@Nullable</span> <span class="keyword">public</span> Class&lt;?&gt; getTargetClass() &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>.targetSource.getTargetClass(); &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader)); 这里设置代理对象的接口</p>
</li>
<li><p>super.setFrozen(this.freezeProxy); 初始化共享单例实例 ，当一个配置被冻结时，不能对advice进行更改</p>
</li>
<li><p>this.singletonInstance = getProxy(createAopProxy()); 通过createAopProxy返回的AopProxy来生成需要的Proxy</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getProxy</span><span class="params">(AopProxy aopProxy)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> aopProxy.getProxy(<span class="keyword">this</span>.proxyClassLoader); &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> AopProxy <span class="title">createAopProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (!<span class="keyword">this</span>.active) &#123;</span><br><span class="line">      activate();</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">return</span> getAopProxyFactory().createAopProxy(<span class="keyword">this</span>); &#125;</span><br></pre></td></tr></table></figure>

<p>监听调用AdvisedSupportListener实现类的activated方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">activate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.active = <span class="keyword">true</span>;</span><br><span class="line"> <span class="keyword">for</span> (AdvisedSupportListener listener : <span class="keyword">this</span>.listeners) &#123;</span><br><span class="line">      listener.activated(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的代理对象的生成，是在ProxyFactoryBean的基类AdvisedSupport的实现中借助AopProxyFactory完成的，这个代理对象要么从JDK中生成，要么借助CGLIB获得。</p>
<p>这个AopProxyFactory是在初始化函数中定义的，使用的是DefaultAopProxyFactor。</p>
<ul>
<li>createAopProxy(AdvisedSupport config)<br>在该方法中会判断采用不同的策略来生成AopProxy</li>
</ul>
<p>如果targetClass是接口类，使用JDK来生成Proxy<br>如果不是接口类要生成Proxy,那么使用CGLIB来生成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">      Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"> <span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line">               <span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">  &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来分别介绍两种不同的方式来产生AopProxy代理对象</p>
<ol>
<li>JdkDynamicAopProxy<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Creating JDK dynamic proxy: target source is "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">  &#125;</span><br><span class="line">  # 获取AdvisedSupport类型对象的所有接口</span><br><span class="line">   Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised, <span class="keyword">true</span>);</span><br><span class="line">   # 接口是否定义了 equals和hashcode方法 正常是没有的</span><br><span class="line">  findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);</span><br><span class="line"> <span class="keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="keyword">this</span>); &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>首先从advised对象中取得代理对象的代理接口配置，然后调用Proxy的newProxyInstance方法，得到最终的Proxy代理对象。</p>
<p>在生成代理对象时，需要指明三个参数，类加载器，代理接口和Proxy回调方法所在的对象。<br>在回调方法所在对象中，需要实现InvocationHandler接口，它定义了invoke方法，<br>对于JdkDynamimcAopProxy，它本身实现了InvocationHandler接口和invoke方法，这个invoke方法是Proxy代理对象的回调方法。</p>
<ol start="2">
<li>CGLIB生成代理对象</li>
</ol>
<p>在该篇文章中就不讲解了，感兴趣的可以百度搜索。</p>
<p>注：本文大多数是对《Spring技术内幕》的阅读整理。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/09/14/Spring MVC源码分析/" class="prev">上一篇</a><a href="/2019/08/26/Spring之bean的生命周期及InitializingBean等接口的作用/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2019/09/04/Spring AOP的AopProxy代理对象/';
var disqus_title = 'Spring AOP之AopProxy代理对象';
var disqus_url = 'https://github.com/spurstong/2019/09/04/Spring AOP的AopProxy代理对象/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2018 - 2019 <a href="https://github.com/spurstong">Mara Tong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>