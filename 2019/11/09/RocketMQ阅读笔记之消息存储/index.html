<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> RocketMQ阅读笔记之消息存储 · 房东的小黑</title><meta name="description" content="RocketMQ阅读笔记之消息存储 - Mara Tong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/spurstong/atom.xml" title="房东的小黑"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/black.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">JIANSHU</a></li><li class="nav-list-item"><a href="https://github.com/spurstong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">房东的小黑黑</a></li></ul><div class="mySign">路途虽遥远，将来更美好</div></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">RocketMQ阅读笔记之消息存储</h1><div class="post-info">2019年11月9日</div><div class="post-content"><p>消息存储部分是RocketMQ的重要组成部分，良好的存储机制会有效降低延迟，提高整体效率。RocketMQ利用到了文件系统，将消息存放在磁盘中实现持久化。</p>
<p>首先先介绍消息存储的整体结构，先大体了解其处理机制。</p>
<p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/RocketMQ%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/1.png" alt="RocketMQ消息存储整体架构"></p>
<p>从上图中可以看出有几个重要的文件。</p>
<ul>
<li><p>CommitLog: 消息存储文件，所有消息主题的消息都存储在CommitLog文件夹中，它以物理文件的方式存放，每台Broker上有一个CommitLog文件夹，里面有多个文件，单个文件的大小默认为1G,文件名表示的是该文件中的第1条信息的物理偏移量。每台Broker上的CommitLog被本机器所有ConsumeQueue共享。在CommitLog中，一个消息的存储长度是不固定的。每条消息的前4个字节存储该条消息的总长度，其余的信息就是在该长度下的消息内容。</p>
</li>
<li><p>ConsumerQueue: 消息队列文件，在ConsumerQueue文件夹中存在以topic(主题名)为文件夹名的多个文件夹。然后在每个文件夹里根据消息队列数创建了多个文件夹，文件夹名为0，1，2，..。然后在最里面的文件记录的是某主题下的某消息队列下的文件信息，但是它并没有存储消息的具体信息，它起到了类似于索引的功能，更够使消费者可以快速的在CommitLog文件中查找到所需的信息。</p>
<p>单个ConsumerQueue文件中默认包含30万个条目，单个文件的长度为30W * 20字节，即每条信息占20字节。前8个字节为commitlog offset,为该条消息在commitlog的实际偏移量，中间4个字节为size,即该条消息的长度，最后8字节为tag hashcode,即存储该条消息的tag的哈希值，用于订阅时消息过滤。</p>
</li>
<li><p>IndexFile：索引文件。如果消息包含key值的话，会使用IndexFile来存储消息索引。具体的逻辑结构在后面讲解到。</p>
</li>
</ul>
<h1 id="内存映射技术"><a href="#内存映射技术" class="headerlink" title="内存映射技术"></a>内存映射技术</h1><p>  在Linux操作系统中分为“用户态”和“内核态”，在进行IO操作时，会涉及到这两种形态的切换及read()和write()操作。在执行read()操作时，是系统调用的，期间进行了数据拷贝，它首先将文件内容从硬盘拷贝到内核空间的一个缓冲区，然后再将这些数据拷贝到用户空间，在这个过程中实际上完成了两次的数据拷贝。这样会对访问速度有所影响。</p>
<p>  针对这种情况，提出了mmap内存映射技术，mmap内存映射和普通标准IO操作的本质区别是它并不需要将文件中的数据先拷贝到OS的内核IO缓冲区，而是可以直接将用户进程私有地址空间的一块区域与文件对象建立映射关系，就好像可以直接从内存中完成对文件读写操作一样。只有当缺页中断发生时，直接将磁盘拷贝至用户态的进程空间内，只进行了一次数据拷贝。</p>
<p>  <img src="https://raw.githubusercontent.com/spurstong/img_data/master/RocketMQ%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/3.png" alt="标准IO与NIO的区别"></p>
<h1 id="高可用机制"><a href="#高可用机制" class="headerlink" title="高可用机制"></a>高可用机制</h1><p>  RocketMQ分布式集群是通过Master和Slave的配合达到高可用性的，在Broker的配置文件中，参数brokerId的值为0表示这个Broker是Master,大于0表示该Broker是Slave。Master角色的Broker支持读和写，Slave角色的Broker仅支持读，也就是说,Producer只能和Master角色的Broker连接写入信息；Consumer可以连接Master角色和Slave角色的Broker来读取消息。</p>
<p>  对于Consumer,当Master不可用或者繁忙的时候，Consumer会自动切换到Slave进行读取消息，实现了消费端的高可用性。</p>
<p>  对于Producer,在创建topic的时候，把Topic的多个Message Queue创建在多个Broker组上（相同Broker名称，不同BrokerId的机器组成一个Broker组），这样当一个Broker组的Master不可用候，其他组的Master依然可用，Producer仍然可以发送消息。</p>
<h1 id="内存映射相关类"><a href="#内存映射相关类" class="headerlink" title="内存映射相关类"></a>内存映射相关类</h1><p>  由上面可知，RocketMQ通过使用内存映射文件来提高IO访问性能，现在介绍几个相关的类。</p>
<p>  <em>MappedFile</em></p>
<p>  它是CommitLog里面具体文件的映射。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedFile</span> <span class="keyword">extends</span> <span class="title">ReferenceResource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OS_PAGE_SIZE = <span class="number">1024</span> * <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);</span><br><span class="line">    <span class="comment">// 当前JVM中映射的虚拟内存总大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong TOTAL_MAPPED_VIRTUAL_MEMORY = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 当前JVM中mmap句柄数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger TOTAL_MAPPED_FILES = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 当前写到什么位置</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> AtomicInteger wrotePosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//ADD BY ChenYang</span></span><br><span class="line">    <span class="comment">// Flush到什么位置</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> AtomicInteger committedPosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger flushedPosition = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 映射的文件大小，定长</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> fileSize;</span><br><span class="line">    <span class="comment">// 映射的FileChannel对象</span></span><br><span class="line">    <span class="keyword">protected</span> FileChannel fileChannel;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Message will put to here first, and then reput to FileChannel if writeBuffer is not null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> ByteBuffer writeBuffer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">protected</span> TransientStorePool transientStorePool = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 映射的文件名</span></span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line">    <span class="comment">// 映射的起始偏移量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> fileFromOffset;</span><br><span class="line">    <span class="comment">// 映射的文件</span></span><br><span class="line">    <span class="keyword">private</span> File file;</span><br><span class="line">    <span class="comment">// 映射的内存对象，position永远不变</span></span><br><span class="line">    <span class="keyword">private</span> MappedByteBuffer mappedByteBuffer;</span><br><span class="line">    <span class="comment">// 最后一条消息存储时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> storeTimestamp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> firstCreateInQueue = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>



<p>  <em>MappedFileQueue</em></p>
<p>  MappedFileQueue是MappedFile的管理容器，MappedFileQueue是对存储目录的封装。</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedFileQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG_ERROR = LoggerFactory.getLogger(LoggerName.STORE_ERROR_LOGGER_NAME);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每次触发删除文件，最多删除多少个文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELETE_FILES_BATCH_MAX = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 文件存储位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String storePath;</span><br><span class="line">    <span class="comment">// 每个文件的大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mappedFileSize;</span><br><span class="line">    <span class="comment">// 各个文件</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;MappedFile&gt; mappedFiles = <span class="keyword">new</span> CopyOnWriteArrayList&lt;MappedFile&gt;();</span><br><span class="line">    <span class="comment">// 预分配MapedFile对象服务</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AllocateMappedFileService allocateMappedFileService;</span><br><span class="line">    <span class="comment">// 当前刷盘指针，表示该指针之前的所有数据全部持久化到磁盘</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> flushedWhere = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前数据提交指针，内存中ByteBuffer当前的写指针，该值大于等于flushedWhere.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> committedWhere = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 最后一条消息存储时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> storeTimestamp = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>  根据消息偏移量offset查找MappedFile时，不会直接使用offset/mappedFileSize，因为消息文件不是永久存在的，RocketMQ会定时删除存储文件，第一个文件不一定是000000000000000000，可能最初的起始文件已经被删除，那么利用上述方法是会产生错误的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MappedFile <span class="title">findMappedFileByOffset</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> offset, <span class="keyword">final</span> <span class="keyword">boolean</span> returnFirstOnNotFound)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          # 获取第一个MappedFile</span><br><span class="line">          MappedFile mappedFile = <span class="keyword">this</span>.getFirstMappedFile();</span><br><span class="line">          <span class="keyword">if</span> (mappedFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">int</span> index = (<span class="keyword">int</span>) ((offset / <span class="keyword">this</span>.mappedFileSize) - (mappedFile.getFileFromOffset() / <span class="keyword">this</span>.mappedFileSize));</span><br><span class="line">              <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= <span class="keyword">this</span>.mappedFiles.size()) &#123;</span><br><span class="line">                  LOG_ERROR.warn(<span class="string">"Offset for &#123;&#125; not matched. Request offset: &#123;&#125;, index: &#123;&#125;, "</span> +</span><br><span class="line">                          <span class="string">"mappedFileSize: &#123;&#125;, mappedFiles count: &#123;&#125;"</span>,</span><br><span class="line">                      mappedFile,</span><br><span class="line">                      offset,</span><br><span class="line">                      index,</span><br><span class="line">                      <span class="keyword">this</span>.mappedFileSize,</span><br><span class="line">                      <span class="keyword">this</span>.mappedFiles.size());</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">this</span>.mappedFiles.get(index);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                  <span class="keyword">if</span> (returnFirstOnNotFound) &#123;</span><br><span class="line">                      <span class="keyword">return</span> mappedFile;</span><br><span class="line">                  &#125;</span><br><span class="line">                  LOG_ERROR.warn(<span class="string">"findMappedFileByOffset failure. "</span>, e);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          log.error(<span class="string">"findMappedFileByOffset Exception"</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>  其中，重要的一个公式是<em>(int) ((offset / this.mappedFileSize) - (mappedFile.getFileFromOffset() / this.mappedFileSize));</em>    offset / this.mappedFileSize得到的是假设所有文件没有被删除的情况下该偏移量所处的文件，然后mappedFile.getFileFromOffset() / this.mappedFileSize，获取第一个文件的起始偏移量，如果之前有文件删除的话，计算已删除的文件数。这样就可以得到定位到实际的文件。</p>
<p><em>ConsumeQueue</em></p>
<p>ConsumeQueue是消息的逻辑队列，类似数据库的索引文件，存储的指向物理存储的地址，每个topic下的每一个Message Queue都有一个对应的ConsumeQueue文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumeQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储单元大小 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CQ_STORE_UNIT_SIZE = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG_ERROR = LoggerFactory.getLogger(LoggerName.STORE_ERROR_LOGGER_NAME);</span><br><span class="line">    <span class="comment">// 存储顶层对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultMessageStore defaultMessageStore;</span><br><span class="line">    <span class="comment">// 存储消息索引的队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MappedFileQueue mappedFileQueue;</span><br><span class="line">    <span class="comment">// Topic</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String topic;</span><br><span class="line">    <span class="comment">// queueId</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> queueId;</span><br><span class="line">    <span class="comment">// 写索引时用到的ByteBuffer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ByteBuffer byteBufferIndex;</span><br><span class="line">    <span class="comment">// 配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String storePath;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> mappedFileSize;</span><br><span class="line">    <span class="comment">// 最后一个消息对应的物理Offset</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> maxPhysicOffset = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 逻辑队列的最小Offset，删除物理文件时，计算出来的最小Offset</span></span><br><span class="line">    <span class="comment">// 实际使用需要除以 StoreUnitSize</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> minLogicOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> ConsumeQueueExt consumeQueueExt = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p><em>IndexFile</em></p>
<p>如果该消息存在key,可以根据key进行查询，这时需要用到IndexFile索引文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexFile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger log = LoggerFactory.getLogger(LoggerName.STORE_LOGGER_NAME);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> hashSlotSize = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> indexSize = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> invalidIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hashSlotNum;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> indexNum;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MappedFile mappedFile;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileChannel fileChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MappedByteBuffer mappedByteBuffer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IndexHeader indexHeader;</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/spurstong/img_data/master/RocketMQ%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/4.png" alt="RocketMQ索引文件"></p>
<p>从大的方面来说，分为3个部分，IndexHead,500w个hsah槽和2000w个Index条目。<br>IndexHead头部，包含40个字节，记录该IndexFile的统计信息，其结构如下：</p>
<ul>
<li>beginTimestamp: 该索引文件中包含信息的最小存储时间。</li>
<li>endTimestamp: 该索引文件中包含信息的最大存储时间。</li>
<li>beginPhyoffset: 该索引文件中包含的消息在commitlog文件中的最小物理偏移量。</li>
<li>endPhyoffset: 该索引文件中包含的消息在commitlog文件中的最大物理偏移量。</li>
<li>hashlogCount: hashlot个数。</li>
<li>indexCount: Index条目列表当前已使用的个数。</li>
</ul>
<p>500w个hsah槽<br>每个Hash槽存储的是落在该Hash槽的hashcode最新的Index的索引，每个Hash槽占4个字节。</p>
<p>2000w个Index<br>每一个Index条目结构如下：</p>
<ul>
<li>hashcode: key的hashcode</li>
<li>phyoffset: 消息对应的物理偏移量</li>
<li>timedif: 该消息存储时间与第一条消息的时间戳的差值</li>
<li>preIndexNo: 该条目的前一条记录的Index索引</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">putKey</span><span class="params">(<span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">long</span> phyOffset, <span class="keyword">final</span> <span class="keyword">long</span> storeTimestamp)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getIndexCount() &lt; <span class="keyword">this</span>.indexNum) &#123;</span><br><span class="line">           # 消息key的hashcode </span><br><span class="line">           <span class="keyword">int</span> keyHash = indexKeyHashMethod(key);</span><br><span class="line">           # 将key的hashcode与hash槽数量取余，得到该hashcode下的hash槽下标</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">int</span> slotPos = keyHash % <span class="keyword">this</span>.hashSlotNum;</span><br><span class="line">           # 该槽的物理地址</span><br><span class="line">           <span class="keyword">int</span> absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize;</span><br><span class="line"></span><br><span class="line">           FileLock fileLock = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// fileLock = this.fileChannel.lock(absSlotPos, hashSlotSize,</span></span><br><span class="line">               <span class="comment">// false);</span></span><br><span class="line">               # 获取该hashcode的存储的Index索引，</span><br><span class="line">               <span class="keyword">int</span> slotValue = <span class="keyword">this</span>.mappedByteBuffer.getInt(absSlotPos);</span><br><span class="line">               <span class="keyword">if</span> (slotValue &lt;= invalidIndex || slotValue &gt; <span class="keyword">this</span>.indexHeader.getIndexCount()) &#123;</span><br><span class="line">                   slotValue = invalidIndex;</span><br><span class="line">               &#125;</span><br><span class="line">              # 计算待存储消息的时间戳与第一条消息时间戳的差值，并转换为秒</span><br><span class="line">               <span class="keyword">long</span> timeDiff = storeTimestamp - <span class="keyword">this</span>.indexHeader.getBeginTimestamp();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 时间差存储单位由毫秒改为秒</span></span><br><span class="line">               timeDiff = timeDiff / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 25000天后溢出</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getBeginTimestamp() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                   timeDiff = <span class="number">0</span>;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeDiff &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                   timeDiff = Integer.MAX_VALUE;</span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                   timeDiff = <span class="number">0</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">int</span> absIndexPos =</span><br><span class="line">                   IndexHeader.INDEX_HEADER_SIZE + <span class="keyword">this</span>.hashSlotNum * hashSlotSize</span><br><span class="line">                       + <span class="keyword">this</span>.indexHeader.getIndexCount() * indexSize;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 写入真正索引</span></span><br><span class="line">               <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos, keyHash);</span><br><span class="line">               <span class="keyword">this</span>.mappedByteBuffer.putLong(absIndexPos + <span class="number">4</span>, phyOffset);</span><br><span class="line">               <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span>, (<span class="keyword">int</span>) timeDiff);</span><br><span class="line">              <span class="keyword">this</span>.mappedByteBuffer.putInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span> + <span class="number">4</span>, slotValue);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 更新哈希槽</span></span><br><span class="line">               <span class="keyword">this</span>.mappedByteBuffer.putInt(absSlotPos, <span class="keyword">this</span>.indexHeader.getIndexCount());</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 第一次写入</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">this</span>.indexHeader.getIndexCount() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.indexHeader.setBeginPhyOffset(phyOffset);</span><br><span class="line">                   <span class="keyword">this</span>.indexHeader.setBeginTimestamp(storeTimestamp);</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">this</span>.indexHeader.incHashSlotCount();</span><br><span class="line">               <span class="keyword">this</span>.indexHeader.incIndexCount();</span><br><span class="line">               <span class="keyword">this</span>.indexHeader.setEndPhyOffset(phyOffset);</span><br><span class="line">               <span class="keyword">this</span>.indexHeader.setEndTimestamp(storeTimestamp);</span><br><span class="line"></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               log.error(<span class="string">"putKey exception, Key: "</span> + key + <span class="string">" KeyHashCode: "</span> + key.hashCode(), e);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (fileLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       fileLock.release();</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           log.warn(<span class="string">"Over index file capacity: index count = "</span> + <span class="keyword">this</span>.indexHeader.getIndexCount()</span><br><span class="line">               + <span class="string">"; index max num = "</span> + <span class="keyword">this</span>.indexNum);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>将该条目信息存储在IndexFile中，在之前的所存储的最后一个Index的后面添加，依次存放hashcode、消息物理偏移值、消息存储时间戳与第一条消息时间戳的差值、上一条相同hashcode的索引位置。并将当前新放入的Index条目个数即下标放入到该key值所处的卡槽位置中，即会覆盖掉原来记录的Index条目的下标，它只会记录最新的Index条目的下标。</p>
<p>但会存在一种情况，即不同的key可能会存在相同的hashcode，在查找hash槽是根据hashcode查找的，只能记录一个，所以会产生冲突，面对这种情况，在Index索引记录时有一个属性记录了该条目的前一条记录的索引值，即他们的hashcode是相同的。</p>
<p>下面是根据索引key查找消息，其中有一步是解决了hashcode冲突问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selectPhyOffset</span><span class="params">(<span class="keyword">final</span> List&lt;Long&gt; phyOffsets, <span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">int</span> maxNum,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">long</span> begin, <span class="keyword">final</span> <span class="keyword">long</span> end, <span class="keyword">boolean</span> lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mappedFile.hold()) &#123;</span><br><span class="line">            <span class="keyword">int</span> keyHash = indexKeyHashMethod(key);</span><br><span class="line">            <span class="keyword">int</span> slotPos = keyHash % <span class="keyword">this</span>.hashSlotNum;</span><br><span class="line">            <span class="keyword">int</span> absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos * hashSlotSize;</span><br><span class="line"></span><br><span class="line">            FileLock fileLock = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (lock) &#123;</span><br><span class="line">                    <span class="comment">// fileLock = this.fileChannel.lock(absSlotPos,</span></span><br><span class="line">                    <span class="comment">// hashSlotSize, true);</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> slotValue = <span class="keyword">this</span>.mappedByteBuffer.getInt(absSlotPos);</span><br><span class="line">                <span class="comment">// if (fileLock != null) &#123;</span></span><br><span class="line">                <span class="comment">// fileLock.release();</span></span><br><span class="line">                <span class="comment">// fileLock = null;</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (slotValue &lt;= invalidIndex || slotValue &gt; <span class="keyword">this</span>.indexHeader.getIndexCount()</span><br><span class="line">                    || <span class="keyword">this</span>.indexHeader.getIndexCount() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">// TODO NOTFOUND</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> nextIndexToRead = slotValue;;) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (phyOffsets.size() &gt;= maxNum) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> absIndexPos =</span><br><span class="line">                            IndexHeader.INDEX_HEADER_SIZE + <span class="keyword">this</span>.hashSlotNum * hashSlotSize</span><br><span class="line">                                + nextIndexToRead * indexSize;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">int</span> keyHashRead = <span class="keyword">this</span>.mappedByteBuffer.getInt(absIndexPos);</span><br><span class="line">                        <span class="keyword">long</span> phyOffsetRead = <span class="keyword">this</span>.mappedByteBuffer.getLong(absIndexPos + <span class="number">4</span>);</span><br><span class="line">                        <span class="comment">// int转为long，避免下面计算时间差值时溢出</span></span><br><span class="line">                        <span class="keyword">long</span> timeDiff = (<span class="keyword">long</span>) <span class="keyword">this</span>.mappedByteBuffer.getInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span>);</span><br><span class="line">                       <span class="keyword">int</span> prevIndexRead = <span class="keyword">this</span>.mappedByteBuffer.getInt(absIndexPos + <span class="number">4</span> + <span class="number">8</span> + <span class="number">4</span>);</span><br><span class="line">                        <span class="comment">// 读到了未知数据</span></span><br><span class="line"><span class="keyword">if</span> (timeDiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 时间差存储的是秒，再还原为毫秒， long避免溢出</span></span><br><span class="line">                        timeDiff *= <span class="number">1000L</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">long</span> timeRead = <span class="keyword">this</span>.indexHeader.getBeginTimestamp() + timeDiff;</span><br><span class="line">                        <span class="keyword">boolean</span> timeMatched = (timeRead &gt;= begin) &amp;&amp; (timeRead &lt;= end);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (keyHash == keyHashRead &amp;&amp; timeMatched) &#123;</span><br><span class="line">                            phyOffsets.add(phyOffsetRead);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (prevIndexRead &lt;= invalidIndex</span><br><span class="line">                            || prevIndexRead &gt; <span class="keyword">this</span>.indexHeader.getIndexCount()</span><br><span class="line">                            || prevIndexRead == nextIndexToRead || timeRead &lt; begin) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        nextIndexToRead = prevIndexRead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"selectPhyOffset exception "</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fileLock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        fileLock.release();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.mappedFile.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于会存在hash冲突，根据slotValue定位该hash槽最新的一个Item条目，经过一些处理后，会通过 <em>prevIndexRead</em> 获取到该Hashcode下的上一个Index下标，如果大于等于1并且小于最大条目数，则继续查找，否则结束查找。</p>
<h1 id="文件刷盘机制"><a href="#文件刷盘机制" class="headerlink" title="文件刷盘机制"></a>文件刷盘机制</h1><p>RocketMQ的存储与读写是基于JDK NIO的内存映射机制（MappedByteBuffer）的，消息存储时首先将消息追加到内存，再根据配置的刷盘策略在不同时间进行刷写磁盘，如果是同步刷盘，消息追加到内存后，将同步调用MappedByteBuffer的force方法；如果是异步刷盘，在消息追加到内存后立刻返回给消息发送端，RocketMQ使用一个单独的线程按照某一个设定的频率执行刷盘操作。</p>
<h1 id="Consume与IndexFile文件的实时更新"><a href="#Consume与IndexFile文件的实时更新" class="headerlink" title="Consume与IndexFile文件的实时更新"></a>Consume与IndexFile文件的实时更新</h1><p>当消息提交存储在Commitlog文件中，ConsumeQueue、IndexFile文件需要及时更新，否则消息无法及时被消费，如何确保消息内容能及时更新到ConsumeQueue、IndexFile等文件，RocketMQ通过开启一个线程ReputMessageService来实时更新消息信息。</p>
<p>在ReputMessageService线程中有一个重要的参数reputFromOffset,该参数表示从哪个物理偏移量开始转发消息给ConsumeQueue和IndexFile,如果允许重复转发，reputFromOffset设置为CommitLog的提交指针，如果不允许重复转发，reputFromOffset设置为CommitLog的内存中最大偏移量。读取的时候会读取该偏移量后的所有消息。</p>
<p>ReputMessageService线程每执行一次任务推送休息1毫秒就继续推送消息到消息消费队列和索引文件。<br>获取到新增的消息后，会采用不同的方法来对ConsumeQueue和IndexFile文件进行更新。</p>
<h2 id="根据消息更新对应文件"><a href="#根据消息更新对应文件" class="headerlink" title="根据消息更新对应文件"></a>根据消息更新对应文件</h2><p>获取到新增的消息后，要将这些消息更新到ConsumeQueue或IndexFile中，现以ConsumeQueue文件为例。</p>
<ul>
<li>根据消息主题与队列ID,获取到对应的ConsumeQueue文件，ConsumeQueue文件实际是对应的该队列ID下的文件夹，文件夹里有很多文件，在ConsumeQueue属性里面有一个MappedFileQueue,对该文件夹下的所有文件做映射。</li>
<li>依次将消息偏移量、消息长度、tag hashcode写入到ByteBuffer中，将内容追加到ConsumeQueue的内存映射文件中，ConsumeQueue的刷盘方式固定为异步刷盘方式。</li>
</ul>
<h1 id="过期文件删除机制"><a href="#过期文件删除机制" class="headerlink" title="过期文件删除机制"></a>过期文件删除机制</h1><p>CommitLog、ConsumeQueue文件是基于内存映射机制并在启动的时候会加载commitlog、ConsumeQueue目录下的所有文件，为了避免内存与磁盘的浪费，不可能将消息永久的存储在消息服务器上。</p>
<p>RocketMQ顺序写CommitLog文件、ConsumeQueue文件，所有写操作全部落在了最后一个CommitLog或ConsumeQueue文件上，之前的文件在下一个文件创建后将不会再更新，如果非当前写文件在下一个文件创建后将不会再被更新，则认为是过期文件，默认的过期时间是72小时。</p>
<p>RocketMQ会在下面几种情况下执行删除文件操作。</p>
<ul>
<li>指定删除文件的时间点，通过设置deleteWhen设置一天的固定时间执行一次删除过期文件操作，默认是凌晨4点</li>
<li>磁盘空间是否充足，如果磁盘空间不充足，则会触发过期文件删除操作。</li>
<li>可以通过调用excuteDeleteFilesManualy方法手动触发过期文件删除。</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2019/11/17/RocketMQ阅读笔记之消息消费/" class="prev">上一篇</a><a href="/2019/10/31/RocketMQ阅读笔记之消息发送/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2019/11/09/RocketMQ阅读笔记之消息存储/';
var disqus_title = 'RocketMQ阅读笔记之消息存储';
var disqus_url = 'https://github.com/spurstong/2019/11/09/RocketMQ阅读笔记之消息存储/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2018 - 2019 <a href="https://github.com/spurstong">Mara Tong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>