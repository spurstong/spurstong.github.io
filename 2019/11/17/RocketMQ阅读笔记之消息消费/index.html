<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> RocketMQ阅读笔记之消息消费的消息拉取 · 房东的小黑</title><meta name="description" content="RocketMQ阅读笔记之消息消费的消息拉取 - Mara Tong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/spurstong/atom.xml" title="房东的小黑"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/black.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">JIANSHU</a></li><li class="nav-list-item"><a href="https://github.com/spurstong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">房东的小黑黑</a></li></ul><div class="mySign">路途虽遥远，将来更美好</div></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">RocketMQ阅读笔记之消息消费的消息拉取</h1><div class="post-info">2019年11月17日</div><div class="post-content"><p>消息消费，简而言之就是消费者从消息队列里读取数据。消费者有两种消费方式：</p>
<ol>
<li><p><strong>Push方式</strong>。消息服务器接收到信息后，主动把消息推送给消费者，实时性高。但是这样加大了消息服务器的工作压力，会影响其性能。除此之外，不同消费者的处理信息的能力不同，可能无法及时的消费消息，造成 <em>慢消费</em> 问题。相关类是<code>DefaultMQPushConsumer</code>。</p>
</li>
<li><p><strong>Pull方式</strong>。消费者主动向消息服务器拉取消息，主动权在消费者这里。主要的问题是循环拉取消息的间隔不好设定，设置的间隔时间太久会增加消息的延迟；设置的事件间隔太短，如果消费服务器里没有可用的消息，那么会造成很多无用的请求开销，影响其性能。相关类是<code>DefaultMQPullConsumer</code>。</p>
</li>
</ol>
<p>消息消费以组的模式开展，一个消费组里可以包含多个消费者，每一个消费组可以订阅多个主题，消费组之间有<em>集群模式</em>和<em>广播模式</em>两种消费模式。</p>
<ul>
<li>集群模式:<br>同一个ConsumerGroup里的每个Consumer只消费所订阅消息的一部分内容，同一个ConsumerGroup里的所有的Consumer消费的内容合起来才是订阅的Topic内容的整体，从而达到负载均衡的目的。</li>
<li>广播模式<br>同一个ConsumerGroup里的每个Consumer都能消费到所订阅Topic的全部信息，也就是一个消息会被多次分发，被多个Consumer消费。</li>
</ul>
<p>首先先将一下DefaultMQPushConsumer的相关操作。</p>
<h2 id="DefaultMQPushConsumer的启动"><a href="#DefaultMQPushConsumer的启动" class="headerlink" title="DefaultMQPushConsumer的启动"></a>DefaultMQPushConsumer的启动</h2><p>启动方法是在DefaultMQPushConsumerImpl.start()方法。</p>
<p>首先会根据服务状态选择策略。定义的状态如下所示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ServiceState &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service just created,not start</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CREATE_JUST,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service Running</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNING,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service shutdown</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SHUTDOWN_ALREADY,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Service Start failure</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    START_FAILED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.serviceState = ServiceState.START_FAILED;</span><br></pre></td></tr></table></figure>

<p>如果是<em>RUNNING<em>、</em>START_FAILED</em>,则跳过该环节，直接进行下一环节。如果是<em>SULTdOWN_ALREDAY</em>，则抛出异常。如果是<em>CREATE_JUST</em>，则需要进入执行该环节的代码。<br>进入里面的区域时，先预设serviceState的值为START_FAILE，在执行一段操作后，如果注册消费者没有成功，则修改serviceState为CREATE_JUST，并抛出异常；如果顺利执行则修改serviceState为RUNNING。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证配置</span></span><br><span class="line"><span class="keyword">this</span>.checkConfig();</span><br><span class="line"><span class="keyword">this</span>.copySubscription();</span><br></pre></td></tr></table></figure>

<p>订阅主题订阅消息SubscriptionData,并放入到RebalanceImpl的订阅消息中。订阅关系来源主要有两个。</p>
<ul>
<li>defaultMQPushConsumer.getSubscription()</li>
<li>订阅重试主题消息。RocketMQ消息重试是以消费组为单位，而不是主题，消息重试主题为%RETRY%+消费组名。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">copySubscription</span><span class="params">()</span> <span class="keyword">throws</span> MQClientException </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Map&lt;String, String&gt; sub = <span class="keyword">this</span>.defaultMQPushConsumer.getSubscription();</span><br><span class="line">           <span class="keyword">if</span> (sub != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">final</span> Map.Entry&lt;String, String&gt; entry : sub.entrySet()) &#123;</span><br><span class="line">                   <span class="keyword">final</span> String topic = entry.getKey();</span><br><span class="line">                   <span class="keyword">final</span> String subString = entry.getValue();</span><br><span class="line">                   SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="comment">//</span></span><br><span class="line">                       topic, subString);</span><br><span class="line">                   <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">null</span> == <span class="keyword">this</span>.messageListenerInner) &#123;</span><br><span class="line">               <span class="keyword">this</span>.messageListenerInner = <span class="keyword">this</span>.defaultMQPushConsumer.getMessageListener();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">               <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">                   <span class="keyword">final</span> String retryTopic = MixAll.getRetryTopic(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                   SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="comment">//</span></span><br><span class="line">                       retryTopic, SubscriptionData.SUB_ALL);</span><br><span class="line">                   <span class="keyword">this</span>.rebalanceImpl.getSubscriptionInner().put(retryTopic, subscriptionData);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"subscription exception"</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果当前是集群消费模式，修改实例名为Pid。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) &#123;</span><br><span class="line">	<span class="keyword">this</span>.defaultMQPushConsumer.changeInstanceNameToPID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化MQClientInstance、ReblanceImple(消息重新负载实现类)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(<span class="keyword">this</span>.defaultMQPushConsumer, <span class="keyword">this</span>.rpcHook);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 设置负载均衡器</span></span><br><span class="line">               <span class="keyword">this</span>.rebalanceImpl.setConsumerGroup(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">               <span class="comment">//设置消费集群模式</span></span><br><span class="line">               <span class="keyword">this</span>.rebalanceImpl.setMessageModel(<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel());</span><br><span class="line">               <span class="comment">//Queue allocation algorithm specifying how message queues are allocated to each consumer clients.</span></span><br><span class="line">               <span class="keyword">this</span>.rebalanceImpl.setAllocateMessageQueueStrategy(<span class="keyword">this</span>.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span><br><span class="line">   </span><br><span class="line">               <span class="keyword">this</span>.rebalanceImpl.setmQClientFactory(<span class="keyword">this</span>.mQClientFactory);</span><br><span class="line">   </span><br><span class="line">               <span class="keyword">this</span>.pullAPIWrapper = <span class="keyword">new</span> PullAPIWrapper(</span><br><span class="line">                   mQClientFactory,</span><br><span class="line">                   <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span><br><span class="line">               <span class="keyword">this</span>.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span><br></pre></td></tr></table></figure>

<p>处理offset存储方式。<br>如果消息消费是集群模式，那么消息进度保存在Broker上；如果是广播模式，那么消息消费进度存储在消费端。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">this</span>.offsetStore = <span class="keyword">this</span>.defaultMQPushConsumer.getOffsetStore();</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="keyword">switch</span> (<span class="keyword">this</span>.defaultMQPushConsumer.getMessageModel()) &#123;</span><br><span class="line">                      <span class="keyword">case</span> BROADCASTING:</span><br><span class="line">                          <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> LocalFileOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">case</span> CLUSTERING:</span><br><span class="line">                          <span class="keyword">this</span>.offsetStore = <span class="keyword">new</span> RemoteBrokerOffsetStore(<span class="keyword">this</span>.mQClientFactory, <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup());</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                      <span class="keyword">default</span>:</span><br><span class="line">                          <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">this</span>.offsetStore.load();</span><br></pre></td></tr></table></figure>

<p>根据MessageListener的具体实现方式选择具体的消息拉取线程实现<br>可以选择顺序消息消费服务或者并行消息消费服务<br>最后执行ConsumerMessageService主要负责消费消息，内部维护一个线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerOrderly) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.consumeOrderly = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                        <span class="keyword">new</span> ConsumeMessageOrderlyService(<span class="keyword">this</span>, (MessageListenerOrderly) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.getMessageListenerInner() <span class="keyword">instanceof</span> MessageListenerConcurrently) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.consumeOrderly = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">this</span>.consumeMessageService =</span><br><span class="line">                        <span class="keyword">new</span> ConsumeMessageConcurrentlyService(<span class="keyword">this</span>, (MessageListenerConcurrently) <span class="keyword">this</span>.getMessageListenerInner());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.consumeMessageService.start();</span><br></pre></td></tr></table></figure>

<p>向MQClientInstance注册消费者，并启动MQClientInstance,在一个JVM中的所有消费者、生产者持有同一个MQClientInstance,MQClientInstance只会启动一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> registerOK = mQClientFactory.registerConsumer(<span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup(), <span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> (!registerOK) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">                    <span class="keyword">this</span>.consumeMessageService.shutdown();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"The consumer group["</span> + <span class="keyword">this</span>.defaultMQPushConsumer.getConsumerGroup()</span><br><span class="line">                        + <span class="string">"] has been created before, specify another name please."</span> + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span><br><span class="line">                        <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mQClientFactory.start();</span><br></pre></td></tr></table></figure>

<p>订阅关系改变，更新NameServer的订阅关系表。<br>检查客户端状态<br>发送心跳条<br>唤醒执行消费者负载均衡。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.updateTopicSubscribeInfoWhenSubscriptionChanged();</span><br><span class="line"><span class="keyword">this</span>.mQClientFactory.checkClientInBroker();</span><br><span class="line">       <span class="keyword">this</span>.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span><br><span class="line">       <span class="comment">//马上rebalance</span></span><br><span class="line"><span class="keyword">this</span>.mQClientFactory.rebalanceImmediately();</span><br></pre></td></tr></table></figure>

<p>在上面提到了offset的存储问题。现在先讲一下什么是offset和存储规则。</p>
<h1 id="消息消费进度记录"><a href="#消息消费进度记录" class="headerlink" title="消息消费进度记录"></a>消息消费进度记录</h1><p>消息消费者在消费一批消息后，需要记录该批消息已经消费完毕，否则当消费者重新启动时又得从消息消费队列的开始消费，这样显然会产生问题。一次消息消费后会从ProcessQueue处理队列中移除该批消息，返回ProcessQueue最小偏移量，并存入到消息进度表中。该消息进度表的存储位置和机制是一个重要的问题。</p>
<p>由上面可知,有两种消费模式，<em>广播模式</em>  和 <em>集群模式</em></p>
<p>广播模式： 同一消费组的所有消费者都会消费该主题下的所有消息。即同一个消息会被所有消费者消费，所以每个消费者应该各自独立有一个记录消费进度的文件。<br>广播模式下消息进度存储在消费者本地，主要类是LocalFileOffsetStore.</p>
<p>集群模式： 同一消费者的所有消费者共同消费该主题下的所有消息，一个消息只能被一个消费者所消费，即每个消费者消费的是该消费主题下的部分消息，所以消息消费进度记录被所有消费者所共享。<br>集群模式消息进度存储文件存放在消息服务端Broker,主要类中RemoteBrokerOffsetStore。</p>
<h1 id="几个重要有关消息消费的类"><a href="#几个重要有关消息消费的类" class="headerlink" title="几个重要有关消息消费的类"></a>几个重要有关消息消费的类</h1><p>每一个PullRequest代表一个消费的分组单元<br>PullRequest会记录一个topic记录对应的consumerGroup的拉取进度。</p>
<h2 id="PullRequest"><a href="#PullRequest" class="headerlink" title="PullRequest"></a>PullRequest</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PullRequest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String consumerGroup;</span><br><span class="line">    # 待拉取消息队列</span><br><span class="line">    <span class="keyword">private</span> MessageQueue messageQueue;</span><br><span class="line">    # 消息处理队列，从Broker拉取到的消费先存入到ProcessQueue,然后提交到消费者消费线程池消费</span><br><span class="line">    <span class="keyword">private</span> ProcessQueue processQueue;</span><br><span class="line">    # 待拉取的MessageQueue偏移量</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line">    # 是否被锁定</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lockedFirst = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>

<p>ProcessQueue是MessageQueue在消费端的重现、快照。</p>
<h2 id="ProcessQueue"><a href="#ProcessQueue" class="headerlink" title="ProcessQueue"></a>ProcessQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> REBALANCE_LOCK_MAX_LIVE_TIME =</span><br><span class="line">        Long.parseLong(System.getProperty(<span class="string">"rocketmq.client.rebalance.lockMaxLiveTime"</span>, <span class="string">"30000"</span>));</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> REBALANCE_LOCK_INTERVAL = Long.parseLong(System.getProperty(<span class="string">"rocketmq.client.rebalance.lockInterval"</span>, <span class="string">"20000"</span>));</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">long</span> PULL_MAX_IDLE_TIME = Long.parseLong(System.getProperty(<span class="string">"rocketmq.client.pull.pullMaxIdleTime"</span>, <span class="string">"120000"</span>));</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = ClientLogger.getLog();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReadWriteLock lockTreeMap = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    # 消息存储容器，键为消息在ConsumeQueue中的偏移量，value为消息实体</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMap = <span class="keyword">new</span> TreeMap&lt;Long, MessageExt&gt;();</span><br><span class="line">    # ProcessQueue中的消息总数</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong msgCount = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lockConsume = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    # 消息临时存储容器，消息消费线程从ProcessQueue的msgTreeMap中取出消息前，先将消息临时存储在msgTreeMapTemp中。</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, MessageExt&gt; msgTreeMapTemp = <span class="keyword">new</span> TreeMap&lt;Long, MessageExt&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong tryUnlockTimes = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> queueOffsetMax = <span class="number">0L</span>;</span><br><span class="line">    # 当前ProcessQueue是否被丢弃</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> dropped = <span class="keyword">false</span>;</span><br><span class="line">    # 上一次开始消息拉取时间戳</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastPullTimestamp = System.currentTimeMillis();</span><br><span class="line">    # 上一次消息消费时间戳</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastConsumeTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> lastLockTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> consuming = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> msgAccCnt = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="DefaultMQPushConsumer-客户端消费者实现"><a href="#DefaultMQPushConsumer-客户端消费者实现" class="headerlink" title="DefaultMQPushConsumer 客户端消费者实现"></a>DefaultMQPushConsumer 客户端消费者实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMQPushConsumer</span> <span class="keyword">extends</span> <span class="title">ClientConfig</span> <span class="keyword">implements</span> <span class="title">MQPushConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Internal implementation. Most of the functions herein are delegated to it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">transient</span> DefaultMQPushConsumerImpl defaultMQPushConsumerImpl;</span><br><span class="line"></span><br><span class="line">    # 消费者组名</span><br><span class="line">    <span class="keyword">private</span> String consumerGroup;</span><br><span class="line"></span><br><span class="line">    # 消费模式</span><br><span class="line">    <span class="keyword">private</span> MessageModel messageModel = MessageModel.CLUSTERING;</span><br><span class="line"></span><br><span class="line">   # 消费者从哪个位置消费</span><br><span class="line">   # CONSUME_FROM_LAST_OFFSET: 第一次启动从队列最后位置消费，后续再接着上次消费的进度开始消费</span><br><span class="line">   # CONSUME_FROM_First_OFFSET: 第一次启动从队列开始位置消费，后续再接着上次消费的进度开始消费</span><br><span class="line">   # CONSUME_FROM_TimeStamp: 第一次启动从指定时间点位置消费，后续再接着上次消费的进度开始消费</span><br><span class="line">   # 这里的第一次启动指的是该消费者之前没有消费过该消息队列，如果消费过，则会在Broker端记录消费位置，如果该消费者挂了再启动时，会自动从上次消费的地方开始。</span><br><span class="line">    <span class="keyword">private</span> ConsumeFromWhere consumeFromWhere = ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> String consumeTimestamp = UtilAll.timeMillisToHumanString3(System.currentTimeMillis() - (<span class="number">1000</span> * <span class="number">60</span> * <span class="number">30</span>));</span><br><span class="line">    # 消费分配策略，默认消息平均分配给所有客户端</span><br><span class="line">    <span class="keyword">private</span> AllocateMessageQueueStrategy allocateMessageQueueStrategy;</span><br><span class="line">    # topic对应的订阅tag</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String <span class="comment">/* topic */</span>, String <span class="comment">/* sub expression */</span>&gt; subscription = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    # 客户端消费消息的实现类</span><br><span class="line">    <span class="keyword">private</span> MessageListener messageListener;</span><br><span class="line">    # 存储实现，本地存储或者Broker存储</span><br><span class="line">    <span class="keyword">private</span> OffsetStore offsetStore;</span><br><span class="line">    # Minimum consumer thread number</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> consumeThreadMin = <span class="number">20</span>;</span><br><span class="line">    # Max consumer thread number</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> consumeThreadMax = <span class="number">64</span>;</span><br><span class="line">    # Threshold for dynamic adjustment of the number of thread pool</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> adjustThreadPoolNumsThreshold = <span class="number">100000</span>;</span><br><span class="line">    # 单队列并行消费的最大跨度，用于流量控制</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> consumeConcurrentlyMaxSpan = <span class="number">2000</span>;</span><br><span class="line">    # 一个queue最大消费的消息个数，用于流量控制</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pullThresholdForQueue = <span class="number">1000</span>;</span><br><span class="line">    # 消息拉取时间间隔，默认为0，</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> pullInterval = <span class="number">0</span>;</span><br><span class="line">    # 并发消费时，一次消费消息的数量</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> consumeMessageBatchMaxSize = <span class="number">1</span>;</span><br><span class="line">    # 消息拉取一次的数量</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pullBatchSize = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">     # Whether update subscription relationship when every pull</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> postSubscriptionWhenPull = <span class="keyword">false</span>;</span><br><span class="line">    # Whether the unit of subscription group</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> unitMode = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Max re-consume times. -1 means 16 times.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If messages are re-consumed more than &#123;<span class="doctag">@link</span> #maxReconsumeTimes&#125; before success, it's be directed to a deletion</span></span><br><span class="line"><span class="comment">     * queue waiting.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxReconsumeTimes = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Suspending pulling time for cases requiring slow pulling like flow-control scenario.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> suspendCurrentQueueTimeMillis = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    # Maximum amount of time in minutes a message may block the consuming thread.</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> consumeTimeout = <span class="number">15</span>;</span><br></pre></td></tr></table></figure>

<h2 id="DefaultMQPushConsumerImpl-消费者具体实现类"><a href="#DefaultMQPushConsumerImpl-消费者具体实现类" class="headerlink" title="DefaultMQPushConsumerImpl 消费者具体实现类"></a>DefaultMQPushConsumerImpl 消费者具体实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMQPushConsumerImpl</span> <span class="keyword">implements</span> <span class="title">MQConsumerInner</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Delay some time when exception occur</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PULL_TIME_DELAY_MILLS_WHEN_EXCEPTION = <span class="number">3000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Flow control interval</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL = <span class="number">50</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Delay some time when suspend pull service</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PULL_TIME_DELAY_MILLS_WHEN_SUSPEND = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> BROKER_SUSPEND_MAX_TIME_MILLIS = <span class="number">1000</span> * <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND = <span class="number">1000</span> * <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger log = ClientLogger.getLog();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DefaultMQPushConsumer defaultMQPushConsumer;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//负载均衡实现类 </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RebalanceImpl rebalanceImpl = <span class="keyword">new</span> RebalancePushImpl(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;FilterMessageHook&gt; filterMessageHookList = <span class="keyword">new</span> ArrayList&lt;FilterMessageHook&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> consumerStartTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;ConsumeMessageHook&gt; consumeMessageHookList = <span class="keyword">new</span> ArrayList&lt;ConsumeMessageHook&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RPCHook rpcHook;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServiceState serviceState = ServiceState.CREATE_JUST;</span><br><span class="line">    <span class="keyword">private</span> MQClientInstance mQClientFactory;</span><br><span class="line">    <span class="keyword">private</span> PullAPIWrapper pullAPIWrapper;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> pause = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> consumeOrderly = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> MessageListener messageListenerInner;</span><br><span class="line">    <span class="keyword">private</span> OffsetStore offsetStore;</span><br><span class="line">    <span class="keyword">private</span> ConsumeMessageService consumeMessageService;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> flowControlTimes1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> flowControlTimes2 = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h1 id="消息拉取基本流程"><a href="#消息拉取基本流程" class="headerlink" title="消息拉取基本流程"></a>消息拉取基本流程</h1><p>具体的实现类是DefaultMQPushConsumerImpl<br>消息拉取主要有3个主要步骤：</p>
<ul>
<li>消费拉取客户端消息拉取请求封装</li>
<li>消息服务器查找并返回消息</li>
<li>消息拉取客户端处理返回的消息</li>
</ul>
<ol>
<li><p>客户端封装消息拉取请求</p>
<p>1.1 从PullRequest中获取ProcessQueue,如果处理队列当前状态未被丢弃，则更新ProcessQueue的lastPullTimestamp为当前时间戳；如果当前消费者被挂起，则将拉取任务延迟1s再次放入到PullMessageService的拉取任务中，结束本次消息拉取。</p>
<p>1.2 进行消息拉取流量控制</p>
<p>PushConsumer有个线程池，消息处理逻辑在各个线程里同时执行，在PushConsumer运行的时候，每个Message Queue都有一个对用的ProcessQueue对象，保存了这个Message Queue 消息处理状态的快照。</p>
<p>ProcessQueue对象里主要内容是一个TreeMap和一个读写锁。TreeMap里以Message Queue的Offset作为Key，以消息内容的引用为Value,保存了所有从MessageQueue获取的，但是还未被处理的信息，读写锁控制着多个线程对TreeMap对象的并发处理。</p>
<p>流量控制策略：</p>
<ul>
<li>消息处理总数，如果ProcessQueue当前处理的消息超过了pullThresholdForQueue=1000将触发流量控制，放弃本次拉取任务，并且该队列的下一次拉取任务将在50毫秒后才加入到拉取任务队列中。</li>
<li>ProcessQueue中队列最大偏移量与最小偏移量的间距，不能超过consumeConcurrencyMaxSpan,否则触发流量控制。</li>
</ul>
<p>1.3 拉取该主题订阅信息，如果为空，结束本次消息拉取，关于该队列的下一次拉取任务延迟3秒。<br>1.4 构建消息拉取系统标记。<br>1.5 调用PullAPIWrapper.pullKernelImpl方法后与服务端交互。<br>1.6 根据brokerName、BrokerId从MQClientInstance中获取Broker地址，在整个RocketMQ Broker的部署结构中，相同名称的Broker构成主从结构，其BrokerId会不一样，在每次拉取消息后，会给出一个建议，下次拉取从主节点还是从节点拉取。</p>
</li>
</ol>
<p>然后是消息服务端Broker组装消息。会根据处理的结果返回不同的状态编码。<br>主要有下面几种状态编码。</p>
<ul>
<li>SUCCESS : 成功</li>
<li>PULL_RETRY_IMMEDIATElY : 立即重试</li>
<li>PULL_OFFSET_MOVED : 偏移量移动</li>
<li>PULL_NOT_FOUND : 未找到消息</li>
</ul>
<ol start="3">
<li>消息拉取客户端处理消息。</li>
</ol>
<p>先分析状态编码为SUCCESS的后续处理步骤。</p>
<ul>
<li>更新PullRequest的下一次拉取偏移量，如果msgFoundList为空，则立即将PullRequest放入到PullMessageService的pullRequestQueue,以便PullMessageService能及时唤醒并再次执行消息拉取。</li>
<li>将拉取到的消息存放到ProcessQueue,然后将拉取到的消息提交到ConsumeMessageService中供消费者消费。</li>
<li>将消费提交给消费者线程之后PullCallBack将立即返回，可以说本次消息拉取顺利完成，然后根据pullInterval参数，如果pullInterval &gt; 0,则等待pullInterval毫秒后将PullRequest对象放入到PullMessageService的pullRequestQueue中，该消息队列的下次拉取即将被激活，达到持续消息拉取，实现准实时拉取消息的效果。</li>
</ul>
<p>如果拉取结果为偏移量非法，首先将ProcessQueue设置dropped为ture,表示丢弃该消息队列，意味着ProcessQueue中拉取的消息将停止消费，然后根据服务端下一次校对的偏移量尝试更新消息消费进度，然后尝试持久化消息消费进度，并将该消息队列从RebalanceImpl的处理队列中移除，意味着暂停该消息队列的消息拉取，等待下一次消息队列重新加载。</p>
<p>这篇对消息拉取的笔记就暂时写到这里，下一篇阿静详细介绍关于消息拉取失败后的长轮询方法。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/11/26/RocketMQ消息消费之长轮询/" class="prev">上一篇</a><a href="/2019/11/09/RocketMQ阅读笔记之消息存储/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2019/11/17/RocketMQ阅读笔记之消息消费/';
var disqus_title = 'RocketMQ阅读笔记之消息消费的消息拉取';
var disqus_url = 'https://github.com/spurstong/2019/11/17/RocketMQ阅读笔记之消息消费/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2018 - 2019 <a href="https://github.com/spurstong">Mara Tong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>