<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> RocketMQ阅读笔记之消息发送 · 房东的小黑</title><meta name="description" content="RocketMQ阅读笔记之消息发送 - Mara Tong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/spurstong/atom.xml" title="房东的小黑"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/black.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">JIANSHU</a></li><li class="nav-list-item"><a href="https://github.com/spurstong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">房东的小黑黑</a></li></ul><div class="mySign">路途虽遥远，将来更美好</div></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">RocketMQ阅读笔记之消息发送</h1><div class="post-info">2019年10月31日</div><div class="post-content"><p>上篇文章中我们可以了解到NameServer需要等Broker失效至少120s才能将该Broker从路由表中移除，那如果在Broker故障期间，消息生产者Producer根据获取到的路由信息可能包含已经宕机的Broker,会导致消息发送失败，在接下来的消息发送阶段会解决这个问题。</p>
<a id="more"></a>
<h1 id="初识消息有关类"><a href="#初识消息有关类" class="headerlink" title="初识消息有关类"></a>初识消息有关类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8445773977080406428L</span>;  </span><br><span class="line">    # 消息所属主题</span><br><span class="line">    <span class="keyword">private</span> String topic;</span><br><span class="line"> # 消息Flag</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> flag;</span><br><span class="line"> # 扩展属性</span><br><span class="line"> <span class="keyword">private</span> Map&lt;String, String&gt; properties;</span><br><span class="line"> # 消息体</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">byte</span>[] body;</span><br><span class="line"> <span class="keyword">private</span> String transactionId;</span><br></pre></td></tr></table></figure>

<p>其中，Message扩展属性主要包括下面几个：</p>
<ul>
<li>tag : 消息Tag,用于消息过滤</li>
<li>keys ：Message索引建，多个用空格隔开，RocketMQ可以根据这些key快速检索到消息</li>
<li>waitStoreMsgOK ： 消息发送时是否等到消息存储完成后再返回</li>
<li>delayTimeLevel : 消息延迟级别，用于定时消息或消息重试</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultMQProducer</span> <span class="keyword">extends</span> <span class="title">ClientConfig</span> <span class="keyword">implements</span> <span class="title">MQProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InternalLogger log = ClientLogger.getLog();    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Wrapping internal implementations for virtually all methods presented in this class. */</span>  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">transient</span> DefaultMQProducerImpl defaultMQProducerImpl;   </span><br><span class="line">  # 生产者所属组，消息服务器在回查事务状态时会随机选择该组中的任何一个生产者发起事务回查请求</span><br><span class="line">  <span class="keyword">private</span> String producerGroup;   </span><br><span class="line">  <span class="keyword">private</span> String createTopicKey = MixAll.AUTO_CREATE_TOPIC_KEY_TOPIC;    </span><br><span class="line">  # 默认主题在每一个Broker队列的数量</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> defaultTopicQueueNums = <span class="number">4</span>;    </span><br><span class="line">  # 发送消息默认超时时间，默认3秒</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> sendMsgTimeout = <span class="number">3000</span>;</span><br><span class="line">  # 消息体超过该值则启用压缩，默认4K     </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> compressMsgBodyOverHowmuch = <span class="number">1024</span> * <span class="number">4</span>;    </span><br><span class="line">  # 同步方式发送消息重试次数，默认为2，总共执行3次</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> retryTimesWhenSendFailed = <span class="number">2</span>;</span><br><span class="line">  # 异步方式发送消息重试次数，默认为2    </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> retryTimesWhenSendAsyncFailed = <span class="number">2</span>; </span><br><span class="line">  # 允许发送的最大消息长度   </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxMessageSize = <span class="number">1024</span> * <span class="number">1024</span> * <span class="number">4</span>; <span class="comment">// 4M    </span></span><br><span class="line">  <span class="keyword">private</span> TraceDispatcher traceDispatcher = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueue</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">MessageQueue</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6191200464116433425L</span>;</span><br><span class="line"> <span class="keyword">private</span> String topic;</span><br><span class="line"> <span class="keyword">private</span> String brokerName;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> queueId;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicPublishInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> orderTopic = <span class="keyword">false</span>;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">boolean</span> haveTopicRouterInfo = <span class="keyword">false</span>;</span><br><span class="line"> <span class="keyword">private</span> List&lt;MessageQueue&gt; messageQueueList = <span class="keyword">new</span> ArrayList&lt;MessageQueue&gt;();</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadLocalIndex sendWhichQueue = <span class="keyword">new</span> ThreadLocalIndex();</span><br><span class="line"> <span class="keyword">private</span> TopicRouteData topicRouteData;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TopicRouteData</span> <span class="keyword">extends</span> <span class="title">RemotingSerializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String orderTopicConf;</span><br><span class="line">    <span class="keyword">private</span> List&lt;QueueData&gt; queueDatas;</span><br><span class="line">    <span class="keyword">private</span> List&lt;BrokerData&gt; brokerDatas;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String<span class="comment">/* brokerAddr */</span>, List&lt;String&gt;<span class="comment">/* Filter Server */</span>&gt; filterServerTable;</span><br></pre></td></tr></table></figure>

<h1 id="发送信息总体过程"><a href="#发送信息总体过程" class="headerlink" title="发送信息总体过程"></a>发送信息总体过程</h1><ol>
<li>发送消息的入口  DefaultMQProducerImpl#send()  ，默认消息发送以同步方式发送，默认超时时间为3s。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg, SendCallback sendCallback)</span> <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException </span>&#123;</span><br><span class="line">       send(msg, sendCallback, <span class="keyword">this</span>.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg, SendCallback sendCallback, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> MQClientException, RemotingException, InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">this</span>.sendDefaultImpl(msg, CommunicationMode.ASYNC, sendCallback, timeout);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> MQClientException(<span class="string">"unknownn exception"</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>调用sendDefaultImpl，形参为下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> SendResult <span class="title">sendDefaultImpl</span><span class="params">(//</span></span></span><br><span class="line"><span class="function"><span class="params">       Message msg, //</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> CommunicationMode communicationMode, //</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> SendCallback sendCallback, //</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="keyword">final</span> <span class="keyword">long</span> timeout//</span></span></span><br><span class="line"><span class="function"><span class="params">   )</span></span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>其中，CommunicationMode表示消息发送的方式，同步、异步和单向。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> CommunicationMode &#123;</span><br><span class="line">    SYNC,</span><br><span class="line">    ASYNC,</span><br><span class="line">    ONEWAY,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后会验证服务服务是否可用，消息是否符合规范，具体的验证就不解释了。<br>然后记录当前时间，后面会判断是否timeout。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> beginTimestampFirst = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">long</span> beginTimestampPrev = beginTimestampFirst;</span><br></pre></td></tr></table></figure>

<p>根据要发送消息的topic,寻找该topic的路由信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.tryToFindTopicPublishInfo(msg.getTopic());</span><br></pre></td></tr></table></figure>

<p>当前类有一个属性，记录所有topic的路由信息和消息队列信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String<span class="comment">/* topic */</span>, TopicPublishInfo&gt; topicPublishInfoTable =</span><br><span class="line">        <span class="keyword">new</span> ConcurrentHashMap&lt;String, TopicPublishInfo&gt;();</span><br></pre></td></tr></table></figure>

<p>首先从topicPublishInfoTable中查找该topic的topicPublishInfoTable信息，<br>如果不存在当前topic的信息或者当前topicPublishInfoTable不可用，则先新创建一个TopicPublishInfo()，并放入到topicPublishInfoTable中，然后向NameServer查询该topic的路由信息，此时会调用MQClientInstance的updateTopicRouteInfoFromNameServer(topic)方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TopicPublishInfo <span class="title">tryToFindTopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存中获取 Topic发布信息</span></span><br><span class="line">    TopicPublishInfo topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    <span class="comment">// 当无或者可用的 Topic信息时，从Namesrv获取一次 并且缓存</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == topicPublishInfo || !topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.topicPublishInfoTable.putIfAbsent(topic, <span class="keyword">new</span> TopicPublishInfo());<span class="comment">//如果key存在的情况下，在putIfAbsent下不会修改</span></span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic); <span class="comment">//进行调用获取规则存下来</span></span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, <span class="keyword">true</span>, <span class="keyword">this</span>.defaultMQProducer);</span><br><span class="line">        topicPublishInfo = <span class="keyword">this</span>.topicPublishInfoTable.get(topic);</span><br><span class="line">        <span class="keyword">return</span> topicPublishInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock lockNamesrv = <span class="keyword">new</span> ReentrantLock();</span><br></pre></td></tr></table></figure>

<p>MQClientInstance#updateTopicRouteInfoFromNameServer方法,LOCK_TIMEOUT_MILLIS默认是3秒，在此处用到了ReentrantLock.tryLock。<br>该锁的方法的简单解释：<br>假如线程A和线程B使用同一个锁Lock,此时线程A首先获取锁Lock.lock(),并且始终持有不释放，如果此时B要去获取锁，调用tryLock(3000, mils),则说明在3秒内如果线程A释放锁，会获取到锁并返回true,否则3秒过后会获取不到锁并返回false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.lockNamesrv.tryLock(LOCK_TIMEOUT_MILLIS, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br></pre></td></tr></table></figure>

<p>如果isDefault为true,则使用默认主题去查询，如果查询到路由信息，则替换路由信息中读写队列个数为消息生产者默认的队列个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TopicRouteData topicRouteData;</span><br><span class="line"><span class="keyword">if</span> (isDefault &amp;&amp; defaultMQProducer != <span class="keyword">null</span>) &#123;</span><br><span class="line">    topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getDefaultTopicRouteInfoFromNameServer(defaultMQProducer.getCreateTopicKey(),</span><br><span class="line">        <span class="number">1000</span> * <span class="number">3</span>);<span class="comment">//获取topic规则</span></span><br><span class="line">    <span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (QueueData data : topicRouteData.getQueueDatas()) &#123;</span><br><span class="line">            <span class="keyword">int</span> queueNums = Math.min(defaultMQProducer.getDefaultTopicQueueNums(), data.getReadQueueNums());</span><br><span class="line">            data.setReadQueueNums(queueNums);</span><br><span class="line">            data.setWriteQueueNums(queueNums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果isDefault为false,则使用参数topic去查询，如果未查询到路由信息，则返回false,表示路由信息未变化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    topicRouteData = <span class="keyword">this</span>.mQClientAPIImpl.getTopicRouteInfoFromNameServer(topic, <span class="number">1000</span> * <span class="number">3</span>);</span><br><span class="line">                    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果路由信息找到，与本地缓存中的路由信息进行对比，判断路由信息是否发生了变化，如果没有发生变化，则直接返回fasle。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (topicRouteData != <span class="keyword">null</span>) &#123;</span><br><span class="line">    TopicRouteData old = <span class="keyword">this</span>.topicRouteTable.get(topic);</span><br><span class="line">    <span class="keyword">boolean</span> changed = topicRouteDataIsChange(old, topicRouteData);</span><br><span class="line">    <span class="keyword">if</span> (!changed) &#123;</span><br><span class="line">        changed = <span class="keyword">this</span>.isNeedUpdateTopicRouteInfo(topic);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"the topic[&#123;&#125;] route info changed, old[&#123;&#125;] ,new[&#123;&#125;]"</span>, topic, old, topicRouteData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果发生了变化，先对topicRouteData进行复制，然后根据获得的topicRouteData信息对brokerAddrTable进行更新，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (changed) &#123;</span><br><span class="line">    TopicRouteData cloneTopicRouteData = topicRouteData.cloneTopicRouteData();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (BrokerData bd : topicRouteData.getBrokerDatas()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.brokerAddrTable.put(bd.getBrokerName(), bd.getBrokerAddrs());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>根据topicRouteData中的List&lt;\queueData&gt;转化成topicPublishInfo的List&lt;\MessageQueue&gt;列表。具体的是在topicRouteData2TopicPublishInfo中实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TopicPublishInfo publishInfo = topicRouteData2TopicPublishInfo(topic, topicRouteData);</span><br><span class="line">publishInfo.setHaveTopicRouterInfo(<span class="keyword">true</span>);</span><br><span class="line">Iterator&lt;Entry&lt;String, MQProducerInner&gt;&gt; it = <span class="keyword">this</span>.producerTable.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    Entry&lt;String, MQProducerInner&gt; entry = it.next();</span><br><span class="line">    MQProducerInner impl = entry.getValue();</span><br><span class="line">    <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">        impl.updateTopicPublishInfo(topic, publishInfo);<span class="comment">//更新topic的PublishInfo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>循环遍历路由信息的QueueData信息，如果队列没有写权限，则继续遍历下一个QueueData,根据brokerName找到brokerData信息，找不到或没有找到Master节点，则遍历下一个QueueData,根据写队列个数，根据topic+序号创建MessageQueue,填充topicPublishInfo的List&lt;\QueueMessage&gt;,此时，完成了消息发送的路由查找。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//topicRouteData转换为TopicPublishInfo</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TopicPublishInfo <span class="title">topicRouteData2TopicPublishInfo</span><span class="params">(<span class="keyword">final</span> String topic, <span class="keyword">final</span> TopicRouteData route)</span> </span>&#123;</span><br><span class="line">        TopicPublishInfo info = <span class="keyword">new</span> TopicPublishInfo();</span><br><span class="line">        info.setTopicRouteData(route);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有序</span></span><br><span class="line">        <span class="keyword">if</span> (route.getOrderTopicConf() != <span class="keyword">null</span> &amp;&amp; route.getOrderTopicConf().length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            String[] brokers = route.getOrderTopicConf().split(<span class="string">";"</span>);</span><br><span class="line">            <span class="keyword">for</span> (String broker : brokers) &#123;</span><br><span class="line">                String[] item = broker.split(<span class="string">":"</span>);</span><br><span class="line">                <span class="keyword">int</span> nums = Integer.parseInt(item[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums; i++) &#123;</span><br><span class="line">                    MessageQueue mq = <span class="keyword">new</span> MessageQueue(topic, item[<span class="number">0</span>], i);</span><br><span class="line">                    info.getMessageQueueList().add(mq);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            info.setOrderTopic(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//无序</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            List&lt;QueueData&gt; qds = route.getQueueDatas();</span><br><span class="line">            Collections.sort(qds);<span class="comment">//按照brokerName升序进行排序的</span></span><br><span class="line">            <span class="keyword">for</span> (QueueData qd : qds) &#123;</span><br><span class="line">                <span class="keyword">if</span> (PermName.isWriteable(qd.getPerm())) &#123;</span><br><span class="line">                    BrokerData brokerData = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">for</span> (BrokerData bd : route.getBrokerDatas()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (bd.getBrokerName().equals(qd.getBrokerName())) &#123;</span><br><span class="line">                            brokerData = bd;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> == brokerData) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!brokerData.getBrokerAddrs().containsKey(MixAll.MASTER_ID)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; qd.getWriteQueueNums(); i++) &#123;</span><br><span class="line">                        MessageQueue mq = <span class="keyword">new</span> MessageQueue(topic, qd.getBrokerName(), i);</span><br><span class="line">                        info.getMessageQueueList().add(mq);<span class="comment">//由于brokerName是排序的，TopicPublishInfo里面的messageQueueList就是有序的了从小到大</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            info.setOrderTopic(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>获取到路由信息之后，如果该路由信息可用，则先计算尝试的次数，如果发送模式是sync,则是3次，其他情况下是1次。<br>之后记录上次发送失败的broker名称，在第一次发送的时候，lastBrokerName为null,然后根据消息队列选择策略选择消息队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (topicPublishInfo != <span class="keyword">null</span> &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">    MessageQueue mq = <span class="keyword">null</span>;</span><br><span class="line">    Exception exception = <span class="keyword">null</span>;</span><br><span class="line">    SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//发送模式是sync 会有3次其他1次</span></span><br><span class="line">    <span class="keyword">int</span> timesTotal = communicationMode == CommunicationMode.SYNC ? <span class="number">1</span> + <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendFailed() : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">            String[] brokersSent = <span class="keyword">new</span> String[timesTotal];</span><br><span class="line">            <span class="keyword">for</span> (; times &lt; timesTotal; times++) &#123;</span><br><span class="line">                String lastBrokerName = <span class="keyword">null</span> == mq ? <span class="keyword">null</span> : mq.getBrokerName(); <span class="comment">//第一次的确是null 但是如果第二次呢？ 所以这里存在的意义</span></span><br><span class="line">                MessageQueue tmpmq = <span class="keyword">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName);<span class="comment">//选择一个queue</span></span><br><span class="line">                <span class="keyword">if</span> (tmpmq != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mq = tmpmq;</span><br><span class="line">                    brokersSent[times] = mq.getBrokerName();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line">                        <span class="comment">//调用sendKernelImpl发送消息  发送消息核心</span></span><br><span class="line">                        sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        <span class="comment">//更新Broker可用信息</span></span><br><span class="line">                        <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line">                        <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">                            <span class="keyword">case</span> ASYNC:</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">case</span> SYNC:</span><br><span class="line">                                <span class="keyword">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line">                                        <span class="keyword">continue</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">return</span> sendResult;</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">true</span>);</span><br><span class="line">                        log.warn(String.format(<span class="string">"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        exception = e;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (MQClientException e) &#123;</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">true</span>);</span><br><span class="line">                        log.warn(String.format(<span class="string">"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        exception = e;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (MQBrokerException e) &#123;</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">true</span>);</span><br><span class="line">                        log.warn(String.format(<span class="string">"sendKernelImpl exception, resend at once, InvokeID: %s, RT: %sms, Broker: %s"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        exception = e;</span><br><span class="line">                        <span class="keyword">switch</span> (e.getResponseCode()) &#123;</span><br><span class="line">                           <span class="comment">// 如下异常continue，进行发送消息重试</span></span><br><span class="line">                            <span class="keyword">case</span> ResponseCode.TOPIC_NOT_EXIST:</span><br><span class="line">                            <span class="keyword">case</span> ResponseCode.SERVICE_NOT_AVAILABLE:</span><br><span class="line">                            <span class="keyword">case</span> ResponseCode.SYSTEM_ERROR:</span><br><span class="line">                            <span class="keyword">case</span> ResponseCode.NO_PERMISSION:</span><br><span class="line">                            <span class="keyword">case</span> ResponseCode.NO_BUYER_ID:</span><br><span class="line">                            <span class="keyword">case</span> ResponseCode.NOT_IN_CURRENT_UNIT:</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">default</span>:</span><br><span class="line">                                <span class="keyword">if</span> (sendResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    <span class="keyword">return</span> sendResult;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">throw</span> e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line">                        log.warn(String.format(<span class="string">"sendKernelImpl exception, throw exception, InvokeID: %s, RT: %sms, Broker: %s"</span>, invokeID, endTimestamp - beginTimestampPrev, mq), e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line"></span><br><span class="line">                        log.warn(<span class="string">"sendKernelImpl exception"</span>, e);</span><br><span class="line">                        log.warn(msg.toString());</span><br><span class="line">                        <span class="keyword">throw</span> e;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>消息队列选择策略。<br>有两种策略， sendLatencyFaultEnable=false, 默认不启用Broker故障延迟机制。<br>                       sendLatencyFaultEnable=true,启用Broker故障延迟机制。<br> 先介绍默认的消息队列选择策略，调用TopicPublishInfo#selectOneMessageQueue<br> 当第一次调用时，lastBrokerName为null,对sendWhichQueue本地线程变量进行加1，并与当前路由表中消息队列个数取模，返回该位置的MessageQueue。<br> 如果该消息发送失败，则可能会进行重试发送，此时，lastBrokerName不是null,会记录上次信息发送失败的BrokerName,之后获取sendWhichQueue本地线程变量进行加1，并与当前路由表中消息队列个数取模，获取该位置上的MessageQueue,如果获取的该信息的BrokerName与上一次发送失败的lastBrokerName不相同，则返回该信息，否则再遍历下一个消息，直到第一个不与lastBrokerName相同的消息返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">(<span class="keyword">final</span> String lastBrokerName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastBrokerName == <span class="keyword">null</span>) &#123;<span class="comment">//第一次进入就是空的</span></span><br><span class="line">            <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> index = <span class="keyword">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.messageQueueList.size(); i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = Math.abs(index++) % <span class="keyword">this</span>.messageQueueList.size();</span><br><span class="line">                <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                    pos = <span class="number">0</span>;</span><br><span class="line">                MessageQueue mq = <span class="keyword">this</span>.messageQueueList.get(pos);</span><br><span class="line">                <span class="keyword">if</span> (!mq.getBrokerName().equals(lastBrokerName)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> mq;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> selectOneMessageQueue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MessageQueue <span class="title">selectOneMessageQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> index = <span class="keyword">this</span>.sendWhichQueue.getAndIncrement();</span><br><span class="line">       <span class="keyword">int</span> pos = Math.abs(index) % <span class="keyword">this</span>.messageQueueList.size();</span><br><span class="line">       <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">           pos = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.messageQueueList.get(pos);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>接下来讲解启用Broker故障延迟机制的消息选择策略<br>前面部分和上述介绍的差不多，根据index先获取当前位置的消息，然后判断该消息队列是否可用，通过isAvailable方法判断。如果该消息队列可用，在上次发送，或者这次发送的消息队列的broker姓名与上次发送失败的broker姓名一致，则返回该消息队列。<br>如果所有的broker都预计不可用，随机选择一个不可用的broker,再从路由信息中选择下一个消息队列，将该消息队列的broker重置为上面随机选择的broker,并重置queueId,并返回该消息队列。但是，如果该随机选择的broker内已经没有要发送的消息队列时，则需要将该broker从latencyFaultTolerance中移除，并利用默认的选择机制选择一个消息队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延迟故障容错，维护每个Broker的发送消息的延迟</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> LatencyFaultTolerance&lt;String&gt; latencyFaultTolerance = <span class="keyword">new</span> LatencyFaultToleranceImpl();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123; <span class="comment">//发送消息延迟容错开关</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> index = tpInfo.getSendWhichQueue().getAndIncrement();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</span><br><span class="line">            <span class="keyword">if</span> (pos &lt; <span class="number">0</span>)</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</span><br><span class="line">            <span class="keyword">if</span> (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</span><br><span class="line">                    <span class="keyword">return</span> mq;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</span><br><span class="line">        <span class="keyword">int</span> writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</span><br><span class="line">        <span class="keyword">if</span> (writeQueueNums &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> MessageQueue mq = tpInfo.selectOneMessageQueue();</span><br><span class="line">            <span class="keyword">if</span> (notBestBroker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mq.setBrokerName(notBestBroker);</span><br><span class="line">                mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> mq;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            latencyFaultTolerance.remove(notBestBroker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.eror(<span class="string">"Error occurred when selecting message queue"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tpInfo.selectOneMessageQueue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面部分是根据不同策略选择消息队列的具体解释，获取到消息队列之后，返回到发送消息的最外层方法endDefaultImpl中，执行消息发送步骤。</p>
<h1 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h1><p>tmpmq是选择获取到的消息队列。<br>brokersSent是存储消息发送的broker,由上面可知，如果发送方式是同步，则该数组长度为3，其他方式下长度为1。然后记录当前时间，然后执行<em>sendKernelImpl</em>方法进行发送消息。之后，获取发送完之后的时间，执行<em>updateFaultItem</em>方法来更新Broker异常信息，一个broker会对应一个faultItem。<br>之后，根据消息发送的方式，如果是同步的，如果此次消息没有成功，则可以再进行尝试，如果是异步或者单向，则执行结束。如果期间发送了异常，则会调用<em>updateFaultItem</em>方法来更新Broker异常信息。<br>接下来详细介绍<em>sendKernelImpl</em>方法和<em>updateFaultItem</em>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue tmpmq = <span class="keyword">this</span>.selectOneMessageQueue(topicPublishInfo, lastBrokerName)</span><br><span class="line"><span class="keyword">if</span> (tmpmq != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mq = tmpmq;</span><br><span class="line">    brokersSent[times] = mq.getBrokerName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//调用sendKernelImpl发送消息  发送消息核心</span></span><br><span class="line">        sendResult = <span class="keyword">this</span>.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout);</span><br><span class="line">        endTimestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//更新Broker可用信息</span></span><br><span class="line">        <span class="keyword">this</span>.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">            <span class="keyword">case</span> ASYNC:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> ONEWAY:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">case</span> SYNC:</span><br><span class="line">                <span class="keyword">if</span> (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">this</span>.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> sendResult;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="DefaultMQProducerImpl-sendKernelImpl"><a href="#DefaultMQProducerImpl-sendKernelImpl" class="headerlink" title="DefaultMQProducerImpl.sendKernelImpl"></a>DefaultMQProducerImpl.sendKernelImpl</h2><p>该方法的形参有：</p>
<ul>
<li>Message msg : 待发送的消息</li>
<li>MessageQueue mq : 消息将发送到该消息队列上</li>
<li>CommunicationMode commuicationMode : 消息发送模式，SYNC、ASYNC、ONEWAy</li>
<li>SendCallback sendCallback :异步消息回调函数</li>
<li>TopicPublishInfo topicPublishInfo ： 主题路由信息</li>
<li>long timeout:消息发送超时时间</li>
</ul>
<ol>
<li>根据MessageQueue获取Broker的网络地址,如果MQClientInstance的brokerAddrTable未缓存该Broker的信息，则从NameServer主动更新一下topic的路由信息，如果路由更新后还是找不到Broker信息，则抛出MQClientException，提示Broker不存在。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == brokerAddr) &#123;</span><br><span class="line">            tryToFindTopicPublishInfo(mq.getTopic());</span><br><span class="line">            brokerAddr = <span class="keyword">this</span>.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>为消息分配全局唯一ID,如果消息体默认超过4K,会对消息体采用zip压缩，并设置消息的系统标记为MessageSysFlag.COMPRESED_FLAG。如果是事务Prepared消息，则设置消息的系统标记为MessageSysFlag.TRANSACTION_PREPARED_TYPE。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//for MessageBatch,ID has been set in the generating process</span></span><br><span class="line"><span class="keyword">if</span> (!(msg <span class="keyword">instanceof</span> MessageBatch)) &#123;</span><br><span class="line">    MessageClientIDSetter.setUniqID(msg);<span class="comment">//设置设置UNIQ_id，所以当看见msgId的时候为什么解析不一样了懂了吧</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sysFlag = <span class="number">0</span>; <span class="comment">//又是根据位来进行每位是啥的判断</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.tryToCompressMessage(msg)) &#123;</span><br><span class="line">    sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);<span class="comment">//根据事务属性key获取值看是否是事务消息</span></span><br><span class="line"><span class="keyword">if</span> (tranMsg != <span class="keyword">null</span> &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line">    sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果注册了消息发送钩子函数，则执行消息发送之前的增强逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">                context = <span class="keyword">new</span> SendMessageContext();</span><br><span class="line">                context.setProducer(<span class="keyword">this</span>);</span><br><span class="line">                context.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">                context.setCommunicationMode(communicationMode);</span><br><span class="line">                context.setBornHost(<span class="keyword">this</span>.defaultMQProducer.getClientIP());</span><br><span class="line">                context.setBrokerAddr(brokerAddr);</span><br><span class="line">                context.setMessage(msg);</span><br><span class="line">                context.setMq(mq);</span><br><span class="line">                String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">                <span class="keyword">if</span> (isTrans != <span class="keyword">null</span> &amp;&amp; isTrans.equals(<span class="string">"true"</span>)) &#123;</span><br><span class="line">                    context.setMsgType(MessageType.Trans_Msg_Half);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (msg.getProperty(<span class="string">"__STARTDELIVERTIME"</span>) != <span class="keyword">null</span> || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    context.setMsgType(MessageType.Delay_Msg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">this</span>.executeSendMessageHookBefore(context);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建消息发送请求包。主要包含下列重要信息：</p>
</li>
</ol>
<ul>
<li>生产者组、主题名称、默认创建主题Key、该主题在单个Broker默认队列数、队列ID</li>
<li>消息系统标记、消息发送时间、消息标记、消息扩展属性、消息重试次数、是否是批量信息。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//构建SendMessageRequestHeader</span></span><br><span class="line">SendMessageRequestHeader requestHeader = <span class="keyword">new</span> SendMessageRequestHeader();</span><br><span class="line">    requestHeader.setProducerGroup(<span class="keyword">this</span>.defaultMQProducer.getProducerGroup());</span><br><span class="line">    requestHeader.setTopic(msg.getTopic());</span><br><span class="line">    requestHeader.setDefaultTopic(<span class="keyword">this</span>.defaultMQProducer.getCreateTopicKey());</span><br><span class="line">    requestHeader.setDefaultTopicQueueNums(<span class="keyword">this</span>.defaultMQProducer.getDefaultTopicQueueNums());</span><br><span class="line">    requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line">    requestHeader.setSysFlag(sysFlag);</span><br><span class="line">    <span class="comment">//生成消息时间戳</span></span><br><span class="line">    requestHeader.setBornTimestamp(System.currentTimeMillis());</span><br><span class="line">    requestHeader.setFlag(msg.getFlag());</span><br><span class="line">    requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line">    requestHeader.setReconsumeTimes(<span class="number">0</span>);</span><br><span class="line">    requestHeader.setUnitMode(<span class="keyword">this</span>.isUnitMode());</span><br><span class="line">    requestHeader.setBatch(msg <span class="keyword">instanceof</span> MessageBatch);</span><br><span class="line">    <span class="keyword">if</span> (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123;</span><br><span class="line">        String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</span><br><span class="line">        <span class="keyword">if</span> (reconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</span><br><span class="line">            MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</span><br><span class="line">        <span class="keyword">if</span> (maxReconsumeTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</span><br><span class="line">            MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>按照消息发送方式，同步、异步、单向方式进行网络传输。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">SendResult sendResult = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">switch</span> (communicationMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> ASYNC:</span><br><span class="line">        sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(<span class="comment">//异步发送消息</span></span><br><span class="line">            brokerAddr, <span class="comment">// 1</span></span><br><span class="line">            mq.getBrokerName(), <span class="comment">// 2</span></span><br><span class="line">            msg, <span class="comment">// 3</span></span><br><span class="line">            requestHeader, <span class="comment">// 4</span></span><br><span class="line">            timeout, <span class="comment">// 5</span></span><br><span class="line">            communicationMode, <span class="comment">// 6</span></span><br><span class="line">            sendCallback, <span class="comment">// 7</span></span><br><span class="line">            topicPublishInfo, <span class="comment">// 8</span></span><br><span class="line">            <span class="keyword">this</span>.mQClientFactory, <span class="comment">// 9</span></span><br><span class="line">            <span class="keyword">this</span>.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(), <span class="comment">// 10</span></span><br><span class="line">            context, <span class="comment">//</span></span><br><span class="line">            <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ONEWAY:</span><br><span class="line">    <span class="keyword">case</span> SYNC:</span><br><span class="line">        sendResult = <span class="keyword">this</span>.mQClientFactory.getMQClientAPIImpl().sendMessage(<span class="comment">//同步以及广播发送消息</span></span><br><span class="line">            brokerAddr,</span><br><span class="line">            mq.getBrokerName(),</span><br><span class="line">            msg,</span><br><span class="line">            requestHeader,</span><br><span class="line">            timeout,</span><br><span class="line">            communicationMode,</span><br><span class="line">            context,</span><br><span class="line">            <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.hasSendMessageHook()) &#123;</span><br><span class="line">    context.setSendResult(sendResult);</span><br><span class="line">    <span class="keyword">this</span>.executeSendMessageHookAfter(context); <span class="comment">//发送消息后逻辑</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> sendResult;</span><br></pre></td></tr></table></figure>
</li>
<li><p>之后就是按照不同的方式进行发送。在发送之前会检查消息发送是否合理，检查该Broker是否有写权限，该Topic是否可以进行消息发送，在NameServer端存储主题的配置信息，除此之外，开始检查队列，如果队列不合法，返回错误码</p>
</li>
<li><p>如果消息重试次数超过允许的最大重试次数，消息将进入到DLD延迟队列。延迟队列主题：%DLQ%+消费组名，</p>
</li>
<li><p>调用DefaultMessageStore.putMessage进行消息存储。</p>
</li>
</ol>
<h2 id="DefaultMQProducerImpl-updateFaultItem"><a href="#DefaultMQProducerImpl-updateFaultItem" class="headerlink" title="DefaultMQProducerImpl.updateFaultItem"></a>DefaultMQProducerImpl.updateFaultItem</h2><p>由上面可知，在执行消息发送完之后和出现发送异常的时候，会调用该方法对broker进行异常更新。<br>形参解释：</p>
<ul>
<li>brokerName : broker名称</li>
<li>currentLatency : 本次消息发送延迟时间currentLatency </li>
<li>isolation : 是否隔离，如果为true,则使用默认时长30s来计算BroKer故障规避时长；如果为false,则使用本次消息发送延迟时间来计算Broker故障规避时长。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String brokerName, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">boolean</span> isolation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.sendLatencyFaultEnable) &#123;</span><br><span class="line">            <span class="keyword">long</span> duration = computeNotAvailableDuration(isolation ? <span class="number">30000</span> : currentLatency);</span><br><span class="line">            <span class="keyword">this</span>.latencyFaultTolerance.updateFaultItem(brokerName, currentLatency, duration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li><p>利用<em>computeNotAvailableDuration()</em> 方法计算规避时长。<br>从latencyMax数组尾部开始查找，找到第一个比currentLatency小的下标，然后从notAvailableDuration数组中获取需要规避的时长。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//延迟级别数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] latencyMax = &#123;<span class="number">50L</span>, <span class="number">100L</span>, <span class="number">550L</span>, <span class="number">1000L</span>, <span class="number">2000L</span>, <span class="number">3000L</span>, <span class="number">15000L</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不可用时长数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span>[] notAvailableDuration = &#123;<span class="number">0L</span>, <span class="number">0L</span>, <span class="number">30000L</span>, <span class="number">60000L</span>, <span class="number">120000L</span>, <span class="number">180000L</span>, <span class="number">600000L</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">computeNotAvailableDuration</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> currentLatency)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = latencyMax.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (currentLatency &gt;= latencyMax[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.notAvailableDuration[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据broker名称从缓存表faultItemTable中获取FaultItem,如果找到则更新FaultItem,否则创建FaultItem。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, FaultItem&gt; faultItemTable = <span class="keyword">new</span> ConcurrentHashMap&lt;String, FaultItem&gt;(<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateFaultItem</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">final</span> <span class="keyword">long</span> currentLatency, <span class="keyword">final</span> <span class="keyword">long</span> notAvailableDuration)</span> </span>&#123;</span><br><span class="line">    FaultItem old = <span class="keyword">this</span>.faultItemTable.get(name);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == old) &#123;</span><br><span class="line">        <span class="keyword">final</span> FaultItem faultItem = <span class="keyword">new</span> FaultItem(name);</span><br><span class="line">        faultItem.setCurrentLatency(currentLatency);</span><br><span class="line">        faultItem.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line"></span><br><span class="line">        old = <span class="keyword">this</span>.faultItemTable.putIfAbsent(name, faultItem);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.setCurrentLatency(currentLatency);</span><br><span class="line">            old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        old.setCurrentLatency(currentLatency);</span><br><span class="line">        old.setStartTimestamp(System.currentTimeMillis() + notAvailableDuration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>一个broker对应一个faultItem,记录broker名称、消息发送时长和broker恢复正常时间。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FaultItem</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">FaultItem</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> currentLatency;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> startTimestamp;</span><br></pre></td></tr></table></figure>

<h1 id="批量消息发送"><a href="#批量消息发送" class="headerlink" title="批量消息发送"></a>批量消息发送</h1><p>批量消息发送就是将同一主题的多条信息一起打包发送到消息服务端，减少网络调用次数。<br>单挑信息发送时，消息体的内容将保存在body中。批量消息发送，需要将多条消息体的内容采用固定格式存储在body中。<br>在消息发送端，调用batch方法，将一批消息封装成MessageBatch对象，之后的处理流程与上面的基本一致，只需要将该集合的每一条消息的消息体body聚合成一个byte[]数值，在消息服务端能够从该byte[]数值中正确解析消息即可。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/11/09/RocketMQ阅读笔记之消息存储/" class="prev">上一篇</a><a href="/2019/10/22/RocketMQ阅读笔记之路由中心NameServer/" class="next">下一篇</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2019/10/31/RocketMQ阅读笔记之消息发送/';
var disqus_title = 'RocketMQ阅读笔记之消息发送';
var disqus_url = 'https://github.com/spurstong/2019/10/31/RocketMQ阅读笔记之消息发送/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script><div class="copyright"><p>© 2018 - 2019 <a href="https://github.com/spurstong">Mara Tong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>