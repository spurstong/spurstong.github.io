<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 数据同步与对synchonized的深入理解 · 房东的小黑</title><meta name="description" content="数据同步与对synchonized的深入理解 - Mara Tong"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/spurstong/atom.xml" title="房东的小黑"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/black.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/tags/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://www.jianshu.com/u/a8d49bf62c45" target="_blank" class="nav-list-link">JIANSHU</a></li><li class="nav-list-item"><a href="https://github.com/spurstong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/about" target="_self" class="nav-list-link">ABOUT</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">数据同步与对synchonized的深入理解</h1><div class="post-info">2019年6月25日</div><div class="post-content"><blockquote>
<p>前言</p>
</blockquote>
<p>在上文中，我写了ReentrantLock有关的代码分析，它是基于Lock基础类的。在Java中一般有两种实现锁的方式，一种是基于Lock的，一种是基于JVM的synchonized锁的，在本文中将要介绍后面一种方式。jDK官网中对它进行了这样的解释：它可以实现一个简单的策略来防止线程干扰和内存一致性错误，如果一个对象对多个线程是可见的，那么对该对象的所有读或者写都将通过同步的方式来继续来进行。<br>它具备下面几个特点</p>
<ol>
<li>线程在<strong>解锁前</strong>必须把共享变量的<strong>最新值</strong>刷新到主内存中。</li>
<li>线程在<strong>加锁时</strong>将清空工作内存中共享变量的值，从而在使用共享变量时需要从主内存中重新获取最新的值</li>
<li>线程<strong>解锁前</strong>对共享变量的修改在下次<strong>加锁时</strong>对<strong>其他线程</strong>可见</li>
<li>严格遵守Java happens-before规则，一个monitor exit指令之前必定有一个monitor enter。</li>
</ol>
<h1 id="数据不一致问题"><a href="#数据不一致问题" class="headerlink" title="数据不一致问题"></a>数据不一致问题</h1><p>举一个经典的例子，创建两个线程,index=0,执行index++,并打印输出，当大于300时退出程序。<br>理想的状态是index从0逐一变到300，<br>但实际的状况会出现下面几种情况：</p>
<ul>
<li>两个线程中的index数据一致，比如都是10</li>
<li>数据输出出现了跳跃，比如，上一个数据是30，但接下来的一个却是32，丢失了31</li>
<li>数据超过了300，出现了301<br>对上面情况进行解析：</li>
<li>线程1执行index+1， 然后被暂停，执行线程2操作，由于线程1并没有对index进行赋值操作，index仍然为原值，并没有增加为10，线程2执行index+1并赋值，变成了10，之后线程执行原来停留的index+1,也为10，出现了数据的重复。</li>
<li>当线程1和线程2都执行到了index=30的位置，其中线程2将index修改为31后执行输出之前切换到了线程1，执行index+1,index变成了32，并输出，而中间的31却没有被输出</li>
<li>当index=299的时候，线程1和线程2都看到了条件满足，线程2暂时停顿，线程1中index+1变成了300，之后线程2继续执行，因为它此时已经在条件判断代码块里面，不受条件的控制，执行index+1,就变成了301</li>
</ul>
<h1 id="monitor"><a href="#monitor" class="headerlink" title="monitor"></a>monitor</h1><p>monitor机制需要几个元素来配合，分别是：</p>
<ol>
<li>临界区</li>
<li>monitor对象及锁</li>
<li>条件变量以及定义在monitor对象上的wait和signal操作。<br>使用monitor机制主要是为了互斥进入临界区，每个对象都与一个monitor相关联，一个monitor的lock的锁只能被一个线程在同一时间获得。sychronized关键字包含monitor enter和monitor exit两个JVM指令。<br>monitor存在计数器，如果为0，则说明该monitor的lock还没有被获得。某个线程获得后，该计数器会加1，当计数器为0，那就意味着该线程不再拥有该monitor的所有权。</li>
</ol>
<h1 id="synchonized出现的锁"><a href="#synchonized出现的锁" class="headerlink" title="synchonized出现的锁"></a>synchonized出现的锁</h1><p>在synchonized中会出现3类锁，偏向锁、轻量级锁和重量级锁。</p>
<ul>
<li>偏向锁是指在一段同步代码一直被一个线程访问，那么该线程就会自动获取锁，降低获取锁的代价。</li>
<li>轻量级锁是指当锁为偏向锁的时候，被另一个线程访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的方法尝试获取锁，不会阻塞，提高性能。</li>
<li>重量级锁是指当锁为轻量级锁时，另一个线程在自旋，当尝试一定次数之后，还是没有获取到锁，就会进入阻塞，该锁就会变成重量级锁，重量级锁会让其他申请的线程进入阻塞，性能降低。</li>
</ul>
<h1 id="synchonized锁的实现"><a href="#synchonized锁的实现" class="headerlink" title="synchonized锁的实现"></a>synchonized锁的实现</h1><p>主要有三种形式：</p>
<ol>
<li>修饰实例对象，作用于当前实例加锁，进入同步代码前要获得当前实例的锁</li>
<li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</li>
<li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码前获得给定对象的锁</li>
</ol>
<p><strong>对象锁(synchonized method{})和类锁(static synchonized method{})的区别</strong><br>对象锁也叫实例锁，当多个线程访问多个实例时，它们互不干扰，每个对象都拥有自己的锁<br>对象锁能防止在同一时刻多个线程访问同一个对象的synchonized块<br>类锁是一个全局锁，无论多少个对象共享一个锁，当一个线程访问时，其他线程等待。<br>将synchronized关键字加static方法和不加static方法有时可能效果是一样的，但两者有着本质的不同<br>synchronized关键字加static静态方法是将Class类对象作为锁，而synchronized关键字加到非static静态方法是将方法所在类的对象作为锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程名称为:"</span> + Thread.currentThread().getName() + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"进入printA"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            System.out.println(<span class="string">"线程名称为:"</span> + Thread.currentThread().getName() + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"离开printA"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程名称为:"</span> + Thread.currentThread().getName() + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"进入printB"</span>);</span><br><span class="line">        System.out.println(<span class="string">"线程名称为:"</span> + Thread.currentThread().getName() + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"离开printB"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">printC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"线程名称为:"</span> + Thread.currentThread().getName() + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"进入printC"</span>);</span><br><span class="line">        System.out.println(<span class="string">"线程名称为:"</span> + Thread.currentThread().getName() + <span class="string">"在"</span> + System.currentTimeMillis() + <span class="string">"离开printC"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      service.printA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadB</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        service.printB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadC</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadC</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        service.printC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Service service = <span class="keyword">new</span> Service();</span><br><span class="line">        ThreadA a = <span class="keyword">new</span> ThreadA(service);</span><br><span class="line">        a.setName(<span class="string">"A"</span>);</span><br><span class="line">        a.start();</span><br><span class="line"></span><br><span class="line">        ThreadB b = <span class="keyword">new</span> ThreadB(service);</span><br><span class="line">        b.setName(<span class="string">"B"</span>);</span><br><span class="line">        b.start();</span><br><span class="line"></span><br><span class="line">        ThreadC c = <span class="keyword">new</span> ThreadC(service);</span><br><span class="line">        c.setName(<span class="string">"C"</span>);</span><br><span class="line">        c.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>运行结果：<br>线程名称为:A在1561702771777进入printA<br>线程名称为:C在1561702771778进入printC<br>线程名称为:C在1561702771778离开printC<br>线程名称为:A在1561702774777离开printA<br>线程名称为:B在1561702774777进入printB<br>线程名称为:B在1561702774777离开printB</p>
<p>从中可以看出加上static和不加static是有区别的，主要是产生了不同的锁，一个是将类Service的对象作为锁，另一个是将Service类对应的Class类的对象作为锁，A、B线程和C线程是异步的关系，而A线程和B线程是同步的关系。</p>
<h1 id="synchronized锁重入"><a href="#synchronized锁重入" class="headerlink" title="synchronized锁重入"></a>synchronized锁重入</h1><p>该关键字拥有重入锁的功能，即在使用synchronized时，当一个线程得到一个对象锁后，再次请求此对象锁时也可以得到该对象锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mysyn</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syn1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"syn1"</span>);</span><br><span class="line">      syn2();  </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syn2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"syn2"</span>);</span><br><span class="line">      syn3();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syn3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"syn3"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				       Mysyn syn = <span class="keyword">new</span> Mysyn();</span><br><span class="line">       syn.syn1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       MyThread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">       t.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>结果输出：<br><strong>syn1</strong><br><strong>syn2</strong><br><strong>syn3</strong></p>
<p>上述代码中的锁是对象锁，当这个对象锁还没有被释放时，还可以重新进入获取该对象锁，如果不是可重入锁的话，是不能调用sync2()方法的。</p>
<hr>
<h1 id="不同锁形式调用"><a href="#不同锁形式调用" class="headerlink" title="不同锁形式调用"></a>不同锁形式调用</h1><p>当在一个类中定义了不同形式的synchronized()方法时，混合调用可能会产生不同的效果。</p>
<ul>
<li>锁重入支持继承的环境，当父类中定义了一个synchronized()方法时，子类继承并重新定义了该方法，并在方法内部调用了父类的方法，在实际执行中会先调用子类的方法，然后调用父类的方法。</li>
<li>重写方法如果<strong>不使用</strong>synchronized关键字，会变成<strong>非同步</strong>方法，<strong>使用</strong>后会变成<strong>同步</strong>方法</li>
<li>如果只是在方法的部分区域定义synchronized代码块，在区域内部的代码会同步，在区域外部的代码会异步</li>
<li>当先后调用synchronized(this)方法和synchronized public void func1()方法时，都会将当前类的对象作为锁，都是一把锁，运行的结果是同步的效果。</li>
<li>使用同步代码块锁非this对象，即synchronized(非this)代码块中的程序与同步方法是<strong>异步</strong>的，因为有两把锁，不与其他锁this同步方法争抢this锁，可以大大提高运行效率。</li>
<li>多个锁就是异步执行</li>
<li>同步syn static方法可以对类的所有对象实例起作用</li>
<li>同步syn(class)代码块可以对类的所有对象实例起作用</li>
<li>在大多数情况下，同步synchronized代码块不使用String作为锁对象，这是String常量池所带来的问题</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2019/06/29/深入理解volatile/" class="prev">上一篇</a><a href="/2019/06/24/ReentrantLock 可重入锁 源代码解析/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2019 <a href="https://github.com/spurstong">Mara Tong</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>